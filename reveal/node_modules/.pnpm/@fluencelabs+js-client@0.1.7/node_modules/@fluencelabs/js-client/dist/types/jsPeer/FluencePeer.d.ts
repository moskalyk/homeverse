/// <reference types="node" resolution-mode="require"/>
import { KeyPair } from '../keypair/index.js';
import { ParticleExecutionStage } from '../particle/Particle.js';
import { Sig } from '../services/Sig.js';
import { Buffer } from 'buffer';
import { Srv } from '../services/SingleModuleSrv.js';
import { Tracing } from '../services/Tracing.js';
import { IParticle } from '../particle/interfaces.js';
import { IConnection } from '../connection/interfaces.js';
import { IMarineHost } from '../marine/interfaces.js';
import { GenericCallServiceHandler, IJsServiceHost } from '../jsServiceHost/interfaces.js';
export declare type PeerConfig = {
    /**
     * Sets the default TTL for all particles originating from the peer with no TTL specified.
     * If the originating particle's TTL is defined then that value will be used
     * If the option is not set default TTL will be 7000
     */
    defaultTtlMs: number;
    /**
     * Enables\disabled various debugging features
     */
    debug: {
        /**
         * If set to true, newly initiated particle ids will be printed to console.
         * Useful to see what particle id is responsible for aqua function
         */
        printParticleId: boolean;
    };
};
export declare const DEFAULT_CONFIG: PeerConfig;
/**
 * This class implements the Fluence protocol for javascript-based environments.
 * It provides all the necessary features to communicate with Fluence network
 */
export declare abstract class FluencePeer {
    protected readonly config: PeerConfig;
    readonly keyPair: KeyPair;
    protected readonly marineHost: IMarineHost;
    protected readonly jsServiceHost: IJsServiceHost;
    protected readonly connection: IConnection;
    constructor(config: PeerConfig, keyPair: KeyPair, marineHost: IMarineHost, jsServiceHost: IJsServiceHost, connection: IConnection);
    start(): Promise<void>;
    /**
     * Un-initializes the peer: stops all the underlying workflows, stops the Aqua VM
     * and disconnects from the Fluence network
     */
    stop(): Promise<void>;
    /**
     * Registers marine service within the Fluence peer from wasm file.
     * Following helper functions can be used to load wasm files:
     * * loadWasmFromFileSystem
     * * loadWasmFromNpmPackage
     * * loadWasmFromServer
     * @param wasm - buffer with the wasm file for service
     * @param serviceId - the service id by which the service can be accessed in aqua
     */
    registerMarineService(wasm: SharedArrayBuffer | Buffer, serviceId: string): Promise<void>;
    /**
     * Removes the specified marine service from the Fluence peer
     * @param serviceId - the service id to remove
     */
    removeMarineService(serviceId: string): Promise<void>;
    /**
     * @private Is not intended to be used manually. Subject to change
     */
    get internals(): {
        getServices: () => {
            sig: Sig;
            srv: Srv;
            tracing: Tracing;
        };
        getRelayPeerId: () => string;
        parseAst: (air: string) => Promise<{
            success: boolean;
            data: any;
        }>;
        createNewParticle: (script: string, ttl?: number) => IParticle;
        /**
         * Initiates a new particle execution starting from local peer
         * @param particle - particle to start execution of
         * @param onStageChange - callback for reacting on particle state changes
         */
        initiateParticle: (particle: IParticle, onStageChange: (stage: ParticleExecutionStage) => void) => void;
        /**
         * Register Call Service handler functions
         */
        regHandler: {
            /**
             * Register handler for all particles
             */
            common: (serviceId: string, fnName: string, handler: GenericCallServiceHandler) => void;
            /**
             * Register handler which will be called only for particle with the specific id
             */
            forParticle: (particleId: string, serviceId: string, fnName: string, handler: GenericCallServiceHandler) => void;
        };
    };
    private _incomingParticles;
    private _timeouts;
    private _particleSourceSubscription?;
    private _incomingParticlePromise?;
    private _classServices;
    private isInitialized;
    private printParticleId;
    private _initServices;
    private _startParticleProcessing;
    private _expireParticle;
    private decodeAvmData;
    private _execSingleCallRequest;
    private _stopParticleProcessing;
}
