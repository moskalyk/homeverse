var nn = Object.defineProperty;
var on = (t, e, r) => e in t ? nn(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var $ = (t, e, r) => (on(t, typeof e != "symbol" ? e + "" : e, r), r), Qe = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
};
var Y = (t, e, r) => (Qe(t, e, "read from private field"), r ? r.call(t) : e.get(t)), ie = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, fe = (t, e, r, n) => (Qe(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r);
var re = (t, e, r) => (Qe(t, e, "access private method"), r);
import require$$0$4, { setMaxListeners, EventEmitter as EventEmitter$4 } from "events";
import * as WorkerScope from "worker_threads";
import { Worker } from "worker_threads";
import crypto$3, { randomFillSync as randomFillSync$1 } from "crypto";
import require$$1$1, { promisify } from "util";
import * as nc from "node:crypto";
import require$$1 from "tty";
import require$$0, { cpus } from "os";
import { isIP as isIP$1, isIPv4, isIPv6 } from "node:net";
import cluster$1 from "cluster";
import { Resolver } from "dns/promises";
import require$$0$3 from "stream";
import require$$0$1 from "zlib";
import * as fs from "fs";
import fs__default from "fs";
import * as path from "path";
import path__default from "path";
import require$$0$2, { Buffer as Buffer$1 } from "buffer";
import require$$3 from "net";
import require$$4 from "tls";
import require$$1$2 from "https";
import require$$2 from "http";
import require$$7, { fileURLToPath } from "url";
import process$2 from "process";
let FixedFIFO$1 = class {
  constructor(e) {
    if (!(e > 0) || e - 1 & e)
      throw new Error("Max size for a FixedFIFO should be a power of two");
    this.buffer = new Array(e), this.mask = e - 1, this.top = 0, this.btm = 0, this.next = null;
  }
  push(e) {
    return this.buffer[this.top] !== void 0 ? !1 : (this.buffer[this.top] = e, this.top = this.top + 1 & this.mask, !0);
  }
  shift() {
    const e = this.buffer[this.btm];
    if (e !== void 0)
      return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, e;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
}, FIFO$1 = class {
  constructor(e = {}) {
    this.hwm = e.splitLimit ?? 16, this.head = new FixedFIFO$1(this.hwm), this.tail = this.head, this.size = 0;
  }
  calculateSize(e) {
    return (e == null ? void 0 : e.byteLength) != null ? e.byteLength : 1;
  }
  push(e) {
    if ((e == null ? void 0 : e.value) != null && (this.size += this.calculateSize(e.value)), !this.head.push(e)) {
      const r = this.head;
      this.head = r.next = new FixedFIFO$1(2 * this.head.buffer.length), this.head.push(e);
    }
  }
  shift() {
    let e = this.tail.shift();
    if (e === void 0 && this.tail.next != null) {
      const r = this.tail.next;
      this.tail.next = null, this.tail = r, e = this.tail.shift();
    }
    return (e == null ? void 0 : e.value) != null && (this.size -= this.calculateSize(e.value)), e;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};
function pushable$1(t = {}) {
  return _pushable$1((r) => {
    const n = r.shift();
    if (n == null)
      return { done: !0 };
    if (n.error != null)
      throw n.error;
    return {
      done: n.done === !0,
      // @ts-expect-error
      value: n.value
    };
  }, t);
}
function _pushable$1(t, e) {
  e = e ?? {};
  let r = e.onEnd, n = new FIFO$1(), i, o, a;
  const c = async () => n.isEmpty() ? a ? { done: !0 } : await new Promise((m, y) => {
    o = (b) => {
      o = null, n.push(b);
      try {
        m(t(n));
      } catch (v) {
        y(v);
      }
      return i;
    };
  }) : t(n), l = (m) => o != null ? o(m) : (n.push(m), i), u = (m) => (n = new FIFO$1(), o != null ? o({ error: m }) : (n.push({ error: m }), i)), f = (m) => {
    if (a)
      return i;
    if ((e == null ? void 0 : e.objectMode) !== !0 && (m == null ? void 0 : m.byteLength) == null)
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    return l({ done: !1, value: m });
  }, d = (m) => a ? i : (a = !0, m != null ? u(m) : l({ done: !0 })), p = () => (n = new FIFO$1(), d(), { done: !0 }), g = (m) => (d(m), { done: !0 });
  if (i = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: c,
    return: p,
    throw: g,
    push: f,
    end: d,
    get readableLength() {
      return n.size;
    }
  }, r == null)
    return i;
  const h = i;
  return i = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return h.next();
    },
    throw(m) {
      return h.throw(m), r != null && (r(m), r = void 0), { done: !0 };
    },
    return() {
      return h.return(), r != null && (r(), r = void 0), { done: !0 };
    },
    push: f,
    end(m) {
      return h.end(m), r != null && (r(m), r = void 0), i;
    },
    get readableLength() {
      return h.readableLength;
    }
  }, i;
}
async function* merge$7(...t) {
  const e = pushable$1({
    objectMode: !0
  });
  Promise.resolve().then(async () => {
    try {
      await Promise.all(t.map(async (r) => {
        for await (const n of r)
          e.push(n);
      })), e.end();
    } catch (r) {
      e.end(r);
    }
  }), yield* e;
}
const rawPipe$1 = (...t) => {
  let e;
  for (; t.length > 0; )
    e = t.shift()(e);
  return e;
}, isIterable$3 = (t) => t != null && (typeof t[Symbol.asyncIterator] == "function" || typeof t[Symbol.iterator] == "function" || typeof t.next == "function"), isDuplex$1 = (t) => t != null && typeof t.sink == "function" && isIterable$3(t.source), duplexPipelineFn$1 = (t) => (e) => {
  const r = t.sink(e);
  if (r.then != null) {
    const n = pushable$1({
      objectMode: !0
    });
    return r.then(() => {
      n.end();
    }, (o) => {
      n.end(o);
    }), merge$7(n, async function* () {
      yield* t.source, n.end();
    }());
  }
  return t.source;
};
function pipe$3(t, ...e) {
  if (isDuplex$1(t)) {
    const n = t;
    t = () => n.source;
  } else if (isIterable$3(t)) {
    const n = t;
    t = () => n;
  }
  const r = [t, ...e];
  if (r.length > 1 && isDuplex$1(r[r.length - 1]) && (r[r.length - 1] = r[r.length - 1].sink), r.length > 2)
    for (let n = 1; n < r.length - 1; n++)
      isDuplex$1(r[n]) && (r[n] = duplexPipelineFn$1(r[n]));
  return rawPipe$1(...r);
}
function asUint8Array$1(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function alloc(t = 0) {
  var e;
  return ((e = globalThis.Buffer) == null ? void 0 : e.alloc) != null ? asUint8Array$1(globalThis.Buffer.alloc(t)) : new Uint8Array(t);
}
function allocUnsafe$3(t = 0) {
  var e;
  return ((e = globalThis.Buffer) == null ? void 0 : e.allocUnsafe) != null ? asUint8Array$1(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function concat$7(t, e) {
  e == null && (e = t.reduce((i, o) => i + o.length, 0));
  const r = allocUnsafe$3(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return asUint8Array$1(r);
}
function equals$5(t, e) {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const symbol$5 = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(t, e) {
  if (e == null || e < 0)
    throw new RangeError("index is out of bounds");
  let r = 0;
  for (const n of t) {
    const i = r + n.byteLength;
    if (e < i)
      return {
        buf: n,
        index: e - r
      };
    r = i;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(t) {
  return Boolean(t == null ? void 0 : t[symbol$5]);
}
class Uint8ArrayList {
  constructor(...e) {
    Object.defineProperty(this, symbol$5, { value: !0 }), this.bufs = [], this.length = 0, e.length > 0 && this.appendAll(e);
  }
  *[Symbol.iterator]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...e) {
    this.appendAll(e);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(e) {
    let r = 0;
    for (const n of e)
      if (n instanceof Uint8Array)
        r += n.byteLength, this.bufs.push(n);
      else if (isUint8ArrayList(n))
        r += n.byteLength, this.bufs.push(...n.bufs);
      else
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
    this.length += r;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...e) {
    this.prependAll(e);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(e) {
    let r = 0;
    for (const n of e.reverse())
      if (n instanceof Uint8Array)
        r += n.byteLength, this.bufs.unshift(n);
      else if (isUint8ArrayList(n))
        r += n.byteLength, this.bufs.unshift(...n.bufs);
      else
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
    this.length += r;
  }
  /**
   * Read the value at `index`
   */
  get(e) {
    const r = findBufAndOffset(this.bufs, e);
    return r.buf[r.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(e, r) {
    const n = findBufAndOffset(this.bufs, e);
    n.buf[n.index] = r;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(e, r = 0) {
    if (e instanceof Uint8Array)
      for (let n = 0; n < e.length; n++)
        this.set(r + n, e[n]);
    else if (isUint8ArrayList(e))
      for (let n = 0; n < e.length; n++)
        this.set(r + n, e.get(n));
    else
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(e) {
    if (e = Math.trunc(e), !(Number.isNaN(e) || e <= 0)) {
      if (e === this.byteLength) {
        this.bufs = [], this.length = 0;
        return;
      }
      for (; this.bufs.length > 0; )
        if (e >= this.bufs[0].byteLength)
          e -= this.bufs[0].byteLength, this.length -= this.bufs[0].byteLength, this.bufs.shift();
        else {
          this.bufs[0] = this.bufs[0].subarray(e), this.length -= e;
          break;
        }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(e, r) {
    const { bufs: n, length: i } = this._subList(e, r);
    return concat$7(n, i);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(e, r) {
    const { bufs: n, length: i } = this._subList(e, r);
    return n.length === 1 ? n[0] : concat$7(n, i);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(e, r) {
    const { bufs: n, length: i } = this._subList(e, r), o = new Uint8ArrayList();
    return o.length = i, o.bufs = n, o;
  }
  _subList(e, r) {
    if (e = e ?? 0, r = r ?? this.length, e < 0 && (e = this.length + e), r < 0 && (r = this.length + r), e < 0 || r > this.length)
      throw new RangeError("index is out of bounds");
    if (e === r)
      return { bufs: [], length: 0 };
    if (e === 0 && r === this.length)
      return { bufs: [...this.bufs], length: this.length };
    const n = [];
    let i = 0;
    for (let o = 0; o < this.bufs.length; o++) {
      const a = this.bufs[o], c = i, l = c + a.byteLength;
      if (i = l, e >= l)
        continue;
      const u = e >= c && e < l, f = r > c && r <= l;
      if (u && f) {
        if (e === c && r === l) {
          n.push(a);
          break;
        }
        const d = e - c;
        n.push(a.subarray(d, d + (r - e)));
        break;
      }
      if (u) {
        if (e === 0) {
          n.push(a);
          continue;
        }
        n.push(a.subarray(e - c));
        continue;
      }
      if (f) {
        if (r === l) {
          n.push(a);
          break;
        }
        n.push(a.subarray(0, r - c));
        break;
      }
      n.push(a);
    }
    return { bufs: n, length: r - e };
  }
  indexOf(e, r = 0) {
    if (!isUint8ArrayList(e) && !(e instanceof Uint8Array))
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    const n = e instanceof Uint8Array ? e : e.subarray();
    if (r = Number(r ?? 0), isNaN(r) && (r = 0), r < 0 && (r = this.length + r), r < 0 && (r = 0), e.length === 0)
      return r > this.length ? this.length : r;
    const i = n.byteLength;
    if (i === 0)
      throw new TypeError("search must be at least 1 byte long");
    const o = 256, a = new Int32Array(o);
    for (let d = 0; d < o; d++)
      a[d] = -1;
    for (let d = 0; d < i; d++)
      a[n[d]] = d;
    const c = a, l = this.byteLength - n.byteLength, u = n.byteLength - 1;
    let f;
    for (let d = r; d <= l; d += f) {
      f = 0;
      for (let p = u; p >= 0; p--) {
        const g = this.get(d + p);
        if (n[p] !== g) {
          f = Math.max(1, p - c[g]);
          break;
        }
      }
      if (f === 0)
        return d;
    }
    return -1;
  }
  getInt8(e) {
    const r = this.subarray(e, e + 1);
    return new DataView(r.buffer, r.byteOffset, r.byteLength).getInt8(0);
  }
  setInt8(e, r) {
    const n = allocUnsafe$3(1);
    new DataView(n.buffer, n.byteOffset, n.byteLength).setInt8(0, r), this.write(n, e);
  }
  getInt16(e, r) {
    const n = this.subarray(e, e + 2);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getInt16(0, r);
  }
  setInt16(e, r, n) {
    const i = alloc(2);
    new DataView(i.buffer, i.byteOffset, i.byteLength).setInt16(0, r, n), this.write(i, e);
  }
  getInt32(e, r) {
    const n = this.subarray(e, e + 4);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getInt32(0, r);
  }
  setInt32(e, r, n) {
    const i = alloc(4);
    new DataView(i.buffer, i.byteOffset, i.byteLength).setInt32(0, r, n), this.write(i, e);
  }
  getBigInt64(e, r) {
    const n = this.subarray(e, e + 8);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getBigInt64(0, r);
  }
  setBigInt64(e, r, n) {
    const i = alloc(8);
    new DataView(i.buffer, i.byteOffset, i.byteLength).setBigInt64(0, r, n), this.write(i, e);
  }
  getUint8(e) {
    const r = this.subarray(e, e + 1);
    return new DataView(r.buffer, r.byteOffset, r.byteLength).getUint8(0);
  }
  setUint8(e, r) {
    const n = allocUnsafe$3(1);
    new DataView(n.buffer, n.byteOffset, n.byteLength).setUint8(0, r), this.write(n, e);
  }
  getUint16(e, r) {
    const n = this.subarray(e, e + 2);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getUint16(0, r);
  }
  setUint16(e, r, n) {
    const i = alloc(2);
    new DataView(i.buffer, i.byteOffset, i.byteLength).setUint16(0, r, n), this.write(i, e);
  }
  getUint32(e, r) {
    const n = this.subarray(e, e + 4);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getUint32(0, r);
  }
  setUint32(e, r, n) {
    const i = alloc(4);
    new DataView(i.buffer, i.byteOffset, i.byteLength).setUint32(0, r, n), this.write(i, e);
  }
  getBigUint64(e, r) {
    const n = this.subarray(e, e + 8);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getBigUint64(0, r);
  }
  setBigUint64(e, r, n) {
    const i = alloc(8);
    new DataView(i.buffer, i.byteOffset, i.byteLength).setBigUint64(0, r, n), this.write(i, e);
  }
  getFloat32(e, r) {
    const n = this.subarray(e, e + 4);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getFloat32(0, r);
  }
  setFloat32(e, r, n) {
    const i = alloc(4);
    new DataView(i.buffer, i.byteOffset, i.byteLength).setFloat32(0, r, n), this.write(i, e);
  }
  getFloat64(e, r) {
    const n = this.subarray(e, e + 8);
    return new DataView(n.buffer, n.byteOffset, n.byteLength).getFloat64(0, r);
  }
  setFloat64(e, r, n) {
    const i = alloc(8);
    new DataView(i.buffer, i.byteOffset, i.byteLength).setFloat64(0, r, n), this.write(i, e);
  }
  equals(e) {
    if (e == null || !(e instanceof Uint8ArrayList) || e.bufs.length !== this.bufs.length)
      return !1;
    for (let r = 0; r < this.bufs.length; r++)
      if (!equals$5(this.bufs[r], e.bufs[r]))
        return !1;
    return !0;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(e, r) {
    const n = new Uint8ArrayList();
    return n.bufs = e, r == null && (r = e.reduce((i, o) => i + o.byteLength, 0)), n.length = r, n;
  }
}
function accessor(t) {
  return t instanceof Uint8Array ? {
    get(e) {
      return t[e];
    },
    set(e, r) {
      t[e] = r;
    }
  } : {
    get(e) {
      return t.get(e);
    },
    set(e, r) {
      t.set(e, r);
    }
  };
}
const TWO_32 = 4294967296;
let LongBits$4 = class de {
  constructor(e = 0, r = 0) {
    this.hi = e, this.lo = r;
  }
  /**
   * Returns these hi/lo bits as a BigInt
   */
  toBigInt(e) {
    if (e === !0)
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    if (this.hi >>> 31) {
      const r = ~this.lo + 1 >>> 0;
      let n = ~this.hi >>> 0;
      return r === 0 && (n = n + 1 >>> 0), -(BigInt(r) + (BigInt(n) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  /**
   * Returns these hi/lo bits as a Number - this may overflow, toBigInt
   * should be preferred
   */
  toNumber(e) {
    return Number(this.toBigInt(e));
  }
  /**
   * ZigZag decode a LongBits object
   */
  zzDecode() {
    const e = -(this.lo & 1), r = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, n = (this.hi >>> 1 ^ e) >>> 0;
    return new de(n, r);
  }
  /**
   * ZigZag encode a LongBits object
   */
  zzEncode() {
    const e = this.hi >> 31, r = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, n = (this.lo << 1 ^ e) >>> 0;
    return new de(r, n);
  }
  /**
   * Encode a LongBits object as a varint byte array
   */
  toBytes(e, r = 0) {
    const n = accessor(e);
    for (; this.hi > 0; )
      n.set(r++, this.lo & 127 | 128), this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0, this.hi >>>= 7;
    for (; this.lo > 127; )
      n.set(r++, this.lo & 127 | 128), this.lo = this.lo >>> 7;
    n.set(r++, this.lo);
  }
  /**
   * Parse a LongBits object from a BigInt
   */
  static fromBigInt(e) {
    if (e === 0n)
      return new de();
    const r = e < 0;
    r && (e = -e);
    let n = Number(e >> 32n) | 0, i = Number(e - (BigInt(n) << 32n)) | 0;
    return r && (n = ~n >>> 0, i = ~i >>> 0, ++i > TWO_32 && (i = 0, ++n > TWO_32 && (n = 0))), new de(n, i);
  }
  /**
   * Parse a LongBits object from a Number
   */
  static fromNumber(e) {
    if (e === 0)
      return new de();
    const r = e < 0;
    r && (e = -e);
    let n = e >>> 0, i = (e - n) / 4294967296 >>> 0;
    return r && (i = ~i >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++i > 4294967295 && (i = 0))), new de(i, n);
  }
  /**
   * Parse a LongBits object from a varint byte array
   */
  static fromBytes(e, r = 0) {
    const n = accessor(e), i = new de();
    let o = 0;
    if (e.length - r > 4) {
      for (; o < 4; ++o)
        if (i.lo = (i.lo | (n.get(r) & 127) << o * 7) >>> 0, n.get(r++) < 128)
          return i;
      if (i.lo = (i.lo | (n.get(r) & 127) << 28) >>> 0, i.hi = (i.hi | (n.get(r) & 127) >> 4) >>> 0, n.get(r++) < 128)
        return i;
      o = 0;
    } else
      for (; o < 4; ++o) {
        if (r >= e.length)
          throw RangeError(`index out of range: ${r} > ${e.length}`);
        if (i.lo = (i.lo | (n.get(r) & 127) << o * 7) >>> 0, n.get(r++) < 128)
          return i;
      }
    if (e.length - r > 4) {
      for (; o < 5; ++o)
        if (i.hi = (i.hi | (n.get(r) & 127) << o * 7 + 3) >>> 0, n.get(r++) < 128)
          return i;
    } else if (r < e.byteLength)
      for (; o < 5; ++o) {
        if (r >= e.length)
          throw RangeError(`index out of range: ${r} > ${e.length}`);
        if (i.hi = (i.hi | (n.get(r) & 127) << o * 7 + 3) >>> 0, n.get(r++) < 128)
          return i;
      }
    throw RangeError("invalid varint encoding");
  }
};
const N1$4 = Math.pow(2, 7), N2$4 = Math.pow(2, 14), N3$4 = Math.pow(2, 21), N4$4 = Math.pow(2, 28), N5$4 = Math.pow(2, 35), N6$4 = Math.pow(2, 42), N7$4 = Math.pow(2, 49), N8$3 = Math.pow(2, 56), N9$3 = Math.pow(2, 63), unsigned = {
  encodingLength(t) {
    return t < N1$4 ? 1 : t < N2$4 ? 2 : t < N3$4 ? 3 : t < N4$4 ? 4 : t < N5$4 ? 5 : t < N6$4 ? 6 : t < N7$4 ? 7 : t < N8$3 ? 8 : t < N9$3 ? 9 : 10;
  },
  encode(t, e, r = 0) {
    if (Number.MAX_SAFE_INTEGER != null && t > Number.MAX_SAFE_INTEGER)
      throw new RangeError("Could not encode varint");
    return e == null && (e = allocUnsafe$3(unsigned.encodingLength(t))), LongBits$4.fromNumber(t).toBytes(e, r), e;
  },
  decode(t, e = 0) {
    return LongBits$4.fromBytes(t, e).toNumber(!0);
  }
};
function allocUnsafe$2(t) {
  var e;
  return ((e = globalThis == null ? void 0 : globalThis.Buffer) == null ? void 0 : e.allocUnsafe) != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
const defaultEncoder$1 = (t) => {
  const e = unsigned.encodingLength(t), r = allocUnsafe$2(e);
  return unsigned.encode(t, r), defaultEncoder$1.bytes = e, r;
};
defaultEncoder$1.bytes = 0;
function encode$c(t) {
  t = t ?? {};
  const e = t.lengthEncoder ?? defaultEncoder$1;
  return async function* (n) {
    for await (const i of n) {
      const o = e(i.byteLength);
      o instanceof Uint8Array ? yield o : yield* o, i instanceof Uint8Array ? yield i : yield* i;
    }
  };
}
encode$c.single = (t, e) => {
  e = e ?? {};
  const r = e.lengthEncoder ?? defaultEncoder$1;
  return new Uint8ArrayList(r(t.byteLength), t);
};
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function assign(t, e) {
  for (const r in e)
    Object.defineProperty(t, r, {
      value: e[r],
      enumerable: !0,
      configurable: !0
    });
  return t;
}
function createError(t, e, r) {
  if (!t || typeof t == "string")
    throw new TypeError("Please pass an Error to err-code");
  r || (r = {}), typeof e == "object" && (r = e, e = ""), e && (r.code = e);
  try {
    return assign(t, r);
  } catch {
    r.message = t.message, r.stack = t.stack;
    const i = function() {
    };
    return i.prototype = Object.create(Object.getPrototypeOf(t)), assign(new i(), r);
  }
}
var errCode = createError;
const MAX_LENGTH_LENGTH$2 = 8, MAX_DATA_LENGTH$2 = 1024 * 1024 * 4;
var ReadMode$2;
(function(t) {
  t[t.LENGTH = 0] = "LENGTH", t[t.DATA = 1] = "DATA";
})(ReadMode$2 || (ReadMode$2 = {}));
const defaultDecoder$2 = (t) => {
  const e = unsigned.decode(t);
  return defaultDecoder$2.bytes = unsigned.encodingLength(e), e;
};
defaultDecoder$2.bytes = 0;
function decode$f(t) {
  return async function* (r) {
    const n = new Uint8ArrayList();
    let i = ReadMode$2.LENGTH, o = -1;
    const a = (t == null ? void 0 : t.lengthDecoder) ?? defaultDecoder$2, c = (t == null ? void 0 : t.maxLengthLength) ?? MAX_LENGTH_LENGTH$2, l = (t == null ? void 0 : t.maxDataLength) ?? MAX_DATA_LENGTH$2;
    for await (const u of r)
      for (n.append(u); n.byteLength > 0; ) {
        if (i === ReadMode$2.LENGTH)
          try {
            if (o = a(n), o < 0)
              throw errCode(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
            if (o > l)
              throw errCode(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
            const f = a.bytes;
            n.consume(f), (t == null ? void 0 : t.onLength) != null && t.onLength(o), i = ReadMode$2.DATA;
          } catch (f) {
            if (f instanceof RangeError) {
              if (n.byteLength > c)
                throw errCode(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
              break;
            }
            throw f;
          }
        if (i === ReadMode$2.DATA) {
          if (n.byteLength < o)
            break;
          const f = n.sublist(0, o);
          n.consume(o), (t == null ? void 0 : t.onData) != null && t.onData(f), yield f, i = ReadMode$2.LENGTH;
        }
      }
    if (n.byteLength > 0)
      throw errCode(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
  };
}
decode$f.fromReader = (t, e) => {
  let r = 1;
  const n = async function* () {
    for (; ; )
      try {
        const { done: o, value: a } = await t.next(r);
        if (o === !0)
          return;
        a != null && (yield a);
      } catch (o) {
        if (o.code === "ERR_UNDER_READ")
          return { done: !0, value: null };
        throw o;
      } finally {
        r = 1;
      }
  }();
  return decode$f({
    ...e ?? {},
    onLength: (o) => {
      r = o;
    }
  })(n);
};
var forge$m = {
  // default options
  options: {
    usePureJavaScript: !1
  }
}, win;
typeof window < "u" ? win = window : typeof commonjsGlobal < "u" ? win = commonjsGlobal : typeof self$1 < "u" ? win = self$1 : win = {};
var window_1 = win;
const self$1 = window_1;
var utilExports = {}, util$c = {
  get exports() {
    return utilExports;
  },
  set exports(t) {
    utilExports = t;
  }
}, api = {}, baseN$1 = api, _reverseAlphabets = {};
api.encode = function(t, e, r) {
  if (typeof e != "string")
    throw new TypeError('"alphabet" must be a string.');
  if (r !== void 0 && typeof r != "number")
    throw new TypeError('"maxline" must be a number.');
  var n = "";
  if (!(t instanceof Uint8Array))
    n = _encodeWithByteBuffer(t, e);
  else {
    var i = 0, o = e.length, a = e.charAt(0), c = [0];
    for (i = 0; i < t.length; ++i) {
      for (var l = 0, u = t[i]; l < c.length; ++l)
        u += c[l] << 8, c[l] = u % o, u = u / o | 0;
      for (; u > 0; )
        c.push(u % o), u = u / o | 0;
    }
    for (i = 0; t[i] === 0 && i < t.length - 1; ++i)
      n += a;
    for (i = c.length - 1; i >= 0; --i)
      n += e[c[i]];
  }
  if (r) {
    var f = new RegExp(".{1," + r + "}", "g");
    n = n.match(f).join(`\r
`);
  }
  return n;
};
api.decode = function(t, e) {
  if (typeof t != "string")
    throw new TypeError('"input" must be a string.');
  if (typeof e != "string")
    throw new TypeError('"alphabet" must be a string.');
  var r = _reverseAlphabets[e];
  if (!r) {
    r = _reverseAlphabets[e] = [];
    for (var n = 0; n < e.length; ++n)
      r[e.charCodeAt(n)] = n;
  }
  t = t.replace(/\s/g, "");
  for (var i = e.length, o = e.charAt(0), a = [0], n = 0; n < t.length; n++) {
    var c = r[t.charCodeAt(n)];
    if (c === void 0)
      return;
    for (var l = 0, u = c; l < a.length; ++l)
      u += a[l] * i, a[l] = u & 255, u >>= 8;
    for (; u > 0; )
      a.push(u & 255), u >>= 8;
  }
  for (var f = 0; t[f] === o && f < t.length - 1; ++f)
    a.push(0);
  return typeof Buffer < "u" ? Buffer.from(a.reverse()) : new Uint8Array(a.reverse());
};
function _encodeWithByteBuffer(t, e) {
  var r = 0, n = e.length, i = e.charAt(0), o = [0];
  for (r = 0; r < t.length(); ++r) {
    for (var a = 0, c = t.at(r); a < o.length; ++a)
      c += o[a] << 8, o[a] = c % n, c = c / n | 0;
    for (; c > 0; )
      o.push(c % n), c = c / n | 0;
  }
  var l = "";
  for (r = 0; t.at(r) === 0 && r < t.length() - 1; ++r)
    l += i;
  for (r = o.length - 1; r >= 0; --r)
    l += e[o[r]];
  return l;
}
var forge$l = forge$m, baseN = baseN$1, util$b = util$c.exports = forge$l.util = forge$l.util || {};
(function() {
  if (typeof process < "u" && process.nextTick && !process.browser) {
    util$b.nextTick = process.nextTick, typeof setImmediate == "function" ? util$b.setImmediate = setImmediate : util$b.setImmediate = util$b.nextTick;
    return;
  }
  if (typeof setImmediate == "function") {
    util$b.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    }, util$b.nextTick = function(a) {
      return setImmediate(a);
    };
    return;
  }
  if (util$b.setImmediate = function(a) {
    setTimeout(a, 0);
  }, typeof window < "u" && typeof window.postMessage == "function") {
    let a = function(c) {
      if (c.source === window && c.data === t) {
        c.stopPropagation();
        var l = e.slice();
        e.length = 0, l.forEach(function(u) {
          u();
        });
      }
    };
    var t = "forge.setImmediate", e = [];
    util$b.setImmediate = function(c) {
      e.push(c), e.length === 1 && window.postMessage(t, "*");
    }, window.addEventListener("message", a, !0);
  }
  if (typeof MutationObserver < "u") {
    var r = Date.now(), n = !0, i = document.createElement("div"), e = [];
    new MutationObserver(function() {
      var c = e.slice();
      e.length = 0, c.forEach(function(l) {
        l();
      });
    }).observe(i, { attributes: !0 });
    var o = util$b.setImmediate;
    util$b.setImmediate = function(c) {
      Date.now() - r > 15 ? (r = Date.now(), o(c)) : (e.push(c), e.length === 1 && i.setAttribute("a", n = !n));
    };
  }
  util$b.nextTick = util$b.setImmediate;
})();
util$b.isNodejs = typeof process < "u" && process.versions && process.versions.node;
util$b.globalScope = function() {
  return util$b.isNodejs ? commonjsGlobal : typeof self$1 > "u" ? window : self$1;
}();
util$b.isArray = Array.isArray || function(t) {
  return Object.prototype.toString.call(t) === "[object Array]";
};
util$b.isArrayBuffer = function(t) {
  return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer;
};
util$b.isArrayBufferView = function(t) {
  return t && util$b.isArrayBuffer(t.buffer) && t.byteLength !== void 0;
};
function _checkBitsParam(t) {
  if (!(t === 8 || t === 16 || t === 24 || t === 32))
    throw new Error("Only 8, 16, 24, or 32 bits supported: " + t);
}
util$b.ByteBuffer = ByteStringBuffer;
function ByteStringBuffer(t) {
  if (this.data = "", this.read = 0, typeof t == "string")
    this.data = t;
  else if (util$b.isArrayBuffer(t) || util$b.isArrayBufferView(t))
    if (typeof Buffer < "u" && t instanceof Buffer)
      this.data = t.toString("binary");
    else {
      var e = new Uint8Array(t);
      try {
        this.data = String.fromCharCode.apply(null, e);
      } catch {
        for (var r = 0; r < e.length; ++r)
          this.putByte(e[r]);
      }
    }
  else
    (t instanceof ByteStringBuffer || typeof t == "object" && typeof t.data == "string" && typeof t.read == "number") && (this.data = t.data, this.read = t.read);
  this._constructedStringLength = 0;
}
util$b.ByteStringBuffer = ByteStringBuffer;
var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
util$b.ByteStringBuffer.prototype._optimizeConstructedString = function(t) {
  this._constructedStringLength += t, this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH && (this.data.substr(0, 1), this._constructedStringLength = 0);
};
util$b.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
util$b.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$b.ByteStringBuffer.prototype.putByte = function(t) {
  return this.putBytes(String.fromCharCode(t));
};
util$b.ByteStringBuffer.prototype.fillWithByte = function(t, e) {
  t = String.fromCharCode(t);
  for (var r = this.data; e > 0; )
    e & 1 && (r += t), e >>>= 1, e > 0 && (t += t);
  return this.data = r, this._optimizeConstructedString(e), this;
};
util$b.ByteStringBuffer.prototype.putBytes = function(t) {
  return this.data += t, this._optimizeConstructedString(t.length), this;
};
util$b.ByteStringBuffer.prototype.putString = function(t) {
  return this.putBytes(util$b.encodeUtf8(t));
};
util$b.ByteStringBuffer.prototype.putInt16 = function(t) {
  return this.putBytes(
    String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt24 = function(t) {
  return this.putBytes(
    String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt32 = function(t) {
  return this.putBytes(
    String.fromCharCode(t >> 24 & 255) + String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt16Le = function(t) {
  return this.putBytes(
    String.fromCharCode(t & 255) + String.fromCharCode(t >> 8 & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt24Le = function(t) {
  return this.putBytes(
    String.fromCharCode(t & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t >> 16 & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt32Le = function(t) {
  return this.putBytes(
    String.fromCharCode(t & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 24 & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt = function(t, e) {
  _checkBitsParam(e);
  var r = "";
  do
    e -= 8, r += String.fromCharCode(t >> e & 255);
  while (e > 0);
  return this.putBytes(r);
};
util$b.ByteStringBuffer.prototype.putSignedInt = function(t, e) {
  return t < 0 && (t += 2 << e - 1), this.putInt(t, e);
};
util$b.ByteStringBuffer.prototype.putBuffer = function(t) {
  return this.putBytes(t.getBytes());
};
util$b.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
util$b.ByteStringBuffer.prototype.getInt16 = function() {
  var t = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  return this.read += 2, t;
};
util$b.ByteStringBuffer.prototype.getInt24 = function() {
  var t = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  return this.read += 3, t;
};
util$b.ByteStringBuffer.prototype.getInt32 = function() {
  var t = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  return this.read += 4, t;
};
util$b.ByteStringBuffer.prototype.getInt16Le = function() {
  var t = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  return this.read += 2, t;
};
util$b.ByteStringBuffer.prototype.getInt24Le = function() {
  var t = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  return this.read += 3, t;
};
util$b.ByteStringBuffer.prototype.getInt32Le = function() {
  var t = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  return this.read += 4, t;
};
util$b.ByteStringBuffer.prototype.getInt = function(t) {
  _checkBitsParam(t);
  var e = 0;
  do
    e = (e << 8) + this.data.charCodeAt(this.read++), t -= 8;
  while (t > 0);
  return e;
};
util$b.ByteStringBuffer.prototype.getSignedInt = function(t) {
  var e = this.getInt(t), r = 2 << t - 2;
  return e >= r && (e -= r << 1), e;
};
util$b.ByteStringBuffer.prototype.getBytes = function(t) {
  var e;
  return t ? (t = Math.min(this.length(), t), e = this.data.slice(this.read, this.read + t), this.read += t) : t === 0 ? e = "" : (e = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e;
};
util$b.ByteStringBuffer.prototype.bytes = function(t) {
  return typeof t > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t);
};
util$b.ByteStringBuffer.prototype.at = function(t) {
  return this.data.charCodeAt(this.read + t);
};
util$b.ByteStringBuffer.prototype.setAt = function(t, e) {
  return this.data = this.data.substr(0, this.read + t) + String.fromCharCode(e) + this.data.substr(this.read + t + 1), this;
};
util$b.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
util$b.ByteStringBuffer.prototype.copy = function() {
  var t = util$b.createBuffer(this.data);
  return t.read = this.read, t;
};
util$b.ByteStringBuffer.prototype.compact = function() {
  return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
};
util$b.ByteStringBuffer.prototype.clear = function() {
  return this.data = "", this.read = 0, this;
};
util$b.ByteStringBuffer.prototype.truncate = function(t) {
  var e = Math.max(0, this.length() - t);
  return this.data = this.data.substr(this.read, e), this.read = 0, this;
};
util$b.ByteStringBuffer.prototype.toHex = function() {
  for (var t = "", e = this.read; e < this.data.length; ++e) {
    var r = this.data.charCodeAt(e);
    r < 16 && (t += "0"), t += r.toString(16);
  }
  return t;
};
util$b.ByteStringBuffer.prototype.toString = function() {
  return util$b.decodeUtf8(this.bytes());
};
function DataBuffer(t, e) {
  e = e || {}, this.read = e.readOffset || 0, this.growSize = e.growSize || 1024;
  var r = util$b.isArrayBuffer(t), n = util$b.isArrayBufferView(t);
  if (r || n) {
    r ? this.data = new DataView(t) : this.data = new DataView(t.buffer, t.byteOffset, t.byteLength), this.write = "writeOffset" in e ? e.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0)), this.write = 0, t != null && this.putBytes(t), "writeOffset" in e && (this.write = e.writeOffset);
}
util$b.DataBuffer = DataBuffer;
util$b.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
util$b.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$b.DataBuffer.prototype.accommodate = function(t, e) {
  if (this.length() >= t)
    return this;
  e = Math.max(e || this.growSize, t);
  var r = new Uint8Array(
    this.data.buffer,
    this.data.byteOffset,
    this.data.byteLength
  ), n = new Uint8Array(this.length() + e);
  return n.set(r), this.data = new DataView(n.buffer), this;
};
util$b.DataBuffer.prototype.putByte = function(t) {
  return this.accommodate(1), this.data.setUint8(this.write++, t), this;
};
util$b.DataBuffer.prototype.fillWithByte = function(t, e) {
  this.accommodate(e);
  for (var r = 0; r < e; ++r)
    this.data.setUint8(t);
  return this;
};
util$b.DataBuffer.prototype.putBytes = function(t, e) {
  if (util$b.isArrayBufferView(t)) {
    var r = new Uint8Array(t.buffer, t.byteOffset, t.byteLength), n = r.byteLength - r.byteOffset;
    this.accommodate(n);
    var i = new Uint8Array(this.data.buffer, this.write);
    return i.set(r), this.write += n, this;
  }
  if (util$b.isArrayBuffer(t)) {
    var r = new Uint8Array(t);
    this.accommodate(r.byteLength);
    var i = new Uint8Array(this.data.buffer);
    return i.set(r, this.write), this.write += r.byteLength, this;
  }
  if (t instanceof util$b.DataBuffer || typeof t == "object" && typeof t.read == "number" && typeof t.write == "number" && util$b.isArrayBufferView(t.data)) {
    var r = new Uint8Array(t.data.byteLength, t.read, t.length());
    this.accommodate(r.byteLength);
    var i = new Uint8Array(t.data.byteLength, this.write);
    return i.set(r), this.write += r.byteLength, this;
  }
  if (t instanceof util$b.ByteStringBuffer && (t = t.data, e = "binary"), e = e || "binary", typeof t == "string") {
    var o;
    if (e === "hex")
      return this.accommodate(Math.ceil(t.length / 2)), o = new Uint8Array(this.data.buffer, this.write), this.write += util$b.binary.hex.decode(t, o, this.write), this;
    if (e === "base64")
      return this.accommodate(Math.ceil(t.length / 4) * 3), o = new Uint8Array(this.data.buffer, this.write), this.write += util$b.binary.base64.decode(t, o, this.write), this;
    if (e === "utf8" && (t = util$b.encodeUtf8(t), e = "binary"), e === "binary" || e === "raw")
      return this.accommodate(t.length), o = new Uint8Array(this.data.buffer, this.write), this.write += util$b.binary.raw.decode(o), this;
    if (e === "utf16")
      return this.accommodate(t.length * 2), o = new Uint16Array(this.data.buffer, this.write), this.write += util$b.text.utf16.encode(o), this;
    throw new Error("Invalid encoding: " + e);
  }
  throw Error("Invalid parameter: " + t);
};
util$b.DataBuffer.prototype.putBuffer = function(t) {
  return this.putBytes(t), t.clear(), this;
};
util$b.DataBuffer.prototype.putString = function(t) {
  return this.putBytes(t, "utf16");
};
util$b.DataBuffer.prototype.putInt16 = function(t) {
  return this.accommodate(2), this.data.setInt16(this.write, t), this.write += 2, this;
};
util$b.DataBuffer.prototype.putInt24 = function(t) {
  return this.accommodate(3), this.data.setInt16(this.write, t >> 8 & 65535), this.data.setInt8(this.write, t >> 16 & 255), this.write += 3, this;
};
util$b.DataBuffer.prototype.putInt32 = function(t) {
  return this.accommodate(4), this.data.setInt32(this.write, t), this.write += 4, this;
};
util$b.DataBuffer.prototype.putInt16Le = function(t) {
  return this.accommodate(2), this.data.setInt16(this.write, t, !0), this.write += 2, this;
};
util$b.DataBuffer.prototype.putInt24Le = function(t) {
  return this.accommodate(3), this.data.setInt8(this.write, t >> 16 & 255), this.data.setInt16(this.write, t >> 8 & 65535, !0), this.write += 3, this;
};
util$b.DataBuffer.prototype.putInt32Le = function(t) {
  return this.accommodate(4), this.data.setInt32(this.write, t, !0), this.write += 4, this;
};
util$b.DataBuffer.prototype.putInt = function(t, e) {
  _checkBitsParam(e), this.accommodate(e / 8);
  do
    e -= 8, this.data.setInt8(this.write++, t >> e & 255);
  while (e > 0);
  return this;
};
util$b.DataBuffer.prototype.putSignedInt = function(t, e) {
  return _checkBitsParam(e), this.accommodate(e / 8), t < 0 && (t += 2 << e - 1), this.putInt(t, e);
};
util$b.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
util$b.DataBuffer.prototype.getInt16 = function() {
  var t = this.data.getInt16(this.read);
  return this.read += 2, t;
};
util$b.DataBuffer.prototype.getInt24 = function() {
  var t = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  return this.read += 3, t;
};
util$b.DataBuffer.prototype.getInt32 = function() {
  var t = this.data.getInt32(this.read);
  return this.read += 4, t;
};
util$b.DataBuffer.prototype.getInt16Le = function() {
  var t = this.data.getInt16(this.read, !0);
  return this.read += 2, t;
};
util$b.DataBuffer.prototype.getInt24Le = function() {
  var t = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8;
  return this.read += 3, t;
};
util$b.DataBuffer.prototype.getInt32Le = function() {
  var t = this.data.getInt32(this.read, !0);
  return this.read += 4, t;
};
util$b.DataBuffer.prototype.getInt = function(t) {
  _checkBitsParam(t);
  var e = 0;
  do
    e = (e << 8) + this.data.getInt8(this.read++), t -= 8;
  while (t > 0);
  return e;
};
util$b.DataBuffer.prototype.getSignedInt = function(t) {
  var e = this.getInt(t), r = 2 << t - 2;
  return e >= r && (e -= r << 1), e;
};
util$b.DataBuffer.prototype.getBytes = function(t) {
  var e;
  return t ? (t = Math.min(this.length(), t), e = this.data.slice(this.read, this.read + t), this.read += t) : t === 0 ? e = "" : (e = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e;
};
util$b.DataBuffer.prototype.bytes = function(t) {
  return typeof t > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t);
};
util$b.DataBuffer.prototype.at = function(t) {
  return this.data.getUint8(this.read + t);
};
util$b.DataBuffer.prototype.setAt = function(t, e) {
  return this.data.setUint8(t, e), this;
};
util$b.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
util$b.DataBuffer.prototype.copy = function() {
  return new util$b.DataBuffer(this);
};
util$b.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var t = new Uint8Array(this.data.buffer, this.read), e = new Uint8Array(t.byteLength);
    e.set(t), this.data = new DataView(e), this.write -= this.read, this.read = 0;
  }
  return this;
};
util$b.DataBuffer.prototype.clear = function() {
  return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
};
util$b.DataBuffer.prototype.truncate = function(t) {
  return this.write = Math.max(0, this.length() - t), this.read = Math.min(this.read, this.write), this;
};
util$b.DataBuffer.prototype.toHex = function() {
  for (var t = "", e = this.read; e < this.data.byteLength; ++e) {
    var r = this.data.getUint8(e);
    r < 16 && (t += "0"), t += r.toString(16);
  }
  return t;
};
util$b.DataBuffer.prototype.toString = function(t) {
  var e = new Uint8Array(this.data, this.read, this.length());
  if (t = t || "utf8", t === "binary" || t === "raw")
    return util$b.binary.raw.encode(e);
  if (t === "hex")
    return util$b.binary.hex.encode(e);
  if (t === "base64")
    return util$b.binary.base64.encode(e);
  if (t === "utf8")
    return util$b.text.utf8.decode(e);
  if (t === "utf16")
    return util$b.text.utf16.decode(e);
  throw new Error("Invalid encoding: " + t);
};
util$b.createBuffer = function(t, e) {
  return e = e || "raw", t !== void 0 && e === "utf8" && (t = util$b.encodeUtf8(t)), new util$b.ByteBuffer(t);
};
util$b.fillString = function(t, e) {
  for (var r = ""; e > 0; )
    e & 1 && (r += t), e >>>= 1, e > 0 && (t += t);
  return r;
};
util$b.xorBytes = function(t, e, r) {
  for (var n = "", i = "", o = "", a = 0, c = 0; r > 0; --r, ++a)
    i = t.charCodeAt(a) ^ e.charCodeAt(a), c >= 10 && (n += o, o = "", c = 0), o += String.fromCharCode(i), ++c;
  return n += o, n;
};
util$b.hexToBytes = function(t) {
  var e = "", r = 0;
  for (t.length & !0 && (r = 1, e += String.fromCharCode(parseInt(t[0], 16))); r < t.length; r += 2)
    e += String.fromCharCode(parseInt(t.substr(r, 2), 16));
  return e;
};
util$b.bytesToHex = function(t) {
  return util$b.createBuffer(t).toHex();
};
util$b.int32ToBytes = function(t) {
  return String.fromCharCode(t >> 24 & 255) + String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t & 255);
};
var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", _base64Idx = [
  /*43 -43 = 0*/
  /*'+',  1,  2,  3,'/' */
  62,
  -1,
  -1,
  -1,
  63,
  /*'0','1','2','3','4','5','6','7','8','9' */
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  /*15, 16, 17,'=', 19, 20, 21 */
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  /*65 - 43 = 22*/
  /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  /*91 - 43 = 48 */
  /*48, 49, 50, 51, 52, 53 */
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  /*97 - 43 = 54*/
  /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
], _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
util$b.encode64 = function(t, e) {
  for (var r = "", n = "", i, o, a, c = 0; c < t.length; )
    i = t.charCodeAt(c++), o = t.charCodeAt(c++), a = t.charCodeAt(c++), r += _base64.charAt(i >> 2), r += _base64.charAt((i & 3) << 4 | o >> 4), isNaN(o) ? r += "==" : (r += _base64.charAt((o & 15) << 2 | a >> 6), r += isNaN(a) ? "=" : _base64.charAt(a & 63)), e && r.length > e && (n += r.substr(0, e) + `\r
`, r = r.substr(e));
  return n += r, n;
};
util$b.decode64 = function(t) {
  t = t.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  for (var e = "", r, n, i, o, a = 0; a < t.length; )
    r = _base64Idx[t.charCodeAt(a++) - 43], n = _base64Idx[t.charCodeAt(a++) - 43], i = _base64Idx[t.charCodeAt(a++) - 43], o = _base64Idx[t.charCodeAt(a++) - 43], e += String.fromCharCode(r << 2 | n >> 4), i !== 64 && (e += String.fromCharCode((n & 15) << 4 | i >> 2), o !== 64 && (e += String.fromCharCode((i & 3) << 6 | o)));
  return e;
};
util$b.encodeUtf8 = function(t) {
  return unescape(encodeURIComponent(t));
};
util$b.decodeUtf8 = function(t) {
  return decodeURIComponent(escape(t));
};
util$b.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: baseN.encode,
    decode: baseN.decode
  }
};
util$b.binary.raw.encode = function(t) {
  return String.fromCharCode.apply(null, t);
};
util$b.binary.raw.decode = function(t, e, r) {
  var n = e;
  n || (n = new Uint8Array(t.length)), r = r || 0;
  for (var i = r, o = 0; o < t.length; ++o)
    n[i++] = t.charCodeAt(o);
  return e ? i - r : n;
};
util$b.binary.hex.encode = util$b.bytesToHex;
util$b.binary.hex.decode = function(t, e, r) {
  var n = e;
  n || (n = new Uint8Array(Math.ceil(t.length / 2))), r = r || 0;
  var i = 0, o = r;
  for (t.length & 1 && (i = 1, n[o++] = parseInt(t[0], 16)); i < t.length; i += 2)
    n[o++] = parseInt(t.substr(i, 2), 16);
  return e ? o - r : n;
};
util$b.binary.base64.encode = function(t, e) {
  for (var r = "", n = "", i, o, a, c = 0; c < t.byteLength; )
    i = t[c++], o = t[c++], a = t[c++], r += _base64.charAt(i >> 2), r += _base64.charAt((i & 3) << 4 | o >> 4), isNaN(o) ? r += "==" : (r += _base64.charAt((o & 15) << 2 | a >> 6), r += isNaN(a) ? "=" : _base64.charAt(a & 63)), e && r.length > e && (n += r.substr(0, e) + `\r
`, r = r.substr(e));
  return n += r, n;
};
util$b.binary.base64.decode = function(t, e, r) {
  var n = e;
  n || (n = new Uint8Array(Math.ceil(t.length / 4) * 3)), t = t.replace(/[^A-Za-z0-9\+\/\=]/g, ""), r = r || 0;
  for (var i, o, a, c, l = 0, u = r; l < t.length; )
    i = _base64Idx[t.charCodeAt(l++) - 43], o = _base64Idx[t.charCodeAt(l++) - 43], a = _base64Idx[t.charCodeAt(l++) - 43], c = _base64Idx[t.charCodeAt(l++) - 43], n[u++] = i << 2 | o >> 4, a !== 64 && (n[u++] = (o & 15) << 4 | a >> 2, c !== 64 && (n[u++] = (a & 3) << 6 | c));
  return e ? u - r : n.subarray(0, u);
};
util$b.binary.base58.encode = function(t, e) {
  return util$b.binary.baseN.encode(t, _base58, e);
};
util$b.binary.base58.decode = function(t, e) {
  return util$b.binary.baseN.decode(t, _base58, e);
};
util$b.text = {
  utf8: {},
  utf16: {}
};
util$b.text.utf8.encode = function(t, e, r) {
  t = util$b.encodeUtf8(t);
  var n = e;
  n || (n = new Uint8Array(t.length)), r = r || 0;
  for (var i = r, o = 0; o < t.length; ++o)
    n[i++] = t.charCodeAt(o);
  return e ? i - r : n;
};
util$b.text.utf8.decode = function(t) {
  return util$b.decodeUtf8(String.fromCharCode.apply(null, t));
};
util$b.text.utf16.encode = function(t, e, r) {
  var n = e;
  n || (n = new Uint8Array(t.length * 2));
  var i = new Uint16Array(n.buffer);
  r = r || 0;
  for (var o = r, a = r, c = 0; c < t.length; ++c)
    i[a++] = t.charCodeAt(c), o += 2;
  return e ? o - r : n;
};
util$b.text.utf16.decode = function(t) {
  return String.fromCharCode.apply(null, new Uint16Array(t.buffer));
};
util$b.deflate = function(t, e, r) {
  if (e = util$b.decode64(t.deflate(util$b.encode64(e)).rval), r) {
    var n = 2, i = e.charCodeAt(1);
    i & 32 && (n = 6), e = e.substring(n, e.length - 4);
  }
  return e;
};
util$b.inflate = function(t, e, r) {
  var n = t.inflate(util$b.encode64(e)).rval;
  return n === null ? null : util$b.decode64(n);
};
var _setStorageObject = function(t, e, r) {
  if (!t)
    throw new Error("WebStorage not available.");
  var n;
  if (r === null ? n = t.removeItem(e) : (r = util$b.encode64(JSON.stringify(r)), n = t.setItem(e, r)), typeof n < "u" && n.rval !== !0) {
    var i = new Error(n.error.message);
    throw i.id = n.error.id, i.name = n.error.name, i;
  }
}, _getStorageObject = function(t, e) {
  if (!t)
    throw new Error("WebStorage not available.");
  var r = t.getItem(e);
  if (t.init)
    if (r.rval === null) {
      if (r.error) {
        var n = new Error(r.error.message);
        throw n.id = r.error.id, n.name = r.error.name, n;
      }
      r = null;
    } else
      r = r.rval;
  return r !== null && (r = JSON.parse(util$b.decode64(r))), r;
}, _setItem = function(t, e, r, n) {
  var i = _getStorageObject(t, e);
  i === null && (i = {}), i[r] = n, _setStorageObject(t, e, i);
}, _getItem = function(t, e, r) {
  var n = _getStorageObject(t, e);
  return n !== null && (n = r in n ? n[r] : null), n;
}, _removeItem = function(t, e, r) {
  var n = _getStorageObject(t, e);
  if (n !== null && r in n) {
    delete n[r];
    var i = !0;
    for (var o in n) {
      i = !1;
      break;
    }
    i && (n = null), _setStorageObject(t, e, n);
  }
}, _clearItems = function(t, e) {
  _setStorageObject(t, e, null);
}, _callStorageFunction = function(t, e, r) {
  var n = null;
  typeof r > "u" && (r = ["web", "flash"]);
  var i, o = !1, a = null;
  for (var c in r) {
    i = r[c];
    try {
      if (i === "flash" || i === "both") {
        if (e[0] === null)
          throw new Error("Flash local storage not available.");
        n = t.apply(this, e), o = i === "flash";
      }
      (i === "web" || i === "both") && (e[0] = localStorage, n = t.apply(this, e), o = !0);
    } catch (l) {
      a = l;
    }
    if (o)
      break;
  }
  if (!o)
    throw a;
  return n;
};
util$b.setItem = function(t, e, r, n, i) {
  _callStorageFunction(_setItem, arguments, i);
};
util$b.getItem = function(t, e, r, n) {
  return _callStorageFunction(_getItem, arguments, n);
};
util$b.removeItem = function(t, e, r, n) {
  _callStorageFunction(_removeItem, arguments, n);
};
util$b.clearItems = function(t, e, r) {
  _callStorageFunction(_clearItems, arguments, r);
};
util$b.isEmpty = function(t) {
  for (var e in t)
    if (t.hasOwnProperty(e))
      return !1;
  return !0;
};
util$b.format = function(t) {
  for (var e = /%./g, r, n, i = 0, o = [], a = 0; r = e.exec(t); ) {
    n = t.substring(a, e.lastIndex - 2), n.length > 0 && o.push(n), a = e.lastIndex;
    var c = r[0][1];
    switch (c) {
      case "s":
      case "o":
        i < arguments.length ? o.push(arguments[i++ + 1]) : o.push("<?>");
        break;
      case "%":
        o.push("%");
        break;
      default:
        o.push("<%" + c + "?>");
    }
  }
  return o.push(t.substring(a)), o.join("");
};
util$b.formatNumber = function(t, e, r, n) {
  var i = t, o = isNaN(e = Math.abs(e)) ? 2 : e, a = r === void 0 ? "," : r, c = n === void 0 ? "." : n, l = i < 0 ? "-" : "", u = parseInt(i = Math.abs(+i || 0).toFixed(o), 10) + "", f = u.length > 3 ? u.length % 3 : 0;
  return l + (f ? u.substr(0, f) + c : "") + u.substr(f).replace(/(\d{3})(?=\d)/g, "$1" + c) + (o ? a + Math.abs(i - u).toFixed(o).slice(2) : "");
};
util$b.formatSize = function(t) {
  return t >= 1073741824 ? t = util$b.formatNumber(t / 1073741824, 2, ".", "") + " GiB" : t >= 1048576 ? t = util$b.formatNumber(t / 1048576, 2, ".", "") + " MiB" : t >= 1024 ? t = util$b.formatNumber(t / 1024, 0) + " KiB" : t = util$b.formatNumber(t, 0) + " bytes", t;
};
util$b.bytesFromIP = function(t) {
  return t.indexOf(".") !== -1 ? util$b.bytesFromIPv4(t) : t.indexOf(":") !== -1 ? util$b.bytesFromIPv6(t) : null;
};
util$b.bytesFromIPv4 = function(t) {
  if (t = t.split("."), t.length !== 4)
    return null;
  for (var e = util$b.createBuffer(), r = 0; r < t.length; ++r) {
    var n = parseInt(t[r], 10);
    if (isNaN(n))
      return null;
    e.putByte(n);
  }
  return e.getBytes();
};
util$b.bytesFromIPv6 = function(t) {
  var e = 0;
  t = t.split(":").filter(function(a) {
    return a.length === 0 && ++e, !0;
  });
  for (var r = (8 - t.length + e) * 2, n = util$b.createBuffer(), i = 0; i < 8; ++i) {
    if (!t[i] || t[i].length === 0) {
      n.fillWithByte(0, r), r = 0;
      continue;
    }
    var o = util$b.hexToBytes(t[i]);
    o.length < 2 && n.putByte(0), n.putBytes(o);
  }
  return n.getBytes();
};
util$b.bytesToIP = function(t) {
  return t.length === 4 ? util$b.bytesToIPv4(t) : t.length === 16 ? util$b.bytesToIPv6(t) : null;
};
util$b.bytesToIPv4 = function(t) {
  if (t.length !== 4)
    return null;
  for (var e = [], r = 0; r < t.length; ++r)
    e.push(t.charCodeAt(r));
  return e.join(".");
};
util$b.bytesToIPv6 = function(t) {
  if (t.length !== 16)
    return null;
  for (var e = [], r = [], n = 0, i = 0; i < t.length; i += 2) {
    for (var o = util$b.bytesToHex(t[i] + t[i + 1]); o[0] === "0" && o !== "0"; )
      o = o.substr(1);
    if (o === "0") {
      var a = r[r.length - 1], c = e.length;
      !a || c !== a.end + 1 ? r.push({ start: c, end: c }) : (a.end = c, a.end - a.start > r[n].end - r[n].start && (n = r.length - 1));
    }
    e.push(o);
  }
  if (r.length > 0) {
    var l = r[n];
    l.end - l.start > 0 && (e.splice(l.start, l.end - l.start + 1, ""), l.start === 0 && e.unshift(""), l.end === 7 && e.push(""));
  }
  return e.join(":");
};
util$b.estimateCores = function(t, e) {
  if (typeof t == "function" && (e = t, t = {}), t = t || {}, "cores" in util$b && !t.update)
    return e(null, util$b.cores);
  if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
    return util$b.cores = navigator.hardwareConcurrency, e(null, util$b.cores);
  if (typeof Worker > "u")
    return util$b.cores = 1, e(null, util$b.cores);
  if (typeof Blob > "u")
    return util$b.cores = 2, e(null, util$b.cores);
  var r = URL.createObjectURL(new Blob([
    "(",
    function() {
      self$1.addEventListener("message", function(a) {
        var c = Date.now(), l = c + 4;
        self$1.postMessage({ st: c, et: l });
      });
    }.toString(),
    ")()"
  ], { type: "application/javascript" }));
  n([], 5, 16);
  function n(a, c, l) {
    if (c === 0) {
      var u = Math.floor(a.reduce(function(f, d) {
        return f + d;
      }, 0) / a.length);
      return util$b.cores = Math.max(1, u), URL.revokeObjectURL(r), e(null, util$b.cores);
    }
    i(l, function(f, d) {
      a.push(o(l, d)), n(a, c - 1, l);
    });
  }
  function i(a, c) {
    for (var l = [], u = [], f = 0; f < a; ++f) {
      var d = new Worker(r);
      d.addEventListener("message", function(p) {
        if (u.push(p.data), u.length === a) {
          for (var g = 0; g < a; ++g)
            l[g].terminate();
          c(null, u);
        }
      }), l.push(d);
    }
    for (var f = 0; f < a; ++f)
      l[f].postMessage(f);
  }
  function o(a, c) {
    for (var l = [], u = 0; u < a; ++u)
      for (var f = c[u], d = l[u] = [], p = 0; p < a; ++p)
        if (u !== p) {
          var g = c[p];
          (f.st > g.st && f.st < g.et || g.st > f.st && g.st < f.et) && d.push(p);
        }
    return l.reduce(function(h, m) {
      return Math.max(h, m.length);
    }, 0);
  }
};
var forge$k = forge$m;
forge$k.pki = forge$k.pki || {};
var oids$1 = forge$k.pki.oids = forge$k.oids = forge$k.oids || {};
function _IN(t, e) {
  oids$1[t] = e, oids$1[e] = t;
}
function _I_(t, e) {
  oids$1[t] = e;
}
_IN("1.2.840.113549.1.1.1", "rsaEncryption");
_IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
_IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
_IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
_IN("1.2.840.113549.1.1.8", "mgf1");
_IN("1.2.840.113549.1.1.9", "pSpecified");
_IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
_IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
_IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
_IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
_IN("1.3.101.112", "EdDSA25519");
_IN("1.2.840.10040.4.3", "dsa-with-sha1");
_IN("1.3.14.3.2.7", "desCBC");
_IN("1.3.14.3.2.26", "sha1");
_IN("1.3.14.3.2.29", "sha1WithRSASignature");
_IN("2.16.840.1.101.3.4.2.1", "sha256");
_IN("2.16.840.1.101.3.4.2.2", "sha384");
_IN("2.16.840.1.101.3.4.2.3", "sha512");
_IN("2.16.840.1.101.3.4.2.4", "sha224");
_IN("2.16.840.1.101.3.4.2.5", "sha512-224");
_IN("2.16.840.1.101.3.4.2.6", "sha512-256");
_IN("1.2.840.113549.2.2", "md2");
_IN("1.2.840.113549.2.5", "md5");
_IN("1.2.840.113549.1.7.1", "data");
_IN("1.2.840.113549.1.7.2", "signedData");
_IN("1.2.840.113549.1.7.3", "envelopedData");
_IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
_IN("1.2.840.113549.1.7.5", "digestedData");
_IN("1.2.840.113549.1.7.6", "encryptedData");
_IN("1.2.840.113549.1.9.1", "emailAddress");
_IN("1.2.840.113549.1.9.2", "unstructuredName");
_IN("1.2.840.113549.1.9.3", "contentType");
_IN("1.2.840.113549.1.9.4", "messageDigest");
_IN("1.2.840.113549.1.9.5", "signingTime");
_IN("1.2.840.113549.1.9.6", "counterSignature");
_IN("1.2.840.113549.1.9.7", "challengePassword");
_IN("1.2.840.113549.1.9.8", "unstructuredAddress");
_IN("1.2.840.113549.1.9.14", "extensionRequest");
_IN("1.2.840.113549.1.9.20", "friendlyName");
_IN("1.2.840.113549.1.9.21", "localKeyId");
_IN("1.2.840.113549.1.9.22.1", "x509Certificate");
_IN("1.2.840.113549.1.12.10.1.1", "keyBag");
_IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
_IN("1.2.840.113549.1.12.10.1.3", "certBag");
_IN("1.2.840.113549.1.12.10.1.4", "crlBag");
_IN("1.2.840.113549.1.12.10.1.5", "secretBag");
_IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
_IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
_IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
_IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
_IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
_IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
_IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
_IN("1.2.840.113549.2.7", "hmacWithSHA1");
_IN("1.2.840.113549.2.8", "hmacWithSHA224");
_IN("1.2.840.113549.2.9", "hmacWithSHA256");
_IN("1.2.840.113549.2.10", "hmacWithSHA384");
_IN("1.2.840.113549.2.11", "hmacWithSHA512");
_IN("1.2.840.113549.3.7", "des-EDE3-CBC");
_IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
_IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
_IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
_IN("2.5.4.3", "commonName");
_IN("2.5.4.4", "surname");
_IN("2.5.4.5", "serialNumber");
_IN("2.5.4.6", "countryName");
_IN("2.5.4.7", "localityName");
_IN("2.5.4.8", "stateOrProvinceName");
_IN("2.5.4.9", "streetAddress");
_IN("2.5.4.10", "organizationName");
_IN("2.5.4.11", "organizationalUnitName");
_IN("2.5.4.12", "title");
_IN("2.5.4.13", "description");
_IN("2.5.4.15", "businessCategory");
_IN("2.5.4.17", "postalCode");
_IN("2.5.4.42", "givenName");
_IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
_IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
_IN("2.16.840.1.113730.1.1", "nsCertType");
_IN("2.16.840.1.113730.1.13", "nsComment");
_I_("2.5.29.1", "authorityKeyIdentifier");
_I_("2.5.29.2", "keyAttributes");
_I_("2.5.29.3", "certificatePolicies");
_I_("2.5.29.4", "keyUsageRestriction");
_I_("2.5.29.5", "policyMapping");
_I_("2.5.29.6", "subtreesConstraint");
_I_("2.5.29.7", "subjectAltName");
_I_("2.5.29.8", "issuerAltName");
_I_("2.5.29.9", "subjectDirectoryAttributes");
_I_("2.5.29.10", "basicConstraints");
_I_("2.5.29.11", "nameConstraints");
_I_("2.5.29.12", "policyConstraints");
_I_("2.5.29.13", "basicConstraints");
_IN("2.5.29.14", "subjectKeyIdentifier");
_IN("2.5.29.15", "keyUsage");
_I_("2.5.29.16", "privateKeyUsagePeriod");
_IN("2.5.29.17", "subjectAltName");
_IN("2.5.29.18", "issuerAltName");
_IN("2.5.29.19", "basicConstraints");
_I_("2.5.29.20", "cRLNumber");
_I_("2.5.29.21", "cRLReason");
_I_("2.5.29.22", "expirationDate");
_I_("2.5.29.23", "instructionCode");
_I_("2.5.29.24", "invalidityDate");
_I_("2.5.29.25", "cRLDistributionPoints");
_I_("2.5.29.26", "issuingDistributionPoint");
_I_("2.5.29.27", "deltaCRLIndicator");
_I_("2.5.29.28", "issuingDistributionPoint");
_I_("2.5.29.29", "certificateIssuer");
_I_("2.5.29.30", "nameConstraints");
_IN("2.5.29.31", "cRLDistributionPoints");
_IN("2.5.29.32", "certificatePolicies");
_I_("2.5.29.33", "policyMappings");
_I_("2.5.29.34", "policyConstraints");
_IN("2.5.29.35", "authorityKeyIdentifier");
_I_("2.5.29.36", "policyConstraints");
_IN("2.5.29.37", "extKeyUsage");
_I_("2.5.29.46", "freshestCRL");
_I_("2.5.29.54", "inhibitAnyPolicy");
_IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
_IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
_IN("1.3.6.1.5.5.7.3.1", "serverAuth");
_IN("1.3.6.1.5.5.7.3.2", "clientAuth");
_IN("1.3.6.1.5.5.7.3.3", "codeSigning");
_IN("1.3.6.1.5.5.7.3.4", "emailProtection");
_IN("1.3.6.1.5.5.7.3.8", "timeStamping");
var forge$j = forge$m, asn1$2 = forge$j.asn1 = forge$j.asn1 || {};
asn1$2.Class = {
  UNIVERSAL: 0,
  APPLICATION: 64,
  CONTEXT_SPECIFIC: 128,
  PRIVATE: 192
};
asn1$2.Type = {
  NONE: 0,
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTETSTRING: 4,
  NULL: 5,
  OID: 6,
  ODESC: 7,
  EXTERNAL: 8,
  REAL: 9,
  ENUMERATED: 10,
  EMBEDDED: 11,
  UTF8: 12,
  ROID: 13,
  SEQUENCE: 16,
  SET: 17,
  PRINTABLESTRING: 19,
  IA5STRING: 22,
  UTCTIME: 23,
  GENERALIZEDTIME: 24,
  BMPSTRING: 30
};
asn1$2.create = function(t, e, r, n, i) {
  if (forge$j.util.isArray(n)) {
    for (var o = [], a = 0; a < n.length; ++a)
      n[a] !== void 0 && o.push(n[a]);
    n = o;
  }
  var c = {
    tagClass: t,
    type: e,
    constructed: r,
    composed: r || forge$j.util.isArray(n),
    value: n
  };
  return i && "bitStringContents" in i && (c.bitStringContents = i.bitStringContents, c.original = asn1$2.copy(c)), c;
};
asn1$2.copy = function(t, e) {
  var r;
  if (forge$j.util.isArray(t)) {
    r = [];
    for (var n = 0; n < t.length; ++n)
      r.push(asn1$2.copy(t[n], e));
    return r;
  }
  return typeof t == "string" ? t : (r = {
    tagClass: t.tagClass,
    type: t.type,
    constructed: t.constructed,
    composed: t.composed,
    value: asn1$2.copy(t.value, e)
  }, e && !e.excludeBitStringContents && (r.bitStringContents = t.bitStringContents), r);
};
asn1$2.equals = function(t, e, r) {
  if (forge$j.util.isArray(t)) {
    if (!forge$j.util.isArray(e) || t.length !== e.length)
      return !1;
    for (var n = 0; n < t.length; ++n)
      if (!asn1$2.equals(t[n], e[n]))
        return !1;
    return !0;
  }
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "string")
    return t === e;
  var i = t.tagClass === e.tagClass && t.type === e.type && t.constructed === e.constructed && t.composed === e.composed && asn1$2.equals(t.value, e.value);
  return r && r.includeBitStringContents && (i = i && t.bitStringContents === e.bitStringContents), i;
};
asn1$2.getBerValueLength = function(t) {
  var e = t.getByte();
  if (e !== 128) {
    var r, n = e & 128;
    return n ? r = t.getInt((e & 127) << 3) : r = e, r;
  }
};
function _checkBufferLength(t, e, r) {
  if (r > e) {
    var n = new Error("Too few bytes to parse DER.");
    throw n.available = t.length(), n.remaining = e, n.requested = r, n;
  }
}
var _getValueLength = function(t, e) {
  var r = t.getByte();
  if (e--, r !== 128) {
    var n, i = r & 128;
    if (!i)
      n = r;
    else {
      var o = r & 127;
      _checkBufferLength(t, e, o), n = t.getInt(o << 3);
    }
    if (n < 0)
      throw new Error("Negative length: " + n);
    return n;
  }
};
asn1$2.fromDer = function(t, e) {
  e === void 0 && (e = {
    strict: !0,
    parseAllBytes: !0,
    decodeBitStrings: !0
  }), typeof e == "boolean" && (e = {
    strict: e,
    parseAllBytes: !0,
    decodeBitStrings: !0
  }), "strict" in e || (e.strict = !0), "parseAllBytes" in e || (e.parseAllBytes = !0), "decodeBitStrings" in e || (e.decodeBitStrings = !0), typeof t == "string" && (t = forge$j.util.createBuffer(t));
  var r = t.length(), n = _fromDer(t, t.length(), 0, e);
  if (e.parseAllBytes && t.length() !== 0) {
    var i = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
    throw i.byteCount = r, i.remaining = t.length(), i;
  }
  return n;
};
function _fromDer(t, e, r, n) {
  var i;
  _checkBufferLength(t, e, 2);
  var o = t.getByte();
  e--;
  var a = o & 192, c = o & 31;
  i = t.length();
  var l = _getValueLength(t, e);
  if (e -= i - t.length(), l !== void 0 && l > e) {
    if (n.strict) {
      var u = new Error("Too few bytes to read ASN.1 value.");
      throw u.available = t.length(), u.remaining = e, u.requested = l, u;
    }
    l = e;
  }
  var f, d, p = (o & 32) === 32;
  if (p)
    if (f = [], l === void 0)
      for (; ; ) {
        if (_checkBufferLength(t, e, 2), t.bytes(2) === String.fromCharCode(0, 0)) {
          t.getBytes(2), e -= 2;
          break;
        }
        i = t.length(), f.push(_fromDer(t, e, r + 1, n)), e -= i - t.length();
      }
    else
      for (; l > 0; )
        i = t.length(), f.push(_fromDer(t, l, r + 1, n)), e -= i - t.length(), l -= i - t.length();
  if (f === void 0 && a === asn1$2.Class.UNIVERSAL && c === asn1$2.Type.BITSTRING && (d = t.bytes(l)), f === void 0 && n.decodeBitStrings && a === asn1$2.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
  // .. other parts of forge expect to decode OCTET STRINGs manually
  c === asn1$2.Type.BITSTRING && l > 1) {
    var g = t.read, h = e, m = 0;
    if (c === asn1$2.Type.BITSTRING && (_checkBufferLength(t, e, 1), m = t.getByte(), e--), m === 0)
      try {
        i = t.length();
        var y = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          strict: !0,
          decodeBitStrings: !0
        }, b = _fromDer(t, e, r + 1, y), v = i - t.length();
        e -= v, c == asn1$2.Type.BITSTRING && v++;
        var _ = b.tagClass;
        v === l && (_ === asn1$2.Class.UNIVERSAL || _ === asn1$2.Class.CONTEXT_SPECIFIC) && (f = [b]);
      } catch {
      }
    f === void 0 && (t.read = g, e = h);
  }
  if (f === void 0) {
    if (l === void 0) {
      if (n.strict)
        throw new Error("Non-constructed ASN.1 object of indefinite length.");
      l = e;
    }
    if (c === asn1$2.Type.BMPSTRING)
      for (f = ""; l > 0; l -= 2)
        _checkBufferLength(t, e, 2), f += String.fromCharCode(t.getInt16()), e -= 2;
    else
      f = t.getBytes(l), e -= l;
  }
  var E = d === void 0 ? null : {
    bitStringContents: d
  };
  return asn1$2.create(a, c, p, f, E);
}
asn1$2.toDer = function(t) {
  var e = forge$j.util.createBuffer(), r = t.tagClass | t.type, n = forge$j.util.createBuffer(), i = !1;
  if ("bitStringContents" in t && (i = !0, t.original && (i = asn1$2.equals(t, t.original))), i)
    n.putBytes(t.bitStringContents);
  else if (t.composed) {
    t.constructed ? r |= 32 : n.putByte(0);
    for (var o = 0; o < t.value.length; ++o)
      t.value[o] !== void 0 && n.putBuffer(asn1$2.toDer(t.value[o]));
  } else if (t.type === asn1$2.Type.BMPSTRING)
    for (var o = 0; o < t.value.length; ++o)
      n.putInt16(t.value.charCodeAt(o));
  else
    t.type === asn1$2.Type.INTEGER && t.value.length > 1 && // leading 0x00 for positive integer
    (t.value.charCodeAt(0) === 0 && !(t.value.charCodeAt(1) & 128) || // leading 0xFF for negative integer
    t.value.charCodeAt(0) === 255 && (t.value.charCodeAt(1) & 128) === 128) ? n.putBytes(t.value.substr(1)) : n.putBytes(t.value);
  if (e.putByte(r), n.length() <= 127)
    e.putByte(n.length() & 127);
  else {
    var a = n.length(), c = "";
    do
      c += String.fromCharCode(a & 255), a = a >>> 8;
    while (a > 0);
    e.putByte(c.length | 128);
    for (var o = c.length - 1; o >= 0; --o)
      e.putByte(c.charCodeAt(o));
  }
  return e.putBuffer(n), e;
};
asn1$2.oidToDer = function(t) {
  var e = t.split("."), r = forge$j.util.createBuffer();
  r.putByte(40 * parseInt(e[0], 10) + parseInt(e[1], 10));
  for (var n, i, o, a, c = 2; c < e.length; ++c) {
    n = !0, i = [], o = parseInt(e[c], 10);
    do
      a = o & 127, o = o >>> 7, n || (a |= 128), i.push(a), n = !1;
    while (o > 0);
    for (var l = i.length - 1; l >= 0; --l)
      r.putByte(i[l]);
  }
  return r;
};
asn1$2.derToOid = function(t) {
  var e;
  typeof t == "string" && (t = forge$j.util.createBuffer(t));
  var r = t.getByte();
  e = Math.floor(r / 40) + "." + r % 40;
  for (var n = 0; t.length() > 0; )
    r = t.getByte(), n = n << 7, r & 128 ? n += r & 127 : (e += "." + (n + r), n = 0);
  return e;
};
asn1$2.utcTimeToDate = function(t) {
  var e = new Date(), r = parseInt(t.substr(0, 2), 10);
  r = r >= 50 ? 1900 + r : 2e3 + r;
  var n = parseInt(t.substr(2, 2), 10) - 1, i = parseInt(t.substr(4, 2), 10), o = parseInt(t.substr(6, 2), 10), a = parseInt(t.substr(8, 2), 10), c = 0;
  if (t.length > 11) {
    var l = t.charAt(10), u = 10;
    l !== "+" && l !== "-" && (c = parseInt(t.substr(10, 2), 10), u += 2);
  }
  if (e.setUTCFullYear(r, n, i), e.setUTCHours(o, a, c, 0), u && (l = t.charAt(u), l === "+" || l === "-")) {
    var f = parseInt(t.substr(u + 1, 2), 10), d = parseInt(t.substr(u + 4, 2), 10), p = f * 60 + d;
    p *= 6e4, l === "+" ? e.setTime(+e - p) : e.setTime(+e + p);
  }
  return e;
};
asn1$2.generalizedTimeToDate = function(t) {
  var e = new Date(), r = parseInt(t.substr(0, 4), 10), n = parseInt(t.substr(4, 2), 10) - 1, i = parseInt(t.substr(6, 2), 10), o = parseInt(t.substr(8, 2), 10), a = parseInt(t.substr(10, 2), 10), c = parseInt(t.substr(12, 2), 10), l = 0, u = 0, f = !1;
  t.charAt(t.length - 1) === "Z" && (f = !0);
  var d = t.length - 5, p = t.charAt(d);
  if (p === "+" || p === "-") {
    var g = parseInt(t.substr(d + 1, 2), 10), h = parseInt(t.substr(d + 4, 2), 10);
    u = g * 60 + h, u *= 6e4, p === "+" && (u *= -1), f = !0;
  }
  return t.charAt(14) === "." && (l = parseFloat(t.substr(14), 10) * 1e3), f ? (e.setUTCFullYear(r, n, i), e.setUTCHours(o, a, c, l), e.setTime(+e + u)) : (e.setFullYear(r, n, i), e.setHours(o, a, c, l)), e;
};
asn1$2.dateToUtcTime = function(t) {
  if (typeof t == "string")
    return t;
  var e = "", r = [];
  r.push(("" + t.getUTCFullYear()).substr(2)), r.push("" + (t.getUTCMonth() + 1)), r.push("" + t.getUTCDate()), r.push("" + t.getUTCHours()), r.push("" + t.getUTCMinutes()), r.push("" + t.getUTCSeconds());
  for (var n = 0; n < r.length; ++n)
    r[n].length < 2 && (e += "0"), e += r[n];
  return e += "Z", e;
};
asn1$2.dateToGeneralizedTime = function(t) {
  if (typeof t == "string")
    return t;
  var e = "", r = [];
  r.push("" + t.getUTCFullYear()), r.push("" + (t.getUTCMonth() + 1)), r.push("" + t.getUTCDate()), r.push("" + t.getUTCHours()), r.push("" + t.getUTCMinutes()), r.push("" + t.getUTCSeconds());
  for (var n = 0; n < r.length; ++n)
    r[n].length < 2 && (e += "0"), e += r[n];
  return e += "Z", e;
};
asn1$2.integerToDer = function(t) {
  var e = forge$j.util.createBuffer();
  if (t >= -128 && t < 128)
    return e.putSignedInt(t, 8);
  if (t >= -32768 && t < 32768)
    return e.putSignedInt(t, 16);
  if (t >= -8388608 && t < 8388608)
    return e.putSignedInt(t, 24);
  if (t >= -2147483648 && t < 2147483648)
    return e.putSignedInt(t, 32);
  var r = new Error("Integer too large; max is 32-bits.");
  throw r.integer = t, r;
};
asn1$2.derToInteger = function(t) {
  typeof t == "string" && (t = forge$j.util.createBuffer(t));
  var e = t.length() * 8;
  if (e > 32)
    throw new Error("Integer too large; max is 32-bits.");
  return t.getSignedInt(e);
};
asn1$2.validate = function(t, e, r, n) {
  var i = !1;
  if ((t.tagClass === e.tagClass || typeof e.tagClass > "u") && (t.type === e.type || typeof e.type > "u"))
    if (t.constructed === e.constructed || typeof e.constructed > "u") {
      if (i = !0, e.value && forge$j.util.isArray(e.value))
        for (var o = 0, a = 0; i && a < e.value.length; ++a)
          i = e.value[a].optional || !1, t.value[o] && (i = asn1$2.validate(t.value[o], e.value[a], r, n), i ? ++o : e.value[a].optional && (i = !0)), !i && n && n.push(
            "[" + e.name + '] Tag class "' + e.tagClass + '", type "' + e.type + '" expected value length "' + e.value.length + '", got "' + t.value.length + '"'
          );
      if (i && r && (e.capture && (r[e.capture] = t.value), e.captureAsn1 && (r[e.captureAsn1] = t), e.captureBitStringContents && "bitStringContents" in t && (r[e.captureBitStringContents] = t.bitStringContents), e.captureBitStringValue && "bitStringContents" in t))
        if (t.bitStringContents.length < 2)
          r[e.captureBitStringValue] = "";
        else {
          var c = t.bitStringContents.charCodeAt(0);
          if (c !== 0)
            throw new Error(
              "captureBitStringValue only supported for zero unused bits"
            );
          r[e.captureBitStringValue] = t.bitStringContents.slice(1);
        }
    } else
      n && n.push(
        "[" + e.name + '] Expected constructed "' + e.constructed + '", got "' + t.constructed + '"'
      );
  else
    n && (t.tagClass !== e.tagClass && n.push(
      "[" + e.name + '] Expected tag class "' + e.tagClass + '", got "' + t.tagClass + '"'
    ), t.type !== e.type && n.push(
      "[" + e.name + '] Expected type "' + e.type + '", got "' + t.type + '"'
    ));
  return i;
};
var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
asn1$2.prettyPrint = function(t, e, r) {
  var n = "";
  e = e || 0, r = r || 2, e > 0 && (n += `
`);
  for (var i = "", o = 0; o < e * r; ++o)
    i += " ";
  switch (n += i + "Tag: ", t.tagClass) {
    case asn1$2.Class.UNIVERSAL:
      n += "Universal:";
      break;
    case asn1$2.Class.APPLICATION:
      n += "Application:";
      break;
    case asn1$2.Class.CONTEXT_SPECIFIC:
      n += "Context-Specific:";
      break;
    case asn1$2.Class.PRIVATE:
      n += "Private:";
      break;
  }
  if (t.tagClass === asn1$2.Class.UNIVERSAL)
    switch (n += t.type, t.type) {
      case asn1$2.Type.NONE:
        n += " (None)";
        break;
      case asn1$2.Type.BOOLEAN:
        n += " (Boolean)";
        break;
      case asn1$2.Type.INTEGER:
        n += " (Integer)";
        break;
      case asn1$2.Type.BITSTRING:
        n += " (Bit string)";
        break;
      case asn1$2.Type.OCTETSTRING:
        n += " (Octet string)";
        break;
      case asn1$2.Type.NULL:
        n += " (Null)";
        break;
      case asn1$2.Type.OID:
        n += " (Object Identifier)";
        break;
      case asn1$2.Type.ODESC:
        n += " (Object Descriptor)";
        break;
      case asn1$2.Type.EXTERNAL:
        n += " (External or Instance of)";
        break;
      case asn1$2.Type.REAL:
        n += " (Real)";
        break;
      case asn1$2.Type.ENUMERATED:
        n += " (Enumerated)";
        break;
      case asn1$2.Type.EMBEDDED:
        n += " (Embedded PDV)";
        break;
      case asn1$2.Type.UTF8:
        n += " (UTF8)";
        break;
      case asn1$2.Type.ROID:
        n += " (Relative Object Identifier)";
        break;
      case asn1$2.Type.SEQUENCE:
        n += " (Sequence)";
        break;
      case asn1$2.Type.SET:
        n += " (Set)";
        break;
      case asn1$2.Type.PRINTABLESTRING:
        n += " (Printable String)";
        break;
      case asn1$2.Type.IA5String:
        n += " (IA5String (ASCII))";
        break;
      case asn1$2.Type.UTCTIME:
        n += " (UTC time)";
        break;
      case asn1$2.Type.GENERALIZEDTIME:
        n += " (Generalized time)";
        break;
      case asn1$2.Type.BMPSTRING:
        n += " (BMP String)";
        break;
    }
  else
    n += t.type;
  if (n += `
`, n += i + "Constructed: " + t.constructed + `
`, t.composed) {
    for (var a = 0, c = "", o = 0; o < t.value.length; ++o)
      t.value[o] !== void 0 && (a += 1, c += asn1$2.prettyPrint(t.value[o], e + 1, r), o + 1 < t.value.length && (c += ","));
    n += i + "Sub values: " + a + c;
  } else {
    if (n += i + "Value: ", t.type === asn1$2.Type.OID) {
      var l = asn1$2.derToOid(t.value);
      n += l, forge$j.pki && forge$j.pki.oids && l in forge$j.pki.oids && (n += " (" + forge$j.pki.oids[l] + ") ");
    }
    if (t.type === asn1$2.Type.INTEGER)
      try {
        n += asn1$2.derToInteger(t.value);
      } catch {
        n += "0x" + forge$j.util.bytesToHex(t.value);
      }
    else if (t.type === asn1$2.Type.BITSTRING) {
      if (t.value.length > 1 ? n += "0x" + forge$j.util.bytesToHex(t.value.slice(1)) : n += "(none)", t.value.length > 0) {
        var u = t.value.charCodeAt(0);
        u == 1 ? n += " (1 unused bit shown)" : u > 1 && (n += " (" + u + " unused bits shown)");
      }
    } else if (t.type === asn1$2.Type.OCTETSTRING)
      _nonLatinRegex.test(t.value) || (n += "(" + t.value + ") "), n += "0x" + forge$j.util.bytesToHex(t.value);
    else if (t.type === asn1$2.Type.UTF8)
      try {
        n += forge$j.util.decodeUtf8(t.value);
      } catch (f) {
        if (f.message === "URI malformed")
          n += "0x" + forge$j.util.bytesToHex(t.value) + " (malformed UTF8)";
        else
          throw f;
      }
    else
      t.type === asn1$2.Type.PRINTABLESTRING || t.type === asn1$2.Type.IA5String ? n += t.value : _nonLatinRegex.test(t.value) ? n += "0x" + forge$j.util.bytesToHex(t.value) : t.value.length === 0 ? n += "[null]" : n += t.value;
  }
  return n;
};
var forge$i = forge$m;
forge$i.cipher = forge$i.cipher || {};
forge$i.cipher.algorithms = forge$i.cipher.algorithms || {};
forge$i.cipher.createCipher = function(t, e) {
  var r = t;
  if (typeof r == "string" && (r = forge$i.cipher.getAlgorithm(r), r && (r = r())), !r)
    throw new Error("Unsupported algorithm: " + t);
  return new forge$i.cipher.BlockCipher({
    algorithm: r,
    key: e,
    decrypt: !1
  });
};
forge$i.cipher.createDecipher = function(t, e) {
  var r = t;
  if (typeof r == "string" && (r = forge$i.cipher.getAlgorithm(r), r && (r = r())), !r)
    throw new Error("Unsupported algorithm: " + t);
  return new forge$i.cipher.BlockCipher({
    algorithm: r,
    key: e,
    decrypt: !0
  });
};
forge$i.cipher.registerAlgorithm = function(t, e) {
  t = t.toUpperCase(), forge$i.cipher.algorithms[t] = e;
};
forge$i.cipher.getAlgorithm = function(t) {
  return t = t.toUpperCase(), t in forge$i.cipher.algorithms ? forge$i.cipher.algorithms[t] : null;
};
var BlockCipher = forge$i.cipher.BlockCipher = function(t) {
  this.algorithm = t.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = t.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = t.decrypt, this.algorithm.initialize(t);
};
BlockCipher.prototype.start = function(t) {
  t = t || {};
  var e = {};
  for (var r in t)
    e[r] = t[r];
  e.decrypt = this._decrypt, this._finish = !1, this._input = forge$i.util.createBuffer(), this.output = t.output || forge$i.util.createBuffer(), this.mode.start(e);
};
BlockCipher.prototype.update = function(t) {
  for (t && this._input.putBuffer(t); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; )
    ;
  this._input.compact();
};
BlockCipher.prototype.finish = function(t) {
  t && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function(r) {
    return t(this.blockSize, r, !1);
  }, this.mode.unpad = function(r) {
    return t(this.blockSize, r, !0);
  });
  var e = {};
  return e.decrypt = this._decrypt, e.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, e) || (this._finish = !0, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, e)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, e));
};
var forge$h = forge$m;
forge$h.cipher = forge$h.cipher || {};
var modes = forge$h.cipher.modes = forge$h.cipher.modes || {};
modes.ecb = function(t) {
  t = t || {}, this.name = "ECB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
modes.ecb.prototype.start = function(t) {
};
modes.ecb.prototype.encrypt = function(t, e, r) {
  if (t.length() < this.blockSize && !(r && t.length() > 0))
    return !0;
  for (var n = 0; n < this._ints; ++n)
    this._inBlock[n] = t.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var n = 0; n < this._ints; ++n)
    e.putInt32(this._outBlock[n]);
};
modes.ecb.prototype.decrypt = function(t, e, r) {
  if (t.length() < this.blockSize && !(r && t.length() > 0))
    return !0;
  for (var n = 0; n < this._ints; ++n)
    this._inBlock[n] = t.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var n = 0; n < this._ints; ++n)
    e.putInt32(this._outBlock[n]);
};
modes.ecb.prototype.pad = function(t, e) {
  var r = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length();
  return t.fillWithByte(r, r), !0;
};
modes.ecb.prototype.unpad = function(t, e) {
  if (e.overflow > 0)
    return !1;
  var r = t.length(), n = t.at(r - 1);
  return n > this.blockSize << 2 ? !1 : (t.truncate(n), !0);
};
modes.cbc = function(t) {
  t = t || {}, this.name = "CBC", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
modes.cbc.prototype.start = function(t) {
  if (t.iv === null) {
    if (!this._prev)
      throw new Error("Invalid IV parameter.");
    this._iv = this._prev.slice(0);
  } else if ("iv" in t)
    this._iv = transformIV(t.iv, this.blockSize), this._prev = this._iv.slice(0);
  else
    throw new Error("Invalid IV parameter.");
};
modes.cbc.prototype.encrypt = function(t, e, r) {
  if (t.length() < this.blockSize && !(r && t.length() > 0))
    return !0;
  for (var n = 0; n < this._ints; ++n)
    this._inBlock[n] = this._prev[n] ^ t.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var n = 0; n < this._ints; ++n)
    e.putInt32(this._outBlock[n]);
  this._prev = this._outBlock;
};
modes.cbc.prototype.decrypt = function(t, e, r) {
  if (t.length() < this.blockSize && !(r && t.length() > 0))
    return !0;
  for (var n = 0; n < this._ints; ++n)
    this._inBlock[n] = t.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var n = 0; n < this._ints; ++n)
    e.putInt32(this._prev[n] ^ this._outBlock[n]);
  this._prev = this._inBlock.slice(0);
};
modes.cbc.prototype.pad = function(t, e) {
  var r = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length();
  return t.fillWithByte(r, r), !0;
};
modes.cbc.prototype.unpad = function(t, e) {
  if (e.overflow > 0)
    return !1;
  var r = t.length(), n = t.at(r - 1);
  return n > this.blockSize << 2 ? !1 : (t.truncate(n), !0);
};
modes.cfb = function(t) {
  t = t || {}, this.name = "CFB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = forge$h.util.createBuffer(), this._partialBytes = 0;
};
modes.cfb.prototype.start = function(t) {
  if (!("iv" in t))
    throw new Error("Invalid IV parameter.");
  this._iv = transformIV(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
modes.cfb.prototype.encrypt = function(t, e, r) {
  var n = t.length();
  if (n === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i)
      this._inBlock[i] = t.getInt32() ^ this._outBlock[i], e.putInt32(this._inBlock[i]);
    return;
  }
  var o = (this.blockSize - n) % this.blockSize;
  o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
  for (var i = 0; i < this._ints; ++i)
    this._partialBlock[i] = t.getInt32() ^ this._outBlock[i], this._partialOutput.putInt32(this._partialBlock[i]);
  if (o > 0)
    t.read -= this.blockSize;
  else
    for (var i = 0; i < this._ints; ++i)
      this._inBlock[i] = this._partialBlock[i];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
    return e.putBytes(this._partialOutput.getBytes(
      o - this._partialBytes
    )), this._partialBytes = o, !0;
  e.putBytes(this._partialOutput.getBytes(
    n - this._partialBytes
  )), this._partialBytes = 0;
};
modes.cfb.prototype.decrypt = function(t, e, r) {
  var n = t.length();
  if (n === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i)
      this._inBlock[i] = t.getInt32(), e.putInt32(this._inBlock[i] ^ this._outBlock[i]);
    return;
  }
  var o = (this.blockSize - n) % this.blockSize;
  o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
  for (var i = 0; i < this._ints; ++i)
    this._partialBlock[i] = t.getInt32(), this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
  if (o > 0)
    t.read -= this.blockSize;
  else
    for (var i = 0; i < this._ints; ++i)
      this._inBlock[i] = this._partialBlock[i];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
    return e.putBytes(this._partialOutput.getBytes(
      o - this._partialBytes
    )), this._partialBytes = o, !0;
  e.putBytes(this._partialOutput.getBytes(
    n - this._partialBytes
  )), this._partialBytes = 0;
};
modes.ofb = function(t) {
  t = t || {}, this.name = "OFB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = forge$h.util.createBuffer(), this._partialBytes = 0;
};
modes.ofb.prototype.start = function(t) {
  if (!("iv" in t))
    throw new Error("Invalid IV parameter.");
  this._iv = transformIV(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
modes.ofb.prototype.encrypt = function(t, e, r) {
  var n = t.length();
  if (t.length() === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i)
      e.putInt32(t.getInt32() ^ this._outBlock[i]), this._inBlock[i] = this._outBlock[i];
    return;
  }
  var o = (this.blockSize - n) % this.blockSize;
  o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
  for (var i = 0; i < this._ints; ++i)
    this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i]);
  if (o > 0)
    t.read -= this.blockSize;
  else
    for (var i = 0; i < this._ints; ++i)
      this._inBlock[i] = this._outBlock[i];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
    return e.putBytes(this._partialOutput.getBytes(
      o - this._partialBytes
    )), this._partialBytes = o, !0;
  e.putBytes(this._partialOutput.getBytes(
    n - this._partialBytes
  )), this._partialBytes = 0;
};
modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
modes.ctr = function(t) {
  t = t || {}, this.name = "CTR", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = forge$h.util.createBuffer(), this._partialBytes = 0;
};
modes.ctr.prototype.start = function(t) {
  if (!("iv" in t))
    throw new Error("Invalid IV parameter.");
  this._iv = transformIV(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
modes.ctr.prototype.encrypt = function(t, e, r) {
  var n = t.length();
  if (n === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)
    for (var i = 0; i < this._ints; ++i)
      e.putInt32(t.getInt32() ^ this._outBlock[i]);
  else {
    var o = (this.blockSize - n) % this.blockSize;
    o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i)
      this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i]);
    if (o > 0 && (t.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
      return e.putBytes(this._partialOutput.getBytes(
        o - this._partialBytes
      )), this._partialBytes = o, !0;
    e.putBytes(this._partialOutput.getBytes(
      n - this._partialBytes
    )), this._partialBytes = 0;
  }
  inc32(this._inBlock);
};
modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
modes.gcm = function(t) {
  t = t || {}, this.name = "GCM", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = forge$h.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
};
modes.gcm.prototype.start = function(t) {
  if (!("iv" in t))
    throw new Error("Invalid IV parameter.");
  var e = forge$h.util.createBuffer(t.iv);
  this._cipherLength = 0;
  var r;
  if ("additionalData" in t ? r = forge$h.util.createBuffer(t.additionalData) : r = forge$h.util.createBuffer(), "tagLength" in t ? this._tagLength = t.tagLength : this._tagLength = 128, this._tag = null, t.decrypt && (this._tag = forge$h.util.createBuffer(t.tag).getBytes(), this._tag.length !== this._tagLength / 8))
    throw new Error("Authentication tag does not match tag length.");
  this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var n = e.length();
  if (n === 12)
    this._j0 = [e.getInt32(), e.getInt32(), e.getInt32(), 1];
  else {
    for (this._j0 = [0, 0, 0, 0]; e.length() > 0; )
      this._j0 = this.ghash(
        this._hashSubkey,
        this._j0,
        [e.getInt32(), e.getInt32(), e.getInt32(), e.getInt32()]
      );
    this._j0 = this.ghash(
      this._hashSubkey,
      this._j0,
      [0, 0].concat(from64To32(n * 8))
    );
  }
  this._inBlock = this._j0.slice(0), inc32(this._inBlock), this._partialBytes = 0, r = forge$h.util.createBuffer(r), this._aDataLength = from64To32(r.length() * 8);
  var i = r.length() % this.blockSize;
  for (i && r.fillWithByte(0, this.blockSize - i), this._s = [0, 0, 0, 0]; r.length() > 0; )
    this._s = this.ghash(this._hashSubkey, this._s, [
      r.getInt32(),
      r.getInt32(),
      r.getInt32(),
      r.getInt32()
    ]);
};
modes.gcm.prototype.encrypt = function(t, e, r) {
  var n = t.length();
  if (n === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i)
      e.putInt32(this._outBlock[i] ^= t.getInt32());
    this._cipherLength += this.blockSize;
  } else {
    var o = (this.blockSize - n) % this.blockSize;
    o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i)
      this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i]);
    if (o <= 0 || r) {
      if (r) {
        var a = n % this.blockSize;
        this._cipherLength += a, this._partialOutput.truncate(this.blockSize - a);
      } else
        this._cipherLength += this.blockSize;
      for (var i = 0; i < this._ints; ++i)
        this._outBlock[i] = this._partialOutput.getInt32();
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
      return t.read -= this.blockSize, e.putBytes(this._partialOutput.getBytes(
        o - this._partialBytes
      )), this._partialBytes = o, !0;
    e.putBytes(this._partialOutput.getBytes(
      n - this._partialBytes
    )), this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), inc32(this._inBlock);
};
modes.gcm.prototype.decrypt = function(t, e, r) {
  var n = t.length();
  if (n < this.blockSize && !(r && n > 0))
    return !0;
  this.cipher.encrypt(this._inBlock, this._outBlock), inc32(this._inBlock), this._hashBlock[0] = t.getInt32(), this._hashBlock[1] = t.getInt32(), this._hashBlock[2] = t.getInt32(), this._hashBlock[3] = t.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var i = 0; i < this._ints; ++i)
    e.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
  n < this.blockSize ? this._cipherLength += n % this.blockSize : this._cipherLength += this.blockSize;
};
modes.gcm.prototype.afterFinish = function(t, e) {
  var r = !0;
  e.decrypt && e.overflow && t.truncate(this.blockSize - e.overflow), this.tag = forge$h.util.createBuffer();
  var n = this._aDataLength.concat(from64To32(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, n);
  var i = [];
  this.cipher.encrypt(this._j0, i);
  for (var o = 0; o < this._ints; ++o)
    this.tag.putInt32(this._s[o] ^ i[o]);
  return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), e.decrypt && this.tag.bytes() !== this._tag && (r = !1), r;
};
modes.gcm.prototype.multiply = function(t, e) {
  for (var r = [0, 0, 0, 0], n = e.slice(0), i = 0; i < 128; ++i) {
    var o = t[i / 32 | 0] & 1 << 31 - i % 32;
    o && (r[0] ^= n[0], r[1] ^= n[1], r[2] ^= n[2], r[3] ^= n[3]), this.pow(n, n);
  }
  return r;
};
modes.gcm.prototype.pow = function(t, e) {
  for (var r = t[3] & 1, n = 3; n > 0; --n)
    e[n] = t[n] >>> 1 | (t[n - 1] & 1) << 31;
  e[0] = t[0] >>> 1, r && (e[0] ^= this._R);
};
modes.gcm.prototype.tableMultiply = function(t) {
  for (var e = [0, 0, 0, 0], r = 0; r < 32; ++r) {
    var n = r / 8 | 0, i = t[n] >>> (7 - r % 8) * 4 & 15, o = this._m[r][i];
    e[0] ^= o[0], e[1] ^= o[1], e[2] ^= o[2], e[3] ^= o[3];
  }
  return e;
};
modes.gcm.prototype.ghash = function(t, e, r) {
  return e[0] ^= r[0], e[1] ^= r[1], e[2] ^= r[2], e[3] ^= r[3], this.tableMultiply(e);
};
modes.gcm.prototype.generateHashTable = function(t, e) {
  for (var r = 8 / e, n = 4 * r, i = 16 * r, o = new Array(i), a = 0; a < i; ++a) {
    var c = [0, 0, 0, 0], l = a / n | 0, u = (n - 1 - a % n) * e;
    c[l] = 1 << e - 1 << u, o[a] = this.generateSubHashTable(this.multiply(c, t), e);
  }
  return o;
};
modes.gcm.prototype.generateSubHashTable = function(t, e) {
  var r = 1 << e, n = r >>> 1, i = new Array(r);
  i[n] = t.slice(0);
  for (var o = n >>> 1; o > 0; )
    this.pow(i[2 * o], i[o] = []), o >>= 1;
  for (o = 2; o < n; ) {
    for (var a = 1; a < o; ++a) {
      var c = i[o], l = i[a];
      i[o + a] = [
        c[0] ^ l[0],
        c[1] ^ l[1],
        c[2] ^ l[2],
        c[3] ^ l[3]
      ];
    }
    o *= 2;
  }
  for (i[0] = [0, 0, 0, 0], o = n + 1; o < r; ++o) {
    var u = i[o ^ n];
    i[o] = [t[0] ^ u[0], t[1] ^ u[1], t[2] ^ u[2], t[3] ^ u[3]];
  }
  return i;
};
function transformIV(t, e) {
  if (typeof t == "string" && (t = forge$h.util.createBuffer(t)), forge$h.util.isArray(t) && t.length > 4) {
    var r = t;
    t = forge$h.util.createBuffer();
    for (var n = 0; n < r.length; ++n)
      t.putByte(r[n]);
  }
  if (t.length() < e)
    throw new Error(
      "Invalid IV length; got " + t.length() + " bytes and expected " + e + " bytes."
    );
  if (!forge$h.util.isArray(t)) {
    for (var i = [], o = e / 4, n = 0; n < o; ++n)
      i.push(t.getInt32());
    t = i;
  }
  return t;
}
function inc32(t) {
  t[t.length - 1] = t[t.length - 1] + 1 & 4294967295;
}
function from64To32(t) {
  return [t / 4294967296 | 0, t & 4294967295];
}
var forge$g = forge$m;
forge$g.aes = forge$g.aes || {};
forge$g.aes.startEncrypting = function(t, e, r, n) {
  var i = _createCipher$1({
    key: t,
    output: r,
    decrypt: !1,
    mode: n
  });
  return i.start(e), i;
};
forge$g.aes.createEncryptionCipher = function(t, e) {
  return _createCipher$1({
    key: t,
    output: null,
    decrypt: !1,
    mode: e
  });
};
forge$g.aes.startDecrypting = function(t, e, r, n) {
  var i = _createCipher$1({
    key: t,
    output: r,
    decrypt: !0,
    mode: n
  });
  return i.start(e), i;
};
forge$g.aes.createDecryptionCipher = function(t, e) {
  return _createCipher$1({
    key: t,
    output: null,
    decrypt: !0,
    mode: e
  });
};
forge$g.aes.Algorithm = function(t, e) {
  init || initialize();
  var r = this;
  r.name = t, r.mode = new e({
    blockSize: 16,
    cipher: {
      encrypt: function(n, i) {
        return _updateBlock$1(r._w, n, i, !1);
      },
      decrypt: function(n, i) {
        return _updateBlock$1(r._w, n, i, !0);
      }
    }
  }), r._init = !1;
};
forge$g.aes.Algorithm.prototype.initialize = function(t) {
  if (!this._init) {
    var e = t.key, r;
    if (typeof e == "string" && (e.length === 16 || e.length === 24 || e.length === 32))
      e = forge$g.util.createBuffer(e);
    else if (forge$g.util.isArray(e) && (e.length === 16 || e.length === 24 || e.length === 32)) {
      r = e, e = forge$g.util.createBuffer();
      for (var n = 0; n < r.length; ++n)
        e.putByte(r[n]);
    }
    if (!forge$g.util.isArray(e)) {
      r = e, e = [];
      var i = r.length();
      if (i === 16 || i === 24 || i === 32) {
        i = i >>> 2;
        for (var n = 0; n < i; ++n)
          e.push(r.getInt32());
      }
    }
    if (!forge$g.util.isArray(e) || !(e.length === 4 || e.length === 6 || e.length === 8))
      throw new Error("Invalid key parameter.");
    var o = this.mode.name, a = ["CFB", "OFB", "CTR", "GCM"].indexOf(o) !== -1;
    this._w = _expandKey(e, t.decrypt && !a), this._init = !0;
  }
};
forge$g.aes._expandKey = function(t, e) {
  return init || initialize(), _expandKey(t, e);
};
forge$g.aes._updateBlock = _updateBlock$1;
registerAlgorithm$1("AES-ECB", forge$g.cipher.modes.ecb);
registerAlgorithm$1("AES-CBC", forge$g.cipher.modes.cbc);
registerAlgorithm$1("AES-CFB", forge$g.cipher.modes.cfb);
registerAlgorithm$1("AES-OFB", forge$g.cipher.modes.ofb);
registerAlgorithm$1("AES-CTR", forge$g.cipher.modes.ctr);
registerAlgorithm$1("AES-GCM", forge$g.cipher.modes.gcm);
function registerAlgorithm$1(t, e) {
  var r = function() {
    return new forge$g.aes.Algorithm(t, e);
  };
  forge$g.cipher.registerAlgorithm(t, r);
}
var init = !1, Nb = 4, sbox, isbox, rcon, mix, imix;
function initialize() {
  init = !0, rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  for (var t = new Array(256), e = 0; e < 128; ++e)
    t[e] = e << 1, t[e + 128] = e + 128 << 1 ^ 283;
  sbox = new Array(256), isbox = new Array(256), mix = new Array(4), imix = new Array(4);
  for (var e = 0; e < 4; ++e)
    mix[e] = new Array(256), imix[e] = new Array(256);
  for (var r = 0, n = 0, i, o, a, c, l, u, f, e = 0; e < 256; ++e) {
    c = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4, c = c >> 8 ^ c & 255 ^ 99, sbox[r] = c, isbox[c] = r, l = t[c], i = t[r], o = t[i], a = t[o], u = l << 24 ^ // 2
    c << 16 ^ // 1
    c << 8 ^ // 1
    (c ^ l), f = (i ^ o ^ a) << 24 ^ // E (14)
    (r ^ a) << 16 ^ // 9
    (r ^ o ^ a) << 8 ^ // D (13)
    (r ^ i ^ a);
    for (var d = 0; d < 4; ++d)
      mix[d][r] = u, imix[d][c] = f, u = u << 24 | u >>> 8, f = f << 24 | f >>> 8;
    r === 0 ? r = n = 1 : (r = i ^ t[t[t[i ^ a]]], n ^= t[t[n]]);
  }
}
function _expandKey(t, e) {
  for (var r = t.slice(0), n, i = 1, o = r.length, a = o + 6 + 1, c = Nb * a, l = o; l < c; ++l)
    n = r[l - 1], l % o === 0 ? (n = sbox[n >>> 16 & 255] << 24 ^ sbox[n >>> 8 & 255] << 16 ^ sbox[n & 255] << 8 ^ sbox[n >>> 24] ^ rcon[i] << 24, i++) : o > 6 && l % o === 4 && (n = sbox[n >>> 24] << 24 ^ sbox[n >>> 16 & 255] << 16 ^ sbox[n >>> 8 & 255] << 8 ^ sbox[n & 255]), r[l] = r[l - o] ^ n;
  if (e) {
    var u, f = imix[0], d = imix[1], p = imix[2], g = imix[3], h = r.slice(0);
    c = r.length;
    for (var l = 0, m = c - Nb; l < c; l += Nb, m -= Nb)
      if (l === 0 || l === c - Nb)
        h[l] = r[m], h[l + 1] = r[m + 3], h[l + 2] = r[m + 2], h[l + 3] = r[m + 1];
      else
        for (var y = 0; y < Nb; ++y)
          u = r[m + y], h[l + (3 & -y)] = f[sbox[u >>> 24]] ^ d[sbox[u >>> 16 & 255]] ^ p[sbox[u >>> 8 & 255]] ^ g[sbox[u & 255]];
    r = h;
  }
  return r;
}
function _updateBlock$1(t, e, r, n) {
  var i = t.length / 4 - 1, o, a, c, l, u;
  n ? (o = imix[0], a = imix[1], c = imix[2], l = imix[3], u = isbox) : (o = mix[0], a = mix[1], c = mix[2], l = mix[3], u = sbox);
  var f, d, p, g, h, m, y;
  f = e[0] ^ t[0], d = e[n ? 3 : 1] ^ t[1], p = e[2] ^ t[2], g = e[n ? 1 : 3] ^ t[3];
  for (var b = 3, v = 1; v < i; ++v)
    h = o[f >>> 24] ^ a[d >>> 16 & 255] ^ c[p >>> 8 & 255] ^ l[g & 255] ^ t[++b], m = o[d >>> 24] ^ a[p >>> 16 & 255] ^ c[g >>> 8 & 255] ^ l[f & 255] ^ t[++b], y = o[p >>> 24] ^ a[g >>> 16 & 255] ^ c[f >>> 8 & 255] ^ l[d & 255] ^ t[++b], g = o[g >>> 24] ^ a[f >>> 16 & 255] ^ c[d >>> 8 & 255] ^ l[p & 255] ^ t[++b], f = h, d = m, p = y;
  r[0] = u[f >>> 24] << 24 ^ u[d >>> 16 & 255] << 16 ^ u[p >>> 8 & 255] << 8 ^ u[g & 255] ^ t[++b], r[n ? 3 : 1] = u[d >>> 24] << 24 ^ u[p >>> 16 & 255] << 16 ^ u[g >>> 8 & 255] << 8 ^ u[f & 255] ^ t[++b], r[2] = u[p >>> 24] << 24 ^ u[g >>> 16 & 255] << 16 ^ u[f >>> 8 & 255] << 8 ^ u[d & 255] ^ t[++b], r[n ? 1 : 3] = u[g >>> 24] << 24 ^ u[f >>> 16 & 255] << 16 ^ u[d >>> 8 & 255] << 8 ^ u[p & 255] ^ t[++b];
}
function _createCipher$1(t) {
  t = t || {};
  var e = (t.mode || "CBC").toUpperCase(), r = "AES-" + e, n;
  t.decrypt ? n = forge$g.cipher.createDecipher(r, t.key) : n = forge$g.cipher.createCipher(r, t.key);
  var i = n.start;
  return n.start = function(o, a) {
    var c = null;
    a instanceof forge$g.util.ByteBuffer && (c = a, a = {}), a = a || {}, a.output = c, a.iv = o, i.call(n, a);
  }, n;
}
var forge$f = forge$m;
forge$f.des = forge$f.des || {};
forge$f.des.startEncrypting = function(t, e, r, n) {
  var i = _createCipher({
    key: t,
    output: r,
    decrypt: !1,
    mode: n || (e === null ? "ECB" : "CBC")
  });
  return i.start(e), i;
};
forge$f.des.createEncryptionCipher = function(t, e) {
  return _createCipher({
    key: t,
    output: null,
    decrypt: !1,
    mode: e
  });
};
forge$f.des.startDecrypting = function(t, e, r, n) {
  var i = _createCipher({
    key: t,
    output: r,
    decrypt: !0,
    mode: n || (e === null ? "ECB" : "CBC")
  });
  return i.start(e), i;
};
forge$f.des.createDecryptionCipher = function(t, e) {
  return _createCipher({
    key: t,
    output: null,
    decrypt: !0,
    mode: e
  });
};
forge$f.des.Algorithm = function(t, e) {
  var r = this;
  r.name = t, r.mode = new e({
    blockSize: 8,
    cipher: {
      encrypt: function(n, i) {
        return _updateBlock(r._keys, n, i, !1);
      },
      decrypt: function(n, i) {
        return _updateBlock(r._keys, n, i, !0);
      }
    }
  }), r._init = !1;
};
forge$f.des.Algorithm.prototype.initialize = function(t) {
  if (!this._init) {
    var e = forge$f.util.createBuffer(t.key);
    if (this.name.indexOf("3DES") === 0 && e.length() !== 24)
      throw new Error("Invalid Triple-DES key size: " + e.length() * 8);
    this._keys = _createKeys(e), this._init = !0;
  }
};
registerAlgorithm("DES-ECB", forge$f.cipher.modes.ecb);
registerAlgorithm("DES-CBC", forge$f.cipher.modes.cbc);
registerAlgorithm("DES-CFB", forge$f.cipher.modes.cfb);
registerAlgorithm("DES-OFB", forge$f.cipher.modes.ofb);
registerAlgorithm("DES-CTR", forge$f.cipher.modes.ctr);
registerAlgorithm("3DES-ECB", forge$f.cipher.modes.ecb);
registerAlgorithm("3DES-CBC", forge$f.cipher.modes.cbc);
registerAlgorithm("3DES-CFB", forge$f.cipher.modes.cfb);
registerAlgorithm("3DES-OFB", forge$f.cipher.modes.ofb);
registerAlgorithm("3DES-CTR", forge$f.cipher.modes.ctr);
function registerAlgorithm(t, e) {
  var r = function() {
    return new forge$f.des.Algorithm(t, e);
  };
  forge$f.cipher.registerAlgorithm(t, r);
}
var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function _createKeys(t) {
  for (var e = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], r = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], n = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], i = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], o = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], a = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], c = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], l = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], u = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], f = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], d = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], p = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], g = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], h = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], m = t.length() > 8 ? 3 : 1, y = [], b = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], v = 0, _, E = 0; E < m; E++) {
    var w = t.getInt32(), S = t.getInt32();
    _ = (w >>> 4 ^ S) & 252645135, S ^= _, w ^= _ << 4, _ = (S >>> -16 ^ w) & 65535, w ^= _, S ^= _ << -16, _ = (w >>> 2 ^ S) & 858993459, S ^= _, w ^= _ << 2, _ = (S >>> -16 ^ w) & 65535, w ^= _, S ^= _ << -16, _ = (w >>> 1 ^ S) & 1431655765, S ^= _, w ^= _ << 1, _ = (S >>> 8 ^ w) & 16711935, w ^= _, S ^= _ << 8, _ = (w >>> 1 ^ S) & 1431655765, S ^= _, w ^= _ << 1, _ = w << 8 | S >>> 20 & 240, w = S << 24 | S << 8 & 16711680 | S >>> 8 & 65280 | S >>> 24 & 240, S = _;
    for (var x = 0; x < b.length; ++x) {
      b[x] ? (w = w << 2 | w >>> 26, S = S << 2 | S >>> 26) : (w = w << 1 | w >>> 27, S = S << 1 | S >>> 27), w &= -15, S &= -15;
      var I = e[w >>> 28] | r[w >>> 24 & 15] | n[w >>> 20 & 15] | i[w >>> 16 & 15] | o[w >>> 12 & 15] | a[w >>> 8 & 15] | c[w >>> 4 & 15], C = l[S >>> 28] | u[S >>> 24 & 15] | f[S >>> 20 & 15] | d[S >>> 16 & 15] | p[S >>> 12 & 15] | g[S >>> 8 & 15] | h[S >>> 4 & 15];
      _ = (C >>> 16 ^ I) & 65535, y[v++] = I ^ _, y[v++] = C ^ _ << 16;
    }
  }
  return y;
}
function _updateBlock(t, e, r, n) {
  var i = t.length === 32 ? 3 : 9, o;
  i === 3 ? o = n ? [30, -2, -2] : [0, 32, 2] : o = n ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  var a, c = e[0], l = e[1];
  a = (c >>> 4 ^ l) & 252645135, l ^= a, c ^= a << 4, a = (c >>> 16 ^ l) & 65535, l ^= a, c ^= a << 16, a = (l >>> 2 ^ c) & 858993459, c ^= a, l ^= a << 2, a = (l >>> 8 ^ c) & 16711935, c ^= a, l ^= a << 8, a = (c >>> 1 ^ l) & 1431655765, l ^= a, c ^= a << 1, c = c << 1 | c >>> 31, l = l << 1 | l >>> 31;
  for (var u = 0; u < i; u += 3) {
    for (var f = o[u + 1], d = o[u + 2], p = o[u]; p != f; p += d) {
      var g = l ^ t[p], h = (l >>> 4 | l << 28) ^ t[p + 1];
      a = c, c = l, l = a ^ (spfunction2[g >>> 24 & 63] | spfunction4[g >>> 16 & 63] | spfunction6[g >>> 8 & 63] | spfunction8[g & 63] | spfunction1[h >>> 24 & 63] | spfunction3[h >>> 16 & 63] | spfunction5[h >>> 8 & 63] | spfunction7[h & 63]);
    }
    a = c, c = l, l = a;
  }
  c = c >>> 1 | c << 31, l = l >>> 1 | l << 31, a = (c >>> 1 ^ l) & 1431655765, l ^= a, c ^= a << 1, a = (l >>> 8 ^ c) & 16711935, c ^= a, l ^= a << 8, a = (l >>> 2 ^ c) & 858993459, c ^= a, l ^= a << 2, a = (c >>> 16 ^ l) & 65535, l ^= a, c ^= a << 16, a = (c >>> 4 ^ l) & 252645135, l ^= a, c ^= a << 4, r[0] = c, r[1] = l;
}
function _createCipher(t) {
  t = t || {};
  var e = (t.mode || "CBC").toUpperCase(), r = "DES-" + e, n;
  t.decrypt ? n = forge$f.cipher.createDecipher(r, t.key) : n = forge$f.cipher.createCipher(r, t.key);
  var i = n.start;
  return n.start = function(o, a) {
    var c = null;
    a instanceof forge$f.util.ByteBuffer && (c = a, a = {}), a = a || {}, a.output = c, a.iv = o, i.call(n, a);
  }, n;
}
var forge$e = forge$m;
forge$e.md = forge$e.md || {};
forge$e.md.algorithms = forge$e.md.algorithms || {};
var forge$d = forge$m, hmac$1 = forge$d.hmac = forge$d.hmac || {};
hmac$1.create = function() {
  var t = null, e = null, r = null, n = null, i = {};
  return i.start = function(o, a) {
    if (o !== null)
      if (typeof o == "string")
        if (o = o.toLowerCase(), o in forge$d.md.algorithms)
          e = forge$d.md.algorithms[o].create();
        else
          throw new Error('Unknown hash algorithm "' + o + '"');
      else
        e = o;
    if (a === null)
      a = t;
    else {
      if (typeof a == "string")
        a = forge$d.util.createBuffer(a);
      else if (forge$d.util.isArray(a)) {
        var c = a;
        a = forge$d.util.createBuffer();
        for (var l = 0; l < c.length; ++l)
          a.putByte(c[l]);
      }
      var u = a.length();
      u > e.blockLength && (e.start(), e.update(a.bytes()), a = e.digest()), r = forge$d.util.createBuffer(), n = forge$d.util.createBuffer(), u = a.length();
      for (var l = 0; l < u; ++l) {
        var c = a.at(l);
        r.putByte(54 ^ c), n.putByte(92 ^ c);
      }
      if (u < e.blockLength)
        for (var c = e.blockLength - u, l = 0; l < c; ++l)
          r.putByte(54), n.putByte(92);
      t = a, r = r.bytes(), n = n.bytes();
    }
    e.start(), e.update(r);
  }, i.update = function(o) {
    e.update(o);
  }, i.getMac = function() {
    var o = e.digest().bytes();
    return e.start(), e.update(n), e.update(o), e.digest();
  }, i.digest = i.getMac, i;
};
var forge$c = forge$m, pkcs5 = forge$c.pkcs5 = forge$c.pkcs5 || {}, crypto$2;
forge$c.util.isNodejs && !forge$c.options.usePureJavaScript && (crypto$2 = crypto$3);
var pbkdf2$1 = forge$c.pbkdf2 = pkcs5.pbkdf2 = function(t, e, r, n, i, o) {
  if (typeof i == "function" && (o = i, i = null), forge$c.util.isNodejs && !forge$c.options.usePureJavaScript && crypto$2.pbkdf2 && (i === null || typeof i != "object") && (crypto$2.pbkdf2Sync.length > 4 || !i || i === "sha1"))
    return typeof i != "string" && (i = "sha1"), t = Buffer.from(t, "binary"), e = Buffer.from(e, "binary"), o ? crypto$2.pbkdf2Sync.length === 4 ? crypto$2.pbkdf2(t, e, r, n, function(_, E) {
      if (_)
        return o(_);
      o(null, E.toString("binary"));
    }) : crypto$2.pbkdf2(t, e, r, n, i, function(_, E) {
      if (_)
        return o(_);
      o(null, E.toString("binary"));
    }) : crypto$2.pbkdf2Sync.length === 4 ? crypto$2.pbkdf2Sync(t, e, r, n).toString("binary") : crypto$2.pbkdf2Sync(t, e, r, n, i).toString("binary");
  if ((typeof i > "u" || i === null) && (i = "sha1"), typeof i == "string") {
    if (!(i in forge$c.md.algorithms))
      throw new Error("Unknown hash algorithm: " + i);
    i = forge$c.md[i].create();
  }
  var a = i.digestLength;
  if (n > 4294967295 * a) {
    var c = new Error("Derived key is too long.");
    if (o)
      return o(c);
    throw c;
  }
  var l = Math.ceil(n / a), u = n - (l - 1) * a, f = forge$c.hmac.create();
  f.start(i, t);
  var d = "", p, g, h;
  if (!o) {
    for (var m = 1; m <= l; ++m) {
      f.start(null, null), f.update(e), f.update(forge$c.util.int32ToBytes(m)), p = h = f.digest().getBytes();
      for (var y = 2; y <= r; ++y)
        f.start(null, null), f.update(h), g = f.digest().getBytes(), p = forge$c.util.xorBytes(p, g, a), h = g;
      d += m < l ? p : p.substr(0, u);
    }
    return d;
  }
  var m = 1, y;
  function b() {
    if (m > l)
      return o(null, d);
    f.start(null, null), f.update(e), f.update(forge$c.util.int32ToBytes(m)), p = h = f.digest().getBytes(), y = 2, v();
  }
  function v() {
    if (y <= r)
      return f.start(null, null), f.update(h), g = f.digest().getBytes(), p = forge$c.util.xorBytes(p, g, a), h = g, ++y, forge$c.util.setImmediate(v);
    d += m < l ? p : p.substr(0, u), ++m, b();
  }
  b();
}, forge$b = forge$m, pem = forge$b.pem = forge$b.pem || {};
pem.encode = function(t, e) {
  e = e || {};
  var r = "-----BEGIN " + t.type + `-----\r
`, n;
  if (t.procType && (n = {
    name: "Proc-Type",
    values: [String(t.procType.version), t.procType.type]
  }, r += foldHeader(n)), t.contentDomain && (n = { name: "Content-Domain", values: [t.contentDomain] }, r += foldHeader(n)), t.dekInfo && (n = { name: "DEK-Info", values: [t.dekInfo.algorithm] }, t.dekInfo.parameters && n.values.push(t.dekInfo.parameters), r += foldHeader(n)), t.headers)
    for (var i = 0; i < t.headers.length; ++i)
      r += foldHeader(t.headers[i]);
  return t.procType && (r += `\r
`), r += forge$b.util.encode64(t.body, e.maxline || 64) + `\r
`, r += "-----END " + t.type + `-----\r
`, r;
};
pem.decode = function(t) {
  for (var e = [], r = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, n = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, i = /\r?\n/, o; o = r.exec(t), !!o; ) {
    var a = o[1];
    a === "NEW CERTIFICATE REQUEST" && (a = "CERTIFICATE REQUEST");
    var c = {
      type: a,
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge$b.util.decode64(o[3])
    };
    if (e.push(c), !!o[2]) {
      for (var l = o[2].split(i), u = 0; o && u < l.length; ) {
        for (var f = l[u].replace(/\s+$/, ""), d = u + 1; d < l.length; ++d) {
          var p = l[d];
          if (!/\s/.test(p[0]))
            break;
          f += p, u = d;
        }
        if (o = f.match(n), o) {
          for (var g = { name: o[1], values: [] }, h = o[2].split(","), m = 0; m < h.length; ++m)
            g.values.push(ltrim(h[m]));
          if (c.procType)
            if (!c.contentDomain && g.name === "Content-Domain")
              c.contentDomain = h[0] || "";
            else if (!c.dekInfo && g.name === "DEK-Info") {
              if (g.values.length === 0)
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              c.dekInfo = { algorithm: h[0], parameters: h[1] || null };
            } else
              c.headers.push(g);
          else {
            if (g.name !== "Proc-Type")
              throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
            if (g.values.length !== 2)
              throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
            c.procType = { version: h[0], type: h[1] };
          }
        }
        ++u;
      }
      if (c.procType === "ENCRYPTED" && !c.dekInfo)
        throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (e.length === 0)
    throw new Error("Invalid PEM formatted message.");
  return e;
};
function foldHeader(t) {
  for (var e = t.name + ": ", r = [], n = function(l, u) {
    return " " + u;
  }, i = 0; i < t.values.length; ++i)
    r.push(t.values[i].replace(/^(\S+\r\n)/, n));
  e += r.join(",") + `\r
`;
  for (var o = 0, a = -1, i = 0; i < e.length; ++i, ++o)
    if (o > 65 && a !== -1) {
      var c = e[a];
      c === "," ? (++a, e = e.substr(0, a) + `\r
 ` + e.substr(a)) : e = e.substr(0, a) + `\r
` + c + e.substr(a + 1), o = i - a - 1, a = -1, ++i;
    } else
      (e[i] === " " || e[i] === "	" || e[i] === ",") && (a = i);
  return e;
}
function ltrim(t) {
  return t.replace(/^\s+/, "");
}
var forge$a = forge$m, sha256$3 = forge$a.sha256 = forge$a.sha256 || {};
forge$a.md.sha256 = forge$a.md.algorithms.sha256 = sha256$3;
sha256$3.create = function() {
  _initialized$2 || _init$2();
  var t = null, e = forge$a.util.createBuffer(), r = new Array(64), n = {
    algorithm: "sha256",
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return n.start = function() {
    n.messageLength = 0, n.fullMessageLength = n.messageLength64 = [];
    for (var i = n.messageLengthSize / 4, o = 0; o < i; ++o)
      n.fullMessageLength.push(0);
    return e = forge$a.util.createBuffer(), t = {
      h0: 1779033703,
      h1: 3144134277,
      h2: 1013904242,
      h3: 2773480762,
      h4: 1359893119,
      h5: 2600822924,
      h6: 528734635,
      h7: 1541459225
    }, n;
  }, n.start(), n.update = function(i, o) {
    o === "utf8" && (i = forge$a.util.encodeUtf8(i));
    var a = i.length;
    n.messageLength += a, a = [a / 4294967296 >>> 0, a >>> 0];
    for (var c = n.fullMessageLength.length - 1; c >= 0; --c)
      n.fullMessageLength[c] += a[1], a[1] = a[0] + (n.fullMessageLength[c] / 4294967296 >>> 0), n.fullMessageLength[c] = n.fullMessageLength[c] >>> 0, a[0] = a[1] / 4294967296 >>> 0;
    return e.putBytes(i), _update$2(t, r, e), (e.read > 2048 || e.length() === 0) && e.compact(), n;
  }, n.digest = function() {
    var i = forge$a.util.createBuffer();
    i.putBytes(e.bytes());
    var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize, a = o & n.blockLength - 1;
    i.putBytes(_padding$2.substr(0, n.blockLength - a));
    for (var c, l, u = n.fullMessageLength[0] * 8, f = 0; f < n.fullMessageLength.length - 1; ++f)
      c = n.fullMessageLength[f + 1] * 8, l = c / 4294967296 >>> 0, u += l, i.putInt32(u >>> 0), u = c >>> 0;
    i.putInt32(u);
    var d = {
      h0: t.h0,
      h1: t.h1,
      h2: t.h2,
      h3: t.h3,
      h4: t.h4,
      h5: t.h5,
      h6: t.h6,
      h7: t.h7
    };
    _update$2(d, r, i);
    var p = forge$a.util.createBuffer();
    return p.putInt32(d.h0), p.putInt32(d.h1), p.putInt32(d.h2), p.putInt32(d.h3), p.putInt32(d.h4), p.putInt32(d.h5), p.putInt32(d.h6), p.putInt32(d.h7), p;
  }, n;
};
var _padding$2 = null, _initialized$2 = !1, _k$1 = null;
function _init$2() {
  _padding$2 = String.fromCharCode(128), _padding$2 += forge$a.util.fillString(String.fromCharCode(0), 64), _k$1 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], _initialized$2 = !0;
}
function _update$2(t, e, r) {
  for (var n, i, o, a, c, l, u, f, d, p, g, h, m, y, b, v = r.length(); v >= 64; ) {
    for (u = 0; u < 16; ++u)
      e[u] = r.getInt32();
    for (; u < 64; ++u)
      n = e[u - 2], n = (n >>> 17 | n << 15) ^ (n >>> 19 | n << 13) ^ n >>> 10, i = e[u - 15], i = (i >>> 7 | i << 25) ^ (i >>> 18 | i << 14) ^ i >>> 3, e[u] = n + e[u - 7] + i + e[u - 16] | 0;
    for (f = t.h0, d = t.h1, p = t.h2, g = t.h3, h = t.h4, m = t.h5, y = t.h6, b = t.h7, u = 0; u < 64; ++u)
      a = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7), c = y ^ h & (m ^ y), o = (f >>> 2 | f << 30) ^ (f >>> 13 | f << 19) ^ (f >>> 22 | f << 10), l = f & d | p & (f ^ d), n = b + a + c + _k$1[u] + e[u], i = o + l, b = y, y = m, m = h, h = g + n >>> 0, g = p, p = d, d = f, f = n + i >>> 0;
    t.h0 = t.h0 + f | 0, t.h1 = t.h1 + d | 0, t.h2 = t.h2 + p | 0, t.h3 = t.h3 + g | 0, t.h4 = t.h4 + h | 0, t.h5 = t.h5 + m | 0, t.h6 = t.h6 + y | 0, t.h7 = t.h7 + b | 0, v -= 64;
  }
}
var forge$9 = forge$m, _crypto$1 = null;
forge$9.util.isNodejs && !forge$9.options.usePureJavaScript && !process.versions["node-webkit"] && (_crypto$1 = crypto$3);
var prng = forge$9.prng = forge$9.prng || {};
prng.create = function(t) {
  for (var e = {
    plugin: t,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ""
  }, r = t.md, n = new Array(32), i = 0; i < 32; ++i)
    n[i] = r.create();
  e.pools = n, e.pool = 0, e.generate = function(u, f) {
    if (!f)
      return e.generateSync(u);
    var d = e.plugin.cipher, p = e.plugin.increment, g = e.plugin.formatKey, h = e.plugin.formatSeed, m = forge$9.util.createBuffer();
    e.key = null, y();
    function y(b) {
      if (b)
        return f(b);
      if (m.length() >= u)
        return f(null, m.getBytes(u));
      if (e.generated > 1048575 && (e.key = null), e.key === null)
        return forge$9.util.nextTick(function() {
          o(y);
        });
      var v = d(e.key, e.seed);
      e.generated += v.length, m.putBytes(v), e.key = g(d(e.key, p(e.seed))), e.seed = h(d(e.key, e.seed)), forge$9.util.setImmediate(y);
    }
  }, e.generateSync = function(u) {
    var f = e.plugin.cipher, d = e.plugin.increment, p = e.plugin.formatKey, g = e.plugin.formatSeed;
    e.key = null;
    for (var h = forge$9.util.createBuffer(); h.length() < u; ) {
      e.generated > 1048575 && (e.key = null), e.key === null && a();
      var m = f(e.key, e.seed);
      e.generated += m.length, h.putBytes(m), e.key = p(f(e.key, d(e.seed))), e.seed = g(f(e.key, e.seed));
    }
    return h.getBytes(u);
  };
  function o(u) {
    if (e.pools[0].messageLength >= 32)
      return c(), u();
    var f = 32 - e.pools[0].messageLength << 5;
    e.seedFile(f, function(d, p) {
      if (d)
        return u(d);
      e.collect(p), c(), u();
    });
  }
  function a() {
    if (e.pools[0].messageLength >= 32)
      return c();
    var u = 32 - e.pools[0].messageLength << 5;
    e.collect(e.seedFileSync(u)), c();
  }
  function c() {
    e.reseeds = e.reseeds === 4294967295 ? 0 : e.reseeds + 1;
    var u = e.plugin.md.create();
    u.update(e.keyBytes);
    for (var f = 1, d = 0; d < 32; ++d)
      e.reseeds % f === 0 && (u.update(e.pools[d].digest().getBytes()), e.pools[d].start()), f = f << 1;
    e.keyBytes = u.digest().getBytes(), u.start(), u.update(e.keyBytes);
    var p = u.digest().getBytes();
    e.key = e.plugin.formatKey(e.keyBytes), e.seed = e.plugin.formatSeed(p), e.generated = 0;
  }
  function l(u) {
    var f = null, d = forge$9.util.globalScope, p = d.crypto || d.msCrypto;
    p && p.getRandomValues && (f = function(w) {
      return p.getRandomValues(w);
    });
    var g = forge$9.util.createBuffer();
    if (f)
      for (; g.length() < u; ) {
        var h = Math.max(1, Math.min(u - g.length(), 65536) / 4), m = new Uint32Array(Math.floor(h));
        try {
          f(m);
          for (var y = 0; y < m.length; ++y)
            g.putInt32(m[y]);
        } catch (w) {
          if (!(typeof QuotaExceededError < "u" && w instanceof QuotaExceededError))
            throw w;
        }
      }
    if (g.length() < u)
      for (var b, v, _, E = Math.floor(Math.random() * 65536); g.length() < u; ) {
        v = 16807 * (E & 65535), b = 16807 * (E >> 16), v += (b & 32767) << 16, v += b >> 15, v = (v & 2147483647) + (v >> 31), E = v & 4294967295;
        for (var y = 0; y < 3; ++y)
          _ = E >>> (y << 3), _ ^= Math.floor(Math.random() * 256), g.putByte(_ & 255);
      }
    return g.getBytes(u);
  }
  return _crypto$1 ? (e.seedFile = function(u, f) {
    _crypto$1.randomBytes(u, function(d, p) {
      if (d)
        return f(d);
      f(null, p.toString());
    });
  }, e.seedFileSync = function(u) {
    return _crypto$1.randomBytes(u).toString();
  }) : (e.seedFile = function(u, f) {
    try {
      f(null, l(u));
    } catch (d) {
      f(d);
    }
  }, e.seedFileSync = l), e.collect = function(u) {
    for (var f = u.length, d = 0; d < f; ++d)
      e.pools[e.pool].update(u.substr(d, 1)), e.pool = e.pool === 31 ? 0 : e.pool + 1;
  }, e.collectInt = function(u, f) {
    for (var d = "", p = 0; p < f; p += 8)
      d += String.fromCharCode(u >> p & 255);
    e.collect(d);
  }, e.registerWorker = function(u) {
    if (u === self$1)
      e.seedFile = function(d, p) {
        function g(h) {
          var m = h.data;
          m.forge && m.forge.prng && (self$1.removeEventListener("message", g), p(m.forge.prng.err, m.forge.prng.bytes));
        }
        self$1.addEventListener("message", g), self$1.postMessage({ forge: { prng: { needed: d } } });
      };
    else {
      var f = function(d) {
        var p = d.data;
        p.forge && p.forge.prng && e.seedFile(p.forge.prng.needed, function(g, h) {
          u.postMessage({ forge: { prng: { err: g, bytes: h } } });
        });
      };
      u.addEventListener("message", f);
    }
  }, e;
};
var forge$8 = forge$m;
(function() {
  forge$8.random && forge$8.random.getBytes || function(t) {
    var e = {}, r = new Array(4), n = forge$8.util.createBuffer();
    e.formatKey = function(d) {
      var p = forge$8.util.createBuffer(d);
      return d = new Array(4), d[0] = p.getInt32(), d[1] = p.getInt32(), d[2] = p.getInt32(), d[3] = p.getInt32(), forge$8.aes._expandKey(d, !1);
    }, e.formatSeed = function(d) {
      var p = forge$8.util.createBuffer(d);
      return d = new Array(4), d[0] = p.getInt32(), d[1] = p.getInt32(), d[2] = p.getInt32(), d[3] = p.getInt32(), d;
    }, e.cipher = function(d, p) {
      return forge$8.aes._updateBlock(d, p, r, !1), n.putInt32(r[0]), n.putInt32(r[1]), n.putInt32(r[2]), n.putInt32(r[3]), n.getBytes();
    }, e.increment = function(d) {
      return ++d[3], d;
    }, e.md = forge$8.md.sha256;
    function i() {
      var d = forge$8.prng.create(e);
      return d.getBytes = function(p, g) {
        return d.generate(p, g);
      }, d.getBytesSync = function(p) {
        return d.generate(p);
      }, d;
    }
    var o = i(), a = null, c = forge$8.util.globalScope, l = c.crypto || c.msCrypto;
    if (l && l.getRandomValues && (a = function(d) {
      return l.getRandomValues(d);
    }), !forge$8.util.isNodejs && !a) {
      if (o.collectInt(+new Date(), 32), typeof navigator < "u") {
        var u = "";
        for (var f in navigator)
          try {
            typeof navigator[f] == "string" && (u += navigator[f]);
          } catch {
          }
        o.collect(u), u = null;
      }
      t && (t().mousemove(function(d) {
        o.collectInt(d.clientX, 16), o.collectInt(d.clientY, 16);
      }), t().keypress(function(d) {
        o.collectInt(d.charCode, 8);
      }));
    }
    if (!forge$8.random)
      forge$8.random = o;
    else
      for (var f in o)
        forge$8.random[f] = o[f];
    forge$8.random.createInstance = i;
  }(typeof jQuery < "u" ? jQuery : null);
})();
var forge$7 = forge$m, piTable = [
  217,
  120,
  249,
  196,
  25,
  221,
  181,
  237,
  40,
  233,
  253,
  121,
  74,
  160,
  216,
  157,
  198,
  126,
  55,
  131,
  43,
  118,
  83,
  142,
  98,
  76,
  100,
  136,
  68,
  139,
  251,
  162,
  23,
  154,
  89,
  245,
  135,
  179,
  79,
  19,
  97,
  69,
  109,
  141,
  9,
  129,
  125,
  50,
  189,
  143,
  64,
  235,
  134,
  183,
  123,
  11,
  240,
  149,
  33,
  34,
  92,
  107,
  78,
  130,
  84,
  214,
  101,
  147,
  206,
  96,
  178,
  28,
  115,
  86,
  192,
  20,
  167,
  140,
  241,
  220,
  18,
  117,
  202,
  31,
  59,
  190,
  228,
  209,
  66,
  61,
  212,
  48,
  163,
  60,
  182,
  38,
  111,
  191,
  14,
  218,
  70,
  105,
  7,
  87,
  39,
  242,
  29,
  155,
  188,
  148,
  67,
  3,
  248,
  17,
  199,
  246,
  144,
  239,
  62,
  231,
  6,
  195,
  213,
  47,
  200,
  102,
  30,
  215,
  8,
  232,
  234,
  222,
  128,
  82,
  238,
  247,
  132,
  170,
  114,
  172,
  53,
  77,
  106,
  42,
  150,
  26,
  210,
  113,
  90,
  21,
  73,
  116,
  75,
  159,
  208,
  94,
  4,
  24,
  164,
  236,
  194,
  224,
  65,
  110,
  15,
  81,
  203,
  204,
  36,
  145,
  175,
  80,
  161,
  244,
  112,
  57,
  153,
  124,
  58,
  133,
  35,
  184,
  180,
  122,
  252,
  2,
  54,
  91,
  37,
  85,
  151,
  49,
  45,
  93,
  250,
  152,
  227,
  138,
  146,
  174,
  5,
  223,
  41,
  16,
  103,
  108,
  186,
  201,
  211,
  0,
  230,
  207,
  225,
  158,
  168,
  44,
  99,
  22,
  1,
  63,
  88,
  226,
  137,
  169,
  13,
  56,
  52,
  27,
  171,
  51,
  255,
  176,
  187,
  72,
  12,
  95,
  185,
  177,
  205,
  46,
  197,
  243,
  219,
  71,
  229,
  165,
  156,
  119,
  10,
  166,
  32,
  104,
  254,
  127,
  193,
  173
], s = [1, 2, 3, 5], rol = function(t, e) {
  return t << e & 65535 | (t & 65535) >> 16 - e;
}, ror = function(t, e) {
  return (t & 65535) >> e | t << 16 - e & 65535;
};
forge$7.rc2 = forge$7.rc2 || {};
forge$7.rc2.expandKey = function(t, e) {
  typeof t == "string" && (t = forge$7.util.createBuffer(t)), e = e || 128;
  var r = t, n = t.length(), i = e, o = Math.ceil(i / 8), a = 255 >> (i & 7), c;
  for (c = n; c < 128; c++)
    r.putByte(piTable[r.at(c - 1) + r.at(c - n) & 255]);
  for (r.setAt(128 - o, piTable[r.at(128 - o) & a]), c = 127 - o; c >= 0; c--)
    r.setAt(c, piTable[r.at(c + 1) ^ r.at(c + o)]);
  return r;
};
var createCipher = function(t, e, r) {
  var n = !1, i = null, o = null, a = null, c, l, u, f, d = [];
  for (t = forge$7.rc2.expandKey(t, e), u = 0; u < 64; u++)
    d.push(t.getInt16Le());
  r ? (c = function(h) {
    for (u = 0; u < 4; u++)
      h[u] += d[f] + (h[(u + 3) % 4] & h[(u + 2) % 4]) + (~h[(u + 3) % 4] & h[(u + 1) % 4]), h[u] = rol(h[u], s[u]), f++;
  }, l = function(h) {
    for (u = 0; u < 4; u++)
      h[u] += d[h[(u + 3) % 4] & 63];
  }) : (c = function(h) {
    for (u = 3; u >= 0; u--)
      h[u] = ror(h[u], s[u]), h[u] -= d[f] + (h[(u + 3) % 4] & h[(u + 2) % 4]) + (~h[(u + 3) % 4] & h[(u + 1) % 4]), f--;
  }, l = function(h) {
    for (u = 3; u >= 0; u--)
      h[u] -= d[h[(u + 3) % 4] & 63];
  });
  var p = function(h) {
    var m = [];
    for (u = 0; u < 4; u++) {
      var y = i.getInt16Le();
      a !== null && (r ? y ^= a.getInt16Le() : a.putInt16Le(y)), m.push(y & 65535);
    }
    f = r ? 0 : 63;
    for (var b = 0; b < h.length; b++)
      for (var v = 0; v < h[b][0]; v++)
        h[b][1](m);
    for (u = 0; u < 4; u++)
      a !== null && (r ? a.putInt16Le(m[u]) : m[u] ^= a.getInt16Le()), o.putInt16Le(m[u]);
  }, g = null;
  return g = {
    /**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */
    start: function(h, m) {
      h && typeof h == "string" && (h = forge$7.util.createBuffer(h)), n = !1, i = forge$7.util.createBuffer(), o = m || new forge$7.util.createBuffer(), a = h, g.output = o;
    },
    /**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */
    update: function(h) {
      for (n || i.putBuffer(h); i.length() >= 8; )
        p([
          [5, c],
          [1, l],
          [6, c],
          [1, l],
          [5, c]
        ]);
    },
    /**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */
    finish: function(h) {
      var m = !0;
      if (r)
        if (h)
          m = h(8, i, !r);
        else {
          var y = i.length() === 8 ? 8 : 8 - i.length();
          i.fillWithByte(y, y);
        }
      if (m && (n = !0, g.update()), !r && (m = i.length() === 0, m))
        if (h)
          m = h(8, o, !r);
        else {
          var b = o.length(), v = o.at(b - 1);
          v > b ? m = !1 : o.truncate(v);
        }
      return m;
    }
  }, g;
};
forge$7.rc2.startEncrypting = function(t, e, r) {
  var n = forge$7.rc2.createEncryptionCipher(t, 128);
  return n.start(e, r), n;
};
forge$7.rc2.createEncryptionCipher = function(t, e) {
  return createCipher(t, e, !0);
};
forge$7.rc2.startDecrypting = function(t, e, r) {
  var n = forge$7.rc2.createDecryptionCipher(t, 128);
  return n.start(e, r), n;
};
forge$7.rc2.createDecryptionCipher = function(t, e) {
  return createCipher(t, e, !1);
};
var forge$6 = forge$m;
forge$6.jsbn = forge$6.jsbn || {};
var dbits;
function BigInteger$2(t, e, r) {
  this.data = [], t != null && (typeof t == "number" ? this.fromNumber(t, e, r) : e == null && typeof t != "string" ? this.fromString(t, 256) : this.fromString(t, e));
}
forge$6.jsbn.BigInteger = BigInteger$2;
function nbi() {
  return new BigInteger$2(null);
}
function am1(t, e, r, n, i, o) {
  for (; --o >= 0; ) {
    var a = e * this.data[t++] + r.data[n] + i;
    i = Math.floor(a / 67108864), r.data[n++] = a & 67108863;
  }
  return i;
}
function am2(t, e, r, n, i, o) {
  for (var a = e & 32767, c = e >> 15; --o >= 0; ) {
    var l = this.data[t] & 32767, u = this.data[t++] >> 15, f = c * l + u * a;
    l = a * l + ((f & 32767) << 15) + r.data[n] + (i & 1073741823), i = (l >>> 30) + (f >>> 15) + c * u + (i >>> 30), r.data[n++] = l & 1073741823;
  }
  return i;
}
function am3(t, e, r, n, i, o) {
  for (var a = e & 16383, c = e >> 14; --o >= 0; ) {
    var l = this.data[t] & 16383, u = this.data[t++] >> 14, f = c * l + u * a;
    l = a * l + ((f & 16383) << 14) + r.data[n] + i, i = (l >> 28) + (f >> 14) + c * u, r.data[n++] = l & 268435455;
  }
  return i;
}
typeof navigator > "u" ? (BigInteger$2.prototype.am = am3, dbits = 28) : navigator.appName == "Microsoft Internet Explorer" ? (BigInteger$2.prototype.am = am2, dbits = 30) : navigator.appName != "Netscape" ? (BigInteger$2.prototype.am = am1, dbits = 26) : (BigInteger$2.prototype.am = am3, dbits = 28);
BigInteger$2.prototype.DB = dbits;
BigInteger$2.prototype.DM = (1 << dbits) - 1;
BigInteger$2.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger$2.prototype.FV = Math.pow(2, BI_FP);
BigInteger$2.prototype.F1 = BI_FP - dbits;
BigInteger$2.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz", BI_RC = new Array(), rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv)
  BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
function int2char(t) {
  return BI_RM.charAt(t);
}
function intAt(t, e) {
  var r = BI_RC[t.charCodeAt(e)];
  return r ?? -1;
}
function bnpCopyTo(t) {
  for (var e = this.t - 1; e >= 0; --e)
    t.data[e] = this.data[e];
  t.t = this.t, t.s = this.s;
}
function bnpFromInt(t) {
  this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this.data[0] = t : t < -1 ? this.data[0] = t + this.DV : this.t = 0;
}
function nbv(t) {
  var e = nbi();
  return e.fromInt(t), e;
}
function bnpFromString(t, e) {
  var r;
  if (e == 16)
    r = 4;
  else if (e == 8)
    r = 3;
  else if (e == 256)
    r = 8;
  else if (e == 2)
    r = 1;
  else if (e == 32)
    r = 5;
  else if (e == 4)
    r = 2;
  else {
    this.fromRadix(t, e);
    return;
  }
  this.t = 0, this.s = 0;
  for (var n = t.length, i = !1, o = 0; --n >= 0; ) {
    var a = r == 8 ? t[n] & 255 : intAt(t, n);
    if (a < 0) {
      t.charAt(n) == "-" && (i = !0);
      continue;
    }
    i = !1, o == 0 ? this.data[this.t++] = a : o + r > this.DB ? (this.data[this.t - 1] |= (a & (1 << this.DB - o) - 1) << o, this.data[this.t++] = a >> this.DB - o) : this.data[this.t - 1] |= a << o, o += r, o >= this.DB && (o -= this.DB);
  }
  r == 8 && t[0] & 128 && (this.s = -1, o > 0 && (this.data[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), i && BigInteger$2.ZERO.subTo(this, this);
}
function bnpClamp() {
  for (var t = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == t; )
    --this.t;
}
function bnToString(t) {
  if (this.s < 0)
    return "-" + this.negate().toString(t);
  var e;
  if (t == 16)
    e = 4;
  else if (t == 8)
    e = 3;
  else if (t == 2)
    e = 1;
  else if (t == 32)
    e = 5;
  else if (t == 4)
    e = 2;
  else
    return this.toRadix(t);
  var r = (1 << e) - 1, n, i = !1, o = "", a = this.t, c = this.DB - a * this.DB % e;
  if (a-- > 0)
    for (c < this.DB && (n = this.data[a] >> c) > 0 && (i = !0, o = int2char(n)); a >= 0; )
      c < e ? (n = (this.data[a] & (1 << c) - 1) << e - c, n |= this.data[--a] >> (c += this.DB - e)) : (n = this.data[a] >> (c -= e) & r, c <= 0 && (c += this.DB, --a)), n > 0 && (i = !0), i && (o += int2char(n));
  return i ? o : "0";
}
function bnNegate() {
  var t = nbi();
  return BigInteger$2.ZERO.subTo(this, t), t;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(t) {
  var e = this.s - t.s;
  if (e != 0)
    return e;
  var r = this.t;
  if (e = r - t.t, e != 0)
    return this.s < 0 ? -e : e;
  for (; --r >= 0; )
    if ((e = this.data[r] - t.data[r]) != 0)
      return e;
  return 0;
}
function nbits(t) {
  var e = 1, r;
  return (r = t >>> 16) != 0 && (t = r, e += 16), (r = t >> 8) != 0 && (t = r, e += 8), (r = t >> 4) != 0 && (t = r, e += 4), (r = t >> 2) != 0 && (t = r, e += 2), (r = t >> 1) != 0 && (t = r, e += 1), e;
}
function bnBitLength() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(t, e) {
  var r;
  for (r = this.t - 1; r >= 0; --r)
    e.data[r + t] = this.data[r];
  for (r = t - 1; r >= 0; --r)
    e.data[r] = 0;
  e.t = this.t + t, e.s = this.s;
}
function bnpDRShiftTo(t, e) {
  for (var r = t; r < this.t; ++r)
    e.data[r - t] = this.data[r];
  e.t = Math.max(this.t - t, 0), e.s = this.s;
}
function bnpLShiftTo(t, e) {
  var r = t % this.DB, n = this.DB - r, i = (1 << n) - 1, o = Math.floor(t / this.DB), a = this.s << r & this.DM, c;
  for (c = this.t - 1; c >= 0; --c)
    e.data[c + o + 1] = this.data[c] >> n | a, a = (this.data[c] & i) << r;
  for (c = o - 1; c >= 0; --c)
    e.data[c] = 0;
  e.data[o] = a, e.t = this.t + o + 1, e.s = this.s, e.clamp();
}
function bnpRShiftTo(t, e) {
  e.s = this.s;
  var r = Math.floor(t / this.DB);
  if (r >= this.t) {
    e.t = 0;
    return;
  }
  var n = t % this.DB, i = this.DB - n, o = (1 << n) - 1;
  e.data[0] = this.data[r] >> n;
  for (var a = r + 1; a < this.t; ++a)
    e.data[a - r - 1] |= (this.data[a] & o) << i, e.data[a - r] = this.data[a] >> n;
  n > 0 && (e.data[this.t - r - 1] |= (this.s & o) << i), e.t = this.t - r, e.clamp();
}
function bnpSubTo(t, e) {
  for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i; )
    n += this.data[r] - t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
  if (t.t < this.t) {
    for (n -= t.s; r < this.t; )
      n += this.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
    n += this.s;
  } else {
    for (n += this.s; r < t.t; )
      n -= t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
    n -= t.s;
  }
  e.s = n < 0 ? -1 : 0, n < -1 ? e.data[r++] = this.DV + n : n > 0 && (e.data[r++] = n), e.t = r, e.clamp();
}
function bnpMultiplyTo(t, e) {
  var r = this.abs(), n = t.abs(), i = r.t;
  for (e.t = i + n.t; --i >= 0; )
    e.data[i] = 0;
  for (i = 0; i < n.t; ++i)
    e.data[i + r.t] = r.am(0, n.data[i], e, i, 0, r.t);
  e.s = 0, e.clamp(), this.s != t.s && BigInteger$2.ZERO.subTo(e, e);
}
function bnpSquareTo(t) {
  for (var e = this.abs(), r = t.t = 2 * e.t; --r >= 0; )
    t.data[r] = 0;
  for (r = 0; r < e.t - 1; ++r) {
    var n = e.am(r, e.data[r], t, 2 * r, 0, 1);
    (t.data[r + e.t] += e.am(r + 1, 2 * e.data[r], t, 2 * r + 1, n, e.t - r - 1)) >= e.DV && (t.data[r + e.t] -= e.DV, t.data[r + e.t + 1] = 1);
  }
  t.t > 0 && (t.data[t.t - 1] += e.am(r, e.data[r], t, 2 * r, 0, 1)), t.s = 0, t.clamp();
}
function bnpDivRemTo(t, e, r) {
  var n = t.abs();
  if (!(n.t <= 0)) {
    var i = this.abs();
    if (i.t < n.t) {
      e != null && e.fromInt(0), r != null && this.copyTo(r);
      return;
    }
    r == null && (r = nbi());
    var o = nbi(), a = this.s, c = t.s, l = this.DB - nbits(n.data[n.t - 1]);
    l > 0 ? (n.lShiftTo(l, o), i.lShiftTo(l, r)) : (n.copyTo(o), i.copyTo(r));
    var u = o.t, f = o.data[u - 1];
    if (f != 0) {
      var d = f * (1 << this.F1) + (u > 1 ? o.data[u - 2] >> this.F2 : 0), p = this.FV / d, g = (1 << this.F1) / d, h = 1 << this.F2, m = r.t, y = m - u, b = e ?? nbi();
      for (o.dlShiftTo(y, b), r.compareTo(b) >= 0 && (r.data[r.t++] = 1, r.subTo(b, r)), BigInteger$2.ONE.dlShiftTo(u, b), b.subTo(o, o); o.t < u; )
        o.data[o.t++] = 0;
      for (; --y >= 0; ) {
        var v = r.data[--m] == f ? this.DM : Math.floor(r.data[m] * p + (r.data[m - 1] + h) * g);
        if ((r.data[m] += o.am(0, v, r, y, 0, u)) < v)
          for (o.dlShiftTo(y, b), r.subTo(b, r); r.data[m] < --v; )
            r.subTo(b, r);
      }
      e != null && (r.drShiftTo(u, e), a != c && BigInteger$2.ZERO.subTo(e, e)), r.t = u, r.clamp(), l > 0 && r.rShiftTo(l, r), a < 0 && BigInteger$2.ZERO.subTo(r, r);
    }
  }
}
function bnMod(t) {
  var e = nbi();
  return this.abs().divRemTo(t, null, e), this.s < 0 && e.compareTo(BigInteger$2.ZERO) > 0 && t.subTo(e, e), e;
}
function Classic(t) {
  this.m = t;
}
function cConvert(t) {
  return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t;
}
function cRevert(t) {
  return t;
}
function cReduce(t) {
  t.divRemTo(this.m, null, t);
}
function cMulTo(t, e, r) {
  t.multiplyTo(e, r), this.reduce(r);
}
function cSqrTo(t, e) {
  t.squareTo(e), this.reduce(e);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
  if (this.t < 1)
    return 0;
  var t = this.data[0];
  if (!(t & 1))
    return 0;
  var e = t & 3;
  return e = e * (2 - (t & 15) * e) & 15, e = e * (2 - (t & 255) * e) & 255, e = e * (2 - ((t & 65535) * e & 65535)) & 65535, e = e * (2 - t * e % this.DV) % this.DV, e > 0 ? this.DV - e : -e;
}
function Montgomery(t) {
  this.m = t, this.mp = t.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t;
}
function montConvert(t) {
  var e = nbi();
  return t.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t.s < 0 && e.compareTo(BigInteger$2.ZERO) > 0 && this.m.subTo(e, e), e;
}
function montRevert(t) {
  var e = nbi();
  return t.copyTo(e), this.reduce(e), e;
}
function montReduce(t) {
  for (; t.t <= this.mt2; )
    t.data[t.t++] = 0;
  for (var e = 0; e < this.m.t; ++e) {
    var r = t.data[e] & 32767, n = r * this.mpl + ((r * this.mph + (t.data[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
    for (r = e + this.m.t, t.data[r] += this.m.am(0, n, t, e, 0, this.m.t); t.data[r] >= t.DV; )
      t.data[r] -= t.DV, t.data[++r]++;
  }
  t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t);
}
function montSqrTo(t, e) {
  t.squareTo(e), this.reduce(e);
}
function montMulTo(t, e, r) {
  t.multiplyTo(e, r), this.reduce(r);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function bnpExp(t, e) {
  if (t > 4294967295 || t < 1)
    return BigInteger$2.ONE;
  var r = nbi(), n = nbi(), i = e.convert(this), o = nbits(t) - 1;
  for (i.copyTo(r); --o >= 0; )
    if (e.sqrTo(r, n), (t & 1 << o) > 0)
      e.mulTo(n, i, r);
    else {
      var a = r;
      r = n, n = a;
    }
  return e.revert(r);
}
function bnModPowInt(t, e) {
  var r;
  return t < 256 || e.isEven() ? r = new Classic(e) : r = new Montgomery(e), this.exp(t, r);
}
BigInteger$2.prototype.copyTo = bnpCopyTo;
BigInteger$2.prototype.fromInt = bnpFromInt;
BigInteger$2.prototype.fromString = bnpFromString;
BigInteger$2.prototype.clamp = bnpClamp;
BigInteger$2.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger$2.prototype.drShiftTo = bnpDRShiftTo;
BigInteger$2.prototype.lShiftTo = bnpLShiftTo;
BigInteger$2.prototype.rShiftTo = bnpRShiftTo;
BigInteger$2.prototype.subTo = bnpSubTo;
BigInteger$2.prototype.multiplyTo = bnpMultiplyTo;
BigInteger$2.prototype.squareTo = bnpSquareTo;
BigInteger$2.prototype.divRemTo = bnpDivRemTo;
BigInteger$2.prototype.invDigit = bnpInvDigit;
BigInteger$2.prototype.isEven = bnpIsEven;
BigInteger$2.prototype.exp = bnpExp;
BigInteger$2.prototype.toString = bnToString;
BigInteger$2.prototype.negate = bnNegate;
BigInteger$2.prototype.abs = bnAbs;
BigInteger$2.prototype.compareTo = bnCompareTo;
BigInteger$2.prototype.bitLength = bnBitLength;
BigInteger$2.prototype.mod = bnMod;
BigInteger$2.prototype.modPowInt = bnModPowInt;
BigInteger$2.ZERO = nbv(0);
BigInteger$2.ONE = nbv(1);
function bnClone() {
  var t = nbi();
  return this.copyTo(t), t;
}
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1)
      return this.data[0] - this.DV;
    if (this.t == 0)
      return -1;
  } else {
    if (this.t == 1)
      return this.data[0];
    if (this.t == 0)
      return 0;
  }
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function bnByteValue() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function bnShortValue() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function bnpChunkSize(t) {
  return Math.floor(Math.LN2 * this.DB / Math.log(t));
}
function bnSigNum() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
}
function bnpToRadix(t) {
  if (t == null && (t = 10), this.signum() == 0 || t < 2 || t > 36)
    return "0";
  var e = this.chunkSize(t), r = Math.pow(t, e), n = nbv(r), i = nbi(), o = nbi(), a = "";
  for (this.divRemTo(n, i, o); i.signum() > 0; )
    a = (r + o.intValue()).toString(t).substr(1) + a, i.divRemTo(n, i, o);
  return o.intValue().toString(t) + a;
}
function bnpFromRadix(t, e) {
  this.fromInt(0), e == null && (e = 10);
  for (var r = this.chunkSize(e), n = Math.pow(e, r), i = !1, o = 0, a = 0, c = 0; c < t.length; ++c) {
    var l = intAt(t, c);
    if (l < 0) {
      t.charAt(c) == "-" && this.signum() == 0 && (i = !0);
      continue;
    }
    a = e * a + l, ++o >= r && (this.dMultiply(n), this.dAddOffset(a, 0), o = 0, a = 0);
  }
  o > 0 && (this.dMultiply(Math.pow(e, o)), this.dAddOffset(a, 0)), i && BigInteger$2.ZERO.subTo(this, this);
}
function bnpFromNumber(t, e, r) {
  if (typeof e == "number")
    if (t < 2)
      this.fromInt(1);
    else
      for (this.fromNumber(t, r), this.testBit(t - 1) || this.bitwiseTo(BigInteger$2.ONE.shiftLeft(t - 1), op_or, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e); )
        this.dAddOffset(2, 0), this.bitLength() > t && this.subTo(BigInteger$2.ONE.shiftLeft(t - 1), this);
  else {
    var n = new Array(), i = t & 7;
    n.length = (t >> 3) + 1, e.nextBytes(n), i > 0 ? n[0] &= (1 << i) - 1 : n[0] = 0, this.fromString(n, 256);
  }
}
function bnToByteArray() {
  var t = this.t, e = new Array();
  e[0] = this.s;
  var r = this.DB - t * this.DB % 8, n, i = 0;
  if (t-- > 0)
    for (r < this.DB && (n = this.data[t] >> r) != (this.s & this.DM) >> r && (e[i++] = n | this.s << this.DB - r); t >= 0; )
      r < 8 ? (n = (this.data[t] & (1 << r) - 1) << 8 - r, n |= this.data[--t] >> (r += this.DB - 8)) : (n = this.data[t] >> (r -= 8) & 255, r <= 0 && (r += this.DB, --t)), n & 128 && (n |= -256), i == 0 && (this.s & 128) != (n & 128) && ++i, (i > 0 || n != this.s) && (e[i++] = n);
  return e;
}
function bnEquals(t) {
  return this.compareTo(t) == 0;
}
function bnMin(t) {
  return this.compareTo(t) < 0 ? this : t;
}
function bnMax(t) {
  return this.compareTo(t) > 0 ? this : t;
}
function bnpBitwiseTo(t, e, r) {
  var n, i, o = Math.min(t.t, this.t);
  for (n = 0; n < o; ++n)
    r.data[n] = e(this.data[n], t.data[n]);
  if (t.t < this.t) {
    for (i = t.s & this.DM, n = o; n < this.t; ++n)
      r.data[n] = e(this.data[n], i);
    r.t = this.t;
  } else {
    for (i = this.s & this.DM, n = o; n < t.t; ++n)
      r.data[n] = e(i, t.data[n]);
    r.t = t.t;
  }
  r.s = e(this.s, t.s), r.clamp();
}
function op_and(t, e) {
  return t & e;
}
function bnAnd(t) {
  var e = nbi();
  return this.bitwiseTo(t, op_and, e), e;
}
function op_or(t, e) {
  return t | e;
}
function bnOr(t) {
  var e = nbi();
  return this.bitwiseTo(t, op_or, e), e;
}
function op_xor(t, e) {
  return t ^ e;
}
function bnXor(t) {
  var e = nbi();
  return this.bitwiseTo(t, op_xor, e), e;
}
function op_andnot(t, e) {
  return t & ~e;
}
function bnAndNot(t) {
  var e = nbi();
  return this.bitwiseTo(t, op_andnot, e), e;
}
function bnNot() {
  for (var t = nbi(), e = 0; e < this.t; ++e)
    t.data[e] = this.DM & ~this.data[e];
  return t.t = this.t, t.s = ~this.s, t;
}
function bnShiftLeft(t) {
  var e = nbi();
  return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e;
}
function bnShiftRight(t) {
  var e = nbi();
  return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e;
}
function lbit(t) {
  if (t == 0)
    return -1;
  var e = 0;
  return t & 65535 || (t >>= 16, e += 16), t & 255 || (t >>= 8, e += 8), t & 15 || (t >>= 4, e += 4), t & 3 || (t >>= 2, e += 2), t & 1 || ++e, e;
}
function bnGetLowestSetBit() {
  for (var t = 0; t < this.t; ++t)
    if (this.data[t] != 0)
      return t * this.DB + lbit(this.data[t]);
  return this.s < 0 ? this.t * this.DB : -1;
}
function cbit(t) {
  for (var e = 0; t != 0; )
    t &= t - 1, ++e;
  return e;
}
function bnBitCount() {
  for (var t = 0, e = this.s & this.DM, r = 0; r < this.t; ++r)
    t += cbit(this.data[r] ^ e);
  return t;
}
function bnTestBit(t) {
  var e = Math.floor(t / this.DB);
  return e >= this.t ? this.s != 0 : (this.data[e] & 1 << t % this.DB) != 0;
}
function bnpChangeBit(t, e) {
  var r = BigInteger$2.ONE.shiftLeft(t);
  return this.bitwiseTo(r, e, r), r;
}
function bnSetBit(t) {
  return this.changeBit(t, op_or);
}
function bnClearBit(t) {
  return this.changeBit(t, op_andnot);
}
function bnFlipBit(t) {
  return this.changeBit(t, op_xor);
}
function bnpAddTo(t, e) {
  for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i; )
    n += this.data[r] + t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
  if (t.t < this.t) {
    for (n += t.s; r < this.t; )
      n += this.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
    n += this.s;
  } else {
    for (n += this.s; r < t.t; )
      n += t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
    n += t.s;
  }
  e.s = n < 0 ? -1 : 0, n > 0 ? e.data[r++] = n : n < -1 && (e.data[r++] = this.DV + n), e.t = r, e.clamp();
}
function bnAdd(t) {
  var e = nbi();
  return this.addTo(t, e), e;
}
function bnSubtract(t) {
  var e = nbi();
  return this.subTo(t, e), e;
}
function bnMultiply(t) {
  var e = nbi();
  return this.multiplyTo(t, e), e;
}
function bnDivide(t) {
  var e = nbi();
  return this.divRemTo(t, e, null), e;
}
function bnRemainder(t) {
  var e = nbi();
  return this.divRemTo(t, null, e), e;
}
function bnDivideAndRemainder(t) {
  var e = nbi(), r = nbi();
  return this.divRemTo(t, e, r), new Array(e, r);
}
function bnpDMultiply(t) {
  this.data[this.t] = this.am(0, t - 1, this, 0, 0, this.t), ++this.t, this.clamp();
}
function bnpDAddOffset(t, e) {
  if (t != 0) {
    for (; this.t <= e; )
      this.data[this.t++] = 0;
    for (this.data[e] += t; this.data[e] >= this.DV; )
      this.data[e] -= this.DV, ++e >= this.t && (this.data[this.t++] = 0), ++this.data[e];
  }
}
function NullExp() {
}
function nNop(t) {
  return t;
}
function nMulTo(t, e, r) {
  t.multiplyTo(e, r);
}
function nSqrTo(t, e) {
  t.squareTo(e);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(t) {
  return this.exp(t, new NullExp());
}
function bnpMultiplyLowerTo(t, e, r) {
  var n = Math.min(this.t + t.t, e);
  for (r.s = 0, r.t = n; n > 0; )
    r.data[--n] = 0;
  var i;
  for (i = r.t - this.t; n < i; ++n)
    r.data[n + this.t] = this.am(0, t.data[n], r, n, 0, this.t);
  for (i = Math.min(t.t, e); n < i; ++n)
    this.am(0, t.data[n], r, n, 0, e - n);
  r.clamp();
}
function bnpMultiplyUpperTo(t, e, r) {
  --e;
  var n = r.t = this.t + t.t - e;
  for (r.s = 0; --n >= 0; )
    r.data[n] = 0;
  for (n = Math.max(e - this.t, 0); n < t.t; ++n)
    r.data[this.t + n - e] = this.am(e - n, t.data[n], r, 0, 0, this.t + n - e);
  r.clamp(), r.drShiftTo(1, r);
}
function Barrett(t) {
  this.r2 = nbi(), this.q3 = nbi(), BigInteger$2.ONE.dlShiftTo(2 * t.t, this.r2), this.mu = this.r2.divide(t), this.m = t;
}
function barrettConvert(t) {
  if (t.s < 0 || t.t > 2 * this.m.t)
    return t.mod(this.m);
  if (t.compareTo(this.m) < 0)
    return t;
  var e = nbi();
  return t.copyTo(e), this.reduce(e), e;
}
function barrettRevert(t) {
  return t;
}
function barrettReduce(t) {
  for (t.drShiftTo(this.m.t - 1, this.r2), t.t > this.m.t + 1 && (t.t = this.m.t + 1, t.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0; )
    t.dAddOffset(1, this.m.t + 1);
  for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0; )
    t.subTo(this.m, t);
}
function barrettSqrTo(t, e) {
  t.squareTo(e), this.reduce(e);
}
function barrettMulTo(t, e, r) {
  t.multiplyTo(e, r), this.reduce(r);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(t, e) {
  var r = t.bitLength(), n, i = nbv(1), o;
  if (r <= 0)
    return i;
  r < 18 ? n = 1 : r < 48 ? n = 3 : r < 144 ? n = 4 : r < 768 ? n = 5 : n = 6, r < 8 ? o = new Classic(e) : e.isEven() ? o = new Barrett(e) : o = new Montgomery(e);
  var a = new Array(), c = 3, l = n - 1, u = (1 << n) - 1;
  if (a[1] = o.convert(this), n > 1) {
    var f = nbi();
    for (o.sqrTo(a[1], f); c <= u; )
      a[c] = nbi(), o.mulTo(f, a[c - 2], a[c]), c += 2;
  }
  var d = t.t - 1, p, g = !0, h = nbi(), m;
  for (r = nbits(t.data[d]) - 1; d >= 0; ) {
    for (r >= l ? p = t.data[d] >> r - l & u : (p = (t.data[d] & (1 << r + 1) - 1) << l - r, d > 0 && (p |= t.data[d - 1] >> this.DB + r - l)), c = n; !(p & 1); )
      p >>= 1, --c;
    if ((r -= c) < 0 && (r += this.DB, --d), g)
      a[p].copyTo(i), g = !1;
    else {
      for (; c > 1; )
        o.sqrTo(i, h), o.sqrTo(h, i), c -= 2;
      c > 0 ? o.sqrTo(i, h) : (m = i, i = h, h = m), o.mulTo(h, a[p], i);
    }
    for (; d >= 0 && !(t.data[d] & 1 << r); )
      o.sqrTo(i, h), m = i, i = h, h = m, --r < 0 && (r = this.DB - 1, --d);
  }
  return o.revert(i);
}
function bnGCD(t) {
  var e = this.s < 0 ? this.negate() : this.clone(), r = t.s < 0 ? t.negate() : t.clone();
  if (e.compareTo(r) < 0) {
    var n = e;
    e = r, r = n;
  }
  var i = e.getLowestSetBit(), o = r.getLowestSetBit();
  if (o < 0)
    return e;
  for (i < o && (o = i), o > 0 && (e.rShiftTo(o, e), r.rShiftTo(o, r)); e.signum() > 0; )
    (i = e.getLowestSetBit()) > 0 && e.rShiftTo(i, e), (i = r.getLowestSetBit()) > 0 && r.rShiftTo(i, r), e.compareTo(r) >= 0 ? (e.subTo(r, e), e.rShiftTo(1, e)) : (r.subTo(e, r), r.rShiftTo(1, r));
  return o > 0 && r.lShiftTo(o, r), r;
}
function bnpModInt(t) {
  if (t <= 0)
    return 0;
  var e = this.DV % t, r = this.s < 0 ? t - 1 : 0;
  if (this.t > 0)
    if (e == 0)
      r = this.data[0] % t;
    else
      for (var n = this.t - 1; n >= 0; --n)
        r = (e * r + this.data[n]) % t;
  return r;
}
function bnModInverse(t) {
  var e = t.isEven();
  if (this.isEven() && e || t.signum() == 0)
    return BigInteger$2.ZERO;
  for (var r = t.clone(), n = this.clone(), i = nbv(1), o = nbv(0), a = nbv(0), c = nbv(1); r.signum() != 0; ) {
    for (; r.isEven(); )
      r.rShiftTo(1, r), e ? ((!i.isEven() || !o.isEven()) && (i.addTo(this, i), o.subTo(t, o)), i.rShiftTo(1, i)) : o.isEven() || o.subTo(t, o), o.rShiftTo(1, o);
    for (; n.isEven(); )
      n.rShiftTo(1, n), e ? ((!a.isEven() || !c.isEven()) && (a.addTo(this, a), c.subTo(t, c)), a.rShiftTo(1, a)) : c.isEven() || c.subTo(t, c), c.rShiftTo(1, c);
    r.compareTo(n) >= 0 ? (r.subTo(n, r), e && i.subTo(a, i), o.subTo(c, o)) : (n.subTo(r, n), e && a.subTo(i, a), c.subTo(o, c));
  }
  if (n.compareTo(BigInteger$2.ONE) != 0)
    return BigInteger$2.ZERO;
  if (c.compareTo(t) >= 0)
    return c.subtract(t);
  if (c.signum() < 0)
    c.addTo(t, c);
  else
    return c;
  return c.signum() < 0 ? c.add(t) : c;
}
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509], lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(t) {
  var e, r = this.abs();
  if (r.t == 1 && r.data[0] <= lowprimes[lowprimes.length - 1]) {
    for (e = 0; e < lowprimes.length; ++e)
      if (r.data[0] == lowprimes[e])
        return !0;
    return !1;
  }
  if (r.isEven())
    return !1;
  for (e = 1; e < lowprimes.length; ) {
    for (var n = lowprimes[e], i = e + 1; i < lowprimes.length && n < lplim; )
      n *= lowprimes[i++];
    for (n = r.modInt(n); e < i; )
      if (n % lowprimes[e++] == 0)
        return !1;
  }
  return r.millerRabin(t);
}
function bnpMillerRabin(t) {
  var e = this.subtract(BigInteger$2.ONE), r = e.getLowestSetBit();
  if (r <= 0)
    return !1;
  for (var n = e.shiftRight(r), i = bnGetPrng(), o, a = 0; a < t; ++a) {
    do
      o = new BigInteger$2(this.bitLength(), i);
    while (o.compareTo(BigInteger$2.ONE) <= 0 || o.compareTo(e) >= 0);
    var c = o.modPow(n, this);
    if (c.compareTo(BigInteger$2.ONE) != 0 && c.compareTo(e) != 0) {
      for (var l = 1; l++ < r && c.compareTo(e) != 0; )
        if (c = c.modPowInt(2, this), c.compareTo(BigInteger$2.ONE) == 0)
          return !1;
      if (c.compareTo(e) != 0)
        return !1;
    }
  }
  return !0;
}
function bnGetPrng() {
  return {
    // x is an array to fill with bytes
    nextBytes: function(t) {
      for (var e = 0; e < t.length; ++e)
        t[e] = Math.floor(Math.random() * 256);
    }
  };
}
BigInteger$2.prototype.chunkSize = bnpChunkSize;
BigInteger$2.prototype.toRadix = bnpToRadix;
BigInteger$2.prototype.fromRadix = bnpFromRadix;
BigInteger$2.prototype.fromNumber = bnpFromNumber;
BigInteger$2.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger$2.prototype.changeBit = bnpChangeBit;
BigInteger$2.prototype.addTo = bnpAddTo;
BigInteger$2.prototype.dMultiply = bnpDMultiply;
BigInteger$2.prototype.dAddOffset = bnpDAddOffset;
BigInteger$2.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger$2.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger$2.prototype.modInt = bnpModInt;
BigInteger$2.prototype.millerRabin = bnpMillerRabin;
BigInteger$2.prototype.clone = bnClone;
BigInteger$2.prototype.intValue = bnIntValue;
BigInteger$2.prototype.byteValue = bnByteValue;
BigInteger$2.prototype.shortValue = bnShortValue;
BigInteger$2.prototype.signum = bnSigNum;
BigInteger$2.prototype.toByteArray = bnToByteArray;
BigInteger$2.prototype.equals = bnEquals;
BigInteger$2.prototype.min = bnMin;
BigInteger$2.prototype.max = bnMax;
BigInteger$2.prototype.and = bnAnd;
BigInteger$2.prototype.or = bnOr;
BigInteger$2.prototype.xor = bnXor;
BigInteger$2.prototype.andNot = bnAndNot;
BigInteger$2.prototype.not = bnNot;
BigInteger$2.prototype.shiftLeft = bnShiftLeft;
BigInteger$2.prototype.shiftRight = bnShiftRight;
BigInteger$2.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger$2.prototype.bitCount = bnBitCount;
BigInteger$2.prototype.testBit = bnTestBit;
BigInteger$2.prototype.setBit = bnSetBit;
BigInteger$2.prototype.clearBit = bnClearBit;
BigInteger$2.prototype.flipBit = bnFlipBit;
BigInteger$2.prototype.add = bnAdd;
BigInteger$2.prototype.subtract = bnSubtract;
BigInteger$2.prototype.multiply = bnMultiply;
BigInteger$2.prototype.divide = bnDivide;
BigInteger$2.prototype.remainder = bnRemainder;
BigInteger$2.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger$2.prototype.modPow = bnModPow;
BigInteger$2.prototype.modInverse = bnModInverse;
BigInteger$2.prototype.pow = bnPow;
BigInteger$2.prototype.gcd = bnGCD;
BigInteger$2.prototype.isProbablePrime = bnIsProbablePrime;
var forge$5 = forge$m, sha1 = forge$5.sha1 = forge$5.sha1 || {};
forge$5.md.sha1 = forge$5.md.algorithms.sha1 = sha1;
sha1.create = function() {
  _initialized$1 || _init$1();
  var t = null, e = forge$5.util.createBuffer(), r = new Array(80), n = {
    algorithm: "sha1",
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return n.start = function() {
    n.messageLength = 0, n.fullMessageLength = n.messageLength64 = [];
    for (var i = n.messageLengthSize / 4, o = 0; o < i; ++o)
      n.fullMessageLength.push(0);
    return e = forge$5.util.createBuffer(), t = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878,
      h4: 3285377520
    }, n;
  }, n.start(), n.update = function(i, o) {
    o === "utf8" && (i = forge$5.util.encodeUtf8(i));
    var a = i.length;
    n.messageLength += a, a = [a / 4294967296 >>> 0, a >>> 0];
    for (var c = n.fullMessageLength.length - 1; c >= 0; --c)
      n.fullMessageLength[c] += a[1], a[1] = a[0] + (n.fullMessageLength[c] / 4294967296 >>> 0), n.fullMessageLength[c] = n.fullMessageLength[c] >>> 0, a[0] = a[1] / 4294967296 >>> 0;
    return e.putBytes(i), _update$1(t, r, e), (e.read > 2048 || e.length() === 0) && e.compact(), n;
  }, n.digest = function() {
    var i = forge$5.util.createBuffer();
    i.putBytes(e.bytes());
    var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize, a = o & n.blockLength - 1;
    i.putBytes(_padding$1.substr(0, n.blockLength - a));
    for (var c, l, u = n.fullMessageLength[0] * 8, f = 0; f < n.fullMessageLength.length - 1; ++f)
      c = n.fullMessageLength[f + 1] * 8, l = c / 4294967296 >>> 0, u += l, i.putInt32(u >>> 0), u = c >>> 0;
    i.putInt32(u);
    var d = {
      h0: t.h0,
      h1: t.h1,
      h2: t.h2,
      h3: t.h3,
      h4: t.h4
    };
    _update$1(d, r, i);
    var p = forge$5.util.createBuffer();
    return p.putInt32(d.h0), p.putInt32(d.h1), p.putInt32(d.h2), p.putInt32(d.h3), p.putInt32(d.h4), p;
  }, n;
};
var _padding$1 = null, _initialized$1 = !1;
function _init$1() {
  _padding$1 = String.fromCharCode(128), _padding$1 += forge$5.util.fillString(String.fromCharCode(0), 64), _initialized$1 = !0;
}
function _update$1(t, e, r) {
  for (var n, i, o, a, c, l, u, f, d = r.length(); d >= 64; ) {
    for (i = t.h0, o = t.h1, a = t.h2, c = t.h3, l = t.h4, f = 0; f < 16; ++f)
      n = r.getInt32(), e[f] = n, u = c ^ o & (a ^ c), n = (i << 5 | i >>> 27) + u + l + 1518500249 + n, l = c, c = a, a = (o << 30 | o >>> 2) >>> 0, o = i, i = n;
    for (; f < 20; ++f)
      n = e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16], n = n << 1 | n >>> 31, e[f] = n, u = c ^ o & (a ^ c), n = (i << 5 | i >>> 27) + u + l + 1518500249 + n, l = c, c = a, a = (o << 30 | o >>> 2) >>> 0, o = i, i = n;
    for (; f < 32; ++f)
      n = e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16], n = n << 1 | n >>> 31, e[f] = n, u = o ^ a ^ c, n = (i << 5 | i >>> 27) + u + l + 1859775393 + n, l = c, c = a, a = (o << 30 | o >>> 2) >>> 0, o = i, i = n;
    for (; f < 40; ++f)
      n = e[f - 6] ^ e[f - 16] ^ e[f - 28] ^ e[f - 32], n = n << 2 | n >>> 30, e[f] = n, u = o ^ a ^ c, n = (i << 5 | i >>> 27) + u + l + 1859775393 + n, l = c, c = a, a = (o << 30 | o >>> 2) >>> 0, o = i, i = n;
    for (; f < 60; ++f)
      n = e[f - 6] ^ e[f - 16] ^ e[f - 28] ^ e[f - 32], n = n << 2 | n >>> 30, e[f] = n, u = o & a | c & (o ^ a), n = (i << 5 | i >>> 27) + u + l + 2400959708 + n, l = c, c = a, a = (o << 30 | o >>> 2) >>> 0, o = i, i = n;
    for (; f < 80; ++f)
      n = e[f - 6] ^ e[f - 16] ^ e[f - 28] ^ e[f - 32], n = n << 2 | n >>> 30, e[f] = n, u = o ^ a ^ c, n = (i << 5 | i >>> 27) + u + l + 3395469782 + n, l = c, c = a, a = (o << 30 | o >>> 2) >>> 0, o = i, i = n;
    t.h0 = t.h0 + i | 0, t.h1 = t.h1 + o | 0, t.h2 = t.h2 + a | 0, t.h3 = t.h3 + c | 0, t.h4 = t.h4 + l | 0, d -= 64;
  }
}
var forge$4 = forge$m, pkcs1 = forge$4.pkcs1 = forge$4.pkcs1 || {};
pkcs1.encode_rsa_oaep = function(t, e, r) {
  var n, i, o, a;
  typeof r == "string" ? (n = r, i = arguments[3] || void 0, o = arguments[4] || void 0) : r && (n = r.label || void 0, i = r.seed || void 0, o = r.md || void 0, r.mgf1 && r.mgf1.md && (a = r.mgf1.md)), o ? o.start() : o = forge$4.md.sha1.create(), a || (a = o);
  var c = Math.ceil(t.n.bitLength() / 8), l = c - 2 * o.digestLength - 2;
  if (e.length > l) {
    var u = new Error("RSAES-OAEP input message length is too long.");
    throw u.length = e.length, u.maxLength = l, u;
  }
  n || (n = ""), o.update(n, "raw");
  for (var f = o.digest(), d = "", p = l - e.length, g = 0; g < p; g++)
    d += "\0";
  var h = f.getBytes() + d + "" + e;
  if (!i)
    i = forge$4.random.getBytes(o.digestLength);
  else if (i.length !== o.digestLength) {
    var u = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    throw u.seedLength = i.length, u.digestLength = o.digestLength, u;
  }
  var m = rsa_mgf1(i, c - o.digestLength - 1, a), y = forge$4.util.xorBytes(h, m, h.length), b = rsa_mgf1(y, o.digestLength, a), v = forge$4.util.xorBytes(i, b, i.length);
  return "\0" + v + y;
};
pkcs1.decode_rsa_oaep = function(t, e, r) {
  var n, i, o;
  typeof r == "string" ? (n = r, i = arguments[3] || void 0) : r && (n = r.label || void 0, i = r.md || void 0, r.mgf1 && r.mgf1.md && (o = r.mgf1.md));
  var a = Math.ceil(t.n.bitLength() / 8);
  if (e.length !== a) {
    var y = new Error("RSAES-OAEP encoded message length is invalid.");
    throw y.length = e.length, y.expectedLength = a, y;
  }
  if (i === void 0 ? i = forge$4.md.sha1.create() : i.start(), o || (o = i), a < 2 * i.digestLength + 2)
    throw new Error("RSAES-OAEP key is too short for the hash function.");
  n || (n = ""), i.update(n, "raw");
  for (var c = i.digest().getBytes(), l = e.charAt(0), u = e.substring(1, i.digestLength + 1), f = e.substring(1 + i.digestLength), d = rsa_mgf1(f, i.digestLength, o), p = forge$4.util.xorBytes(u, d, u.length), g = rsa_mgf1(p, a - i.digestLength - 1, o), h = forge$4.util.xorBytes(f, g, f.length), m = h.substring(0, i.digestLength), y = l !== "\0", b = 0; b < i.digestLength; ++b)
    y |= c.charAt(b) !== m.charAt(b);
  for (var v = 1, _ = i.digestLength, E = i.digestLength; E < h.length; E++) {
    var w = h.charCodeAt(E), S = w & 1 ^ 1, x = v ? 65534 : 0;
    y |= w & x, v = v & S, _ += v;
  }
  if (y || h.charCodeAt(_) !== 1)
    throw new Error("Invalid RSAES-OAEP padding.");
  return h.substring(_ + 1);
};
function rsa_mgf1(t, e, r) {
  r || (r = forge$4.md.sha1.create());
  for (var n = "", i = Math.ceil(e / r.digestLength), o = 0; o < i; ++o) {
    var a = String.fromCharCode(
      o >> 24 & 255,
      o >> 16 & 255,
      o >> 8 & 255,
      o & 255
    );
    r.start(), r.update(t + a), n += r.digest().getBytes();
  }
  return n.substring(0, e);
}
var forge$3 = forge$m;
(function() {
  if (forge$3.prime)
    return;
  var t = forge$3.prime = forge$3.prime || {}, e = forge$3.jsbn.BigInteger, r = [6, 4, 2, 4, 2, 4, 6, 2], n = new e(null);
  n.fromInt(30);
  var i = function(d, p) {
    return d | p;
  };
  t.generateProbablePrime = function(d, p, g) {
    typeof p == "function" && (g = p, p = {}), p = p || {};
    var h = p.algorithm || "PRIMEINC";
    typeof h == "string" && (h = { name: h }), h.options = h.options || {};
    var m = p.prng || forge$3.random, y = {
      // x is an array to fill with bytes
      nextBytes: function(b) {
        for (var v = m.getBytesSync(b.length), _ = 0; _ < b.length; ++_)
          b[_] = v.charCodeAt(_);
      }
    };
    if (h.name === "PRIMEINC")
      return o(d, y, h.options, g);
    throw new Error("Invalid prime generation algorithm: " + h.name);
  };
  function o(d, p, g, h) {
    return "workers" in g ? l(d, p, g, h) : a(d, p, g, h);
  }
  function a(d, p, g, h) {
    var m = u(d, p), y = 0, b = f(m.bitLength());
    "millerRabinTests" in g && (b = g.millerRabinTests);
    var v = 10;
    "maxBlockTime" in g && (v = g.maxBlockTime), c(m, d, p, y, b, v, h);
  }
  function c(d, p, g, h, m, y, b) {
    var v = +new Date();
    do {
      if (d.bitLength() > p && (d = u(p, g)), d.isProbablePrime(m))
        return b(null, d);
      d.dAddOffset(r[h++ % 8], 0);
    } while (y < 0 || +new Date() - v < y);
    forge$3.util.setImmediate(function() {
      c(d, p, g, h, m, y, b);
    });
  }
  function l(d, p, g, h) {
    if (typeof Worker > "u")
      return a(d, p, g, h);
    var m = u(d, p), y = g.workers, b = g.workLoad || 100, v = b * 30 / 8, _ = g.workerScript || "forge/prime.worker.js";
    if (y === -1)
      return forge$3.util.estimateCores(function(w, S) {
        w && (S = 2), y = S - 1, E();
      });
    E();
    function E() {
      y = Math.max(1, y);
      for (var w = [], S = 0; S < y; ++S)
        w[S] = new Worker(_);
      for (var S = 0; S < y; ++S)
        w[S].addEventListener("message", I);
      var x = !1;
      function I(C) {
        if (!x) {
          var M = C.data;
          if (M.found) {
            for (var O = 0; O < w.length; ++O)
              w[O].terminate();
            return x = !0, h(null, new e(M.prime, 16));
          }
          m.bitLength() > d && (m = u(d, p));
          var B = m.toString(16);
          C.target.postMessage({
            hex: B,
            workLoad: b
          }), m.dAddOffset(v, 0);
        }
      }
    }
  }
  function u(d, p) {
    var g = new e(d, p), h = d - 1;
    return g.testBit(h) || g.bitwiseTo(e.ONE.shiftLeft(h), i, g), g.dAddOffset(31 - g.mod(n).byteValue(), 0), g;
  }
  function f(d) {
    return d <= 100 ? 27 : d <= 150 ? 18 : d <= 200 ? 15 : d <= 250 ? 12 : d <= 300 ? 9 : d <= 350 ? 8 : d <= 400 ? 7 : d <= 500 ? 6 : d <= 600 ? 5 : d <= 800 ? 4 : d <= 1250 ? 3 : 2;
  }
})();
var forge$2 = forge$m;
if (typeof BigInteger$1 > "u")
  var BigInteger$1 = forge$2.jsbn.BigInteger;
var _crypto = forge$2.util.isNodejs ? crypto$3 : null, asn1$1 = forge$2.asn1, util$a = forge$2.util;
forge$2.pki = forge$2.pki || {};
forge$2.pki.rsa = forge$2.rsa = forge$2.rsa || {};
var pki$1 = forge$2.pki, GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2], privateKeyValidator = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.OID,
      constructed: !1,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.OCTETSTRING,
    constructed: !1,
    capture: "privateKey"
  }]
}, rsaPrivateKeyValidator = {
  // RSAPrivateKey
  name: "RSAPrivateKey",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "RSAPrivateKey.version",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // modulus (n)
    name: "RSAPrivateKey.modulus",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPrivateKey.publicExponent",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPublicExponent"
  }, {
    // privateExponent (d)
    name: "RSAPrivateKey.privateExponent",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrivateExponent"
  }, {
    // prime1 (p)
    name: "RSAPrivateKey.prime1",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrime1"
  }, {
    // prime2 (q)
    name: "RSAPrivateKey.prime2",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrime2"
  }, {
    // exponent1 (d mod (p-1))
    name: "RSAPrivateKey.exponent1",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyExponent1"
  }, {
    // exponent2 (d mod (q-1))
    name: "RSAPrivateKey.exponent2",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyExponent2"
  }, {
    // coefficient ((inverse of q) mod p)
    name: "RSAPrivateKey.coefficient",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyCoefficient"
  }]
}, rsaPublicKeyValidator = {
  // RSAPublicKey
  name: "RSAPublicKey",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // modulus (n)
    name: "RSAPublicKey.modulus",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "publicKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPublicKey.exponent",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: !1,
    capture: "publicKeyExponent"
  }]
}, publicKeyValidator = forge$2.pki.rsa.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "subjectPublicKeyInfo",
  value: [{
    name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.OID,
      constructed: !1,
      capture: "publicKeyOid"
    }]
  }, {
    // subjectPublicKey
    name: "SubjectPublicKeyInfo.subjectPublicKey",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.BITSTRING,
    constructed: !1,
    value: [{
      // RSAPublicKey
      name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: !0,
      optional: !0,
      captureAsn1: "rsaPublicKey"
    }]
  }]
}, digestInfoValidator = {
  name: "DigestInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "DigestInfo.DigestAlgorithm",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.OID,
      constructed: !1,
      capture: "algorithmIdentifier"
    }, {
      // NULL paramters
      name: "DigestInfo.DigestAlgorithm.parameters",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.NULL,
      // captured only to check existence for md2 and md5
      capture: "parameters",
      optional: !0,
      constructed: !1
    }]
  }, {
    // digest
    name: "DigestInfo.digest",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.OCTETSTRING,
    constructed: !1,
    capture: "digest"
  }]
}, emsaPkcs1v15encode = function(t) {
  var e;
  if (t.algorithm in pki$1.oids)
    e = pki$1.oids[t.algorithm];
  else {
    var r = new Error("Unknown message digest algorithm.");
    throw r.algorithm = t.algorithm, r;
  }
  var n = asn1$1.oidToDer(e).getBytes(), i = asn1$1.create(
    asn1$1.Class.UNIVERSAL,
    asn1$1.Type.SEQUENCE,
    !0,
    []
  ), o = asn1$1.create(
    asn1$1.Class.UNIVERSAL,
    asn1$1.Type.SEQUENCE,
    !0,
    []
  );
  o.value.push(asn1$1.create(
    asn1$1.Class.UNIVERSAL,
    asn1$1.Type.OID,
    !1,
    n
  )), o.value.push(asn1$1.create(
    asn1$1.Class.UNIVERSAL,
    asn1$1.Type.NULL,
    !1,
    ""
  ));
  var a = asn1$1.create(
    asn1$1.Class.UNIVERSAL,
    asn1$1.Type.OCTETSTRING,
    !1,
    t.digest().getBytes()
  );
  return i.value.push(o), i.value.push(a), asn1$1.toDer(i).getBytes();
}, _modPow = function(t, e, r) {
  if (r)
    return t.modPow(e.e, e.n);
  if (!e.p || !e.q)
    return t.modPow(e.d, e.n);
  e.dP || (e.dP = e.d.mod(e.p.subtract(BigInteger$1.ONE))), e.dQ || (e.dQ = e.d.mod(e.q.subtract(BigInteger$1.ONE))), e.qInv || (e.qInv = e.q.modInverse(e.p));
  var n;
  do
    n = new BigInteger$1(
      forge$2.util.bytesToHex(forge$2.random.getBytes(e.n.bitLength() / 8)),
      16
    );
  while (n.compareTo(e.n) >= 0 || !n.gcd(e.n).equals(BigInteger$1.ONE));
  t = t.multiply(n.modPow(e.e, e.n)).mod(e.n);
  for (var i = t.mod(e.p).modPow(e.dP, e.p), o = t.mod(e.q).modPow(e.dQ, e.q); i.compareTo(o) < 0; )
    i = i.add(e.p);
  var a = i.subtract(o).multiply(e.qInv).mod(e.p).multiply(e.q).add(o);
  return a = a.multiply(n.modInverse(e.n)).mod(e.n), a;
};
pki$1.rsa.encrypt = function(t, e, r) {
  var n = r, i, o = Math.ceil(e.n.bitLength() / 8);
  r !== !1 && r !== !0 ? (n = r === 2, i = _encodePkcs1_v1_5(t, e, r)) : (i = forge$2.util.createBuffer(), i.putBytes(t));
  for (var a = new BigInteger$1(i.toHex(), 16), c = _modPow(a, e, n), l = c.toString(16), u = forge$2.util.createBuffer(), f = o - Math.ceil(l.length / 2); f > 0; )
    u.putByte(0), --f;
  return u.putBytes(forge$2.util.hexToBytes(l)), u.getBytes();
};
pki$1.rsa.decrypt = function(t, e, r, n) {
  var i = Math.ceil(e.n.bitLength() / 8);
  if (t.length !== i) {
    var o = new Error("Encrypted message length is invalid.");
    throw o.length = t.length, o.expected = i, o;
  }
  var a = new BigInteger$1(forge$2.util.createBuffer(t).toHex(), 16);
  if (a.compareTo(e.n) >= 0)
    throw new Error("Encrypted message is invalid.");
  for (var c = _modPow(a, e, r), l = c.toString(16), u = forge$2.util.createBuffer(), f = i - Math.ceil(l.length / 2); f > 0; )
    u.putByte(0), --f;
  return u.putBytes(forge$2.util.hexToBytes(l)), n !== !1 ? _decodePkcs1_v1_5(u.getBytes(), e, r) : u.getBytes();
};
pki$1.rsa.createKeyPairGenerationState = function(t, e, r) {
  typeof t == "string" && (t = parseInt(t, 10)), t = t || 2048, r = r || {};
  var n = r.prng || forge$2.random, i = {
    // x is an array to fill with bytes
    nextBytes: function(c) {
      for (var l = n.getBytesSync(c.length), u = 0; u < c.length; ++u)
        c[u] = l.charCodeAt(u);
    }
  }, o = r.algorithm || "PRIMEINC", a;
  if (o === "PRIMEINC")
    a = {
      algorithm: o,
      state: 0,
      bits: t,
      rng: i,
      eInt: e || 65537,
      e: new BigInteger$1(null),
      p: null,
      q: null,
      qBits: t >> 1,
      pBits: t - (t >> 1),
      pqState: 0,
      num: null,
      keys: null
    }, a.e.fromInt(a.eInt);
  else
    throw new Error("Invalid key generation algorithm: " + o);
  return a;
};
pki$1.rsa.stepKeyPairGenerationState = function(t, e) {
  "algorithm" in t || (t.algorithm = "PRIMEINC");
  var r = new BigInteger$1(null);
  r.fromInt(30);
  for (var n = 0, i = function(d, p) {
    return d | p;
  }, o = +new Date(), a, c = 0; t.keys === null && (e <= 0 || c < e); ) {
    if (t.state === 0) {
      var l = t.p === null ? t.pBits : t.qBits, u = l - 1;
      t.pqState === 0 ? (t.num = new BigInteger$1(l, t.rng), t.num.testBit(u) || t.num.bitwiseTo(
        BigInteger$1.ONE.shiftLeft(u),
        i,
        t.num
      ), t.num.dAddOffset(31 - t.num.mod(r).byteValue(), 0), n = 0, ++t.pqState) : t.pqState === 1 ? t.num.bitLength() > l ? t.pqState = 0 : t.num.isProbablePrime(
        _getMillerRabinTests(t.num.bitLength())
      ) ? ++t.pqState : t.num.dAddOffset(GCD_30_DELTA[n++ % 8], 0) : t.pqState === 2 ? t.pqState = t.num.subtract(BigInteger$1.ONE).gcd(t.e).compareTo(BigInteger$1.ONE) === 0 ? 3 : 0 : t.pqState === 3 && (t.pqState = 0, t.p === null ? t.p = t.num : t.q = t.num, t.p !== null && t.q !== null && ++t.state, t.num = null);
    } else if (t.state === 1)
      t.p.compareTo(t.q) < 0 && (t.num = t.p, t.p = t.q, t.q = t.num), ++t.state;
    else if (t.state === 2)
      t.p1 = t.p.subtract(BigInteger$1.ONE), t.q1 = t.q.subtract(BigInteger$1.ONE), t.phi = t.p1.multiply(t.q1), ++t.state;
    else if (t.state === 3)
      t.phi.gcd(t.e).compareTo(BigInteger$1.ONE) === 0 ? ++t.state : (t.p = null, t.q = null, t.state = 0);
    else if (t.state === 4)
      t.n = t.p.multiply(t.q), t.n.bitLength() === t.bits ? ++t.state : (t.q = null, t.state = 0);
    else if (t.state === 5) {
      var f = t.e.modInverse(t.phi);
      t.keys = {
        privateKey: pki$1.rsa.setPrivateKey(
          t.n,
          t.e,
          f,
          t.p,
          t.q,
          f.mod(t.p1),
          f.mod(t.q1),
          t.q.modInverse(t.p)
        ),
        publicKey: pki$1.rsa.setPublicKey(t.n, t.e)
      };
    }
    a = +new Date(), c += a - o, o = a;
  }
  return t.keys !== null;
};
pki$1.rsa.generateKeyPair = function(t, e, r, n) {
  if (arguments.length === 1 ? typeof t == "object" ? (r = t, t = void 0) : typeof t == "function" && (n = t, t = void 0) : arguments.length === 2 ? typeof t == "number" ? typeof e == "function" ? (n = e, e = void 0) : typeof e != "number" && (r = e, e = void 0) : (r = t, n = e, t = void 0, e = void 0) : arguments.length === 3 && (typeof e == "number" ? typeof r == "function" && (n = r, r = void 0) : (n = r, r = e, e = void 0)), r = r || {}, t === void 0 && (t = r.bits || 2048), e === void 0 && (e = r.e || 65537), !r.prng && t >= 256 && t <= 16384 && (e === 65537 || e === 3)) {
    if (n) {
      if (_detectNodeCrypto("generateKeyPair"))
        return _crypto.generateKeyPair("rsa", {
          modulusLength: t,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        }, function(c, l, u) {
          if (c)
            return n(c);
          n(null, {
            privateKey: pki$1.privateKeyFromPem(u),
            publicKey: pki$1.publicKeyFromPem(l)
          });
        });
      if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey"))
        return util$a.globalScope.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: t,
          publicExponent: _intToUint8Array(e),
          hash: { name: "SHA-256" }
        }, !0, ["sign", "verify"]).then(function(c) {
          return util$a.globalScope.crypto.subtle.exportKey(
            "pkcs8",
            c.privateKey
          );
        }).then(void 0, function(c) {
          n(c);
        }).then(function(c) {
          if (c) {
            var l = pki$1.privateKeyFromAsn1(
              asn1$1.fromDer(forge$2.util.createBuffer(c))
            );
            n(null, {
              privateKey: l,
              publicKey: pki$1.setRsaPublicKey(l.n, l.e)
            });
          }
        });
      if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
        var i = util$a.globalScope.msCrypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: t,
          publicExponent: _intToUint8Array(e),
          hash: { name: "SHA-256" }
        }, !0, ["sign", "verify"]);
        i.oncomplete = function(c) {
          var l = c.target.result, u = util$a.globalScope.msCrypto.subtle.exportKey(
            "pkcs8",
            l.privateKey
          );
          u.oncomplete = function(f) {
            var d = f.target.result, p = pki$1.privateKeyFromAsn1(
              asn1$1.fromDer(forge$2.util.createBuffer(d))
            );
            n(null, {
              privateKey: p,
              publicKey: pki$1.setRsaPublicKey(p.n, p.e)
            });
          }, u.onerror = function(f) {
            n(f);
          };
        }, i.onerror = function(c) {
          n(c);
        };
        return;
      }
    } else if (_detectNodeCrypto("generateKeyPairSync")) {
      var o = _crypto.generateKeyPairSync("rsa", {
        modulusLength: t,
        publicExponent: e,
        publicKeyEncoding: {
          type: "spki",
          format: "pem"
        },
        privateKeyEncoding: {
          type: "pkcs8",
          format: "pem"
        }
      });
      return {
        privateKey: pki$1.privateKeyFromPem(o.privateKey),
        publicKey: pki$1.publicKeyFromPem(o.publicKey)
      };
    }
  }
  var a = pki$1.rsa.createKeyPairGenerationState(t, e, r);
  if (!n)
    return pki$1.rsa.stepKeyPairGenerationState(a, 0), a.keys;
  _generateKeyPair(a, r, n);
};
pki$1.setRsaPublicKey = pki$1.rsa.setPublicKey = function(t, e) {
  var r = {
    n: t,
    e
  };
  return r.encrypt = function(n, i, o) {
    if (typeof i == "string" ? i = i.toUpperCase() : i === void 0 && (i = "RSAES-PKCS1-V1_5"), i === "RSAES-PKCS1-V1_5")
      i = {
        encode: function(c, l, u) {
          return _encodePkcs1_v1_5(c, l, 2).getBytes();
        }
      };
    else if (i === "RSA-OAEP" || i === "RSAES-OAEP")
      i = {
        encode: function(c, l) {
          return forge$2.pkcs1.encode_rsa_oaep(l, c, o);
        }
      };
    else if (["RAW", "NONE", "NULL", null].indexOf(i) !== -1)
      i = { encode: function(c) {
        return c;
      } };
    else if (typeof i == "string")
      throw new Error('Unsupported encryption scheme: "' + i + '".');
    var a = i.encode(n, r, !0);
    return pki$1.rsa.encrypt(a, r, !0);
  }, r.verify = function(n, i, o, a) {
    typeof o == "string" ? o = o.toUpperCase() : o === void 0 && (o = "RSASSA-PKCS1-V1_5"), a === void 0 && (a = {
      _parseAllDigestBytes: !0
    }), "_parseAllDigestBytes" in a || (a._parseAllDigestBytes = !0), o === "RSASSA-PKCS1-V1_5" ? o = {
      verify: function(l, u) {
        u = _decodePkcs1_v1_5(u, r, !0);
        var f = asn1$1.fromDer(u, {
          parseAllBytes: a._parseAllDigestBytes
        }), d = {}, p = [];
        if (!asn1$1.validate(f, digestInfoValidator, d, p)) {
          var g = new Error(
            "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
          );
          throw g.errors = p, g;
        }
        var h = asn1$1.derToOid(d.algorithmIdentifier);
        if (!(h === forge$2.oids.md2 || h === forge$2.oids.md5 || h === forge$2.oids.sha1 || h === forge$2.oids.sha224 || h === forge$2.oids.sha256 || h === forge$2.oids.sha384 || h === forge$2.oids.sha512 || h === forge$2.oids["sha512-224"] || h === forge$2.oids["sha512-256"])) {
          var g = new Error(
            "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
          );
          throw g.oid = h, g;
        }
        if ((h === forge$2.oids.md2 || h === forge$2.oids.md5) && !("parameters" in d))
          throw new Error(
            "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
          );
        return l === d.digest;
      }
    } : (o === "NONE" || o === "NULL" || o === null) && (o = {
      verify: function(l, u) {
        return u = _decodePkcs1_v1_5(u, r, !0), l === u;
      }
    });
    var c = pki$1.rsa.decrypt(i, r, !0, !1);
    return o.verify(n, c, r.n.bitLength());
  }, r;
};
pki$1.setRsaPrivateKey = pki$1.rsa.setPrivateKey = function(t, e, r, n, i, o, a, c) {
  var l = {
    n: t,
    e,
    d: r,
    p: n,
    q: i,
    dP: o,
    dQ: a,
    qInv: c
  };
  return l.decrypt = function(u, f, d) {
    typeof f == "string" ? f = f.toUpperCase() : f === void 0 && (f = "RSAES-PKCS1-V1_5");
    var p = pki$1.rsa.decrypt(u, l, !1, !1);
    if (f === "RSAES-PKCS1-V1_5")
      f = { decode: _decodePkcs1_v1_5 };
    else if (f === "RSA-OAEP" || f === "RSAES-OAEP")
      f = {
        decode: function(g, h) {
          return forge$2.pkcs1.decode_rsa_oaep(h, g, d);
        }
      };
    else if (["RAW", "NONE", "NULL", null].indexOf(f) !== -1)
      f = { decode: function(g) {
        return g;
      } };
    else
      throw new Error('Unsupported encryption scheme: "' + f + '".');
    return f.decode(p, l, !1);
  }, l.sign = function(u, f) {
    var d = !1;
    typeof f == "string" && (f = f.toUpperCase()), f === void 0 || f === "RSASSA-PKCS1-V1_5" ? (f = { encode: emsaPkcs1v15encode }, d = 1) : (f === "NONE" || f === "NULL" || f === null) && (f = { encode: function() {
      return u;
    } }, d = 1);
    var p = f.encode(u, l.n.bitLength());
    return pki$1.rsa.encrypt(p, l, d);
  }, l;
};
pki$1.wrapRsaPrivateKey = function(t) {
  return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, !0, [
    // version (0)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      asn1$1.integerToDer(0).getBytes()
    ),
    // privateKeyAlgorithm
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, !0, [
      asn1$1.create(
        asn1$1.Class.UNIVERSAL,
        asn1$1.Type.OID,
        !1,
        asn1$1.oidToDer(pki$1.oids.rsaEncryption).getBytes()
      ),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, !1, "")
    ]),
    // PrivateKey
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.OCTETSTRING,
      !1,
      asn1$1.toDer(t).getBytes()
    )
  ]);
};
pki$1.privateKeyFromAsn1 = function(t) {
  var e = {}, r = [];
  if (asn1$1.validate(t, privateKeyValidator, e, r) && (t = asn1$1.fromDer(forge$2.util.createBuffer(e.privateKey))), e = {}, r = [], !asn1$1.validate(t, rsaPrivateKeyValidator, e, r)) {
    var n = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    throw n.errors = r, n;
  }
  var i, o, a, c, l, u, f, d;
  return i = forge$2.util.createBuffer(e.privateKeyModulus).toHex(), o = forge$2.util.createBuffer(e.privateKeyPublicExponent).toHex(), a = forge$2.util.createBuffer(e.privateKeyPrivateExponent).toHex(), c = forge$2.util.createBuffer(e.privateKeyPrime1).toHex(), l = forge$2.util.createBuffer(e.privateKeyPrime2).toHex(), u = forge$2.util.createBuffer(e.privateKeyExponent1).toHex(), f = forge$2.util.createBuffer(e.privateKeyExponent2).toHex(), d = forge$2.util.createBuffer(e.privateKeyCoefficient).toHex(), pki$1.setRsaPrivateKey(
    new BigInteger$1(i, 16),
    new BigInteger$1(o, 16),
    new BigInteger$1(a, 16),
    new BigInteger$1(c, 16),
    new BigInteger$1(l, 16),
    new BigInteger$1(u, 16),
    new BigInteger$1(f, 16),
    new BigInteger$1(d, 16)
  );
};
pki$1.privateKeyToAsn1 = pki$1.privateKeyToRSAPrivateKey = function(t) {
  return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, !0, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      asn1$1.integerToDer(0).getBytes()
    ),
    // modulus (n)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.n)
    ),
    // publicExponent (e)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.e)
    ),
    // privateExponent (d)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.d)
    ),
    // privateKeyPrime1 (p)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.p)
    ),
    // privateKeyPrime2 (q)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.q)
    ),
    // privateKeyExponent1 (dP)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.dP)
    ),
    // privateKeyExponent2 (dQ)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.dQ)
    ),
    // coefficient (qInv)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.qInv)
    )
  ]);
};
pki$1.publicKeyFromAsn1 = function(t) {
  var e = {}, r = [];
  if (asn1$1.validate(t, publicKeyValidator, e, r)) {
    var n = asn1$1.derToOid(e.publicKeyOid);
    if (n !== pki$1.oids.rsaEncryption) {
      var i = new Error("Cannot read public key. Unknown OID.");
      throw i.oid = n, i;
    }
    t = e.rsaPublicKey;
  }
  if (r = [], !asn1$1.validate(t, rsaPublicKeyValidator, e, r)) {
    var i = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    throw i.errors = r, i;
  }
  var o = forge$2.util.createBuffer(e.publicKeyModulus).toHex(), a = forge$2.util.createBuffer(e.publicKeyExponent).toHex();
  return pki$1.setRsaPublicKey(
    new BigInteger$1(o, 16),
    new BigInteger$1(a, 16)
  );
};
pki$1.publicKeyToAsn1 = pki$1.publicKeyToSubjectPublicKeyInfo = function(t) {
  return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, !0, [
    // AlgorithmIdentifier
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, !0, [
      // algorithm
      asn1$1.create(
        asn1$1.Class.UNIVERSAL,
        asn1$1.Type.OID,
        !1,
        asn1$1.oidToDer(pki$1.oids.rsaEncryption).getBytes()
      ),
      // parameters (null)
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, !1, "")
    ]),
    // subjectPublicKey
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.BITSTRING, !1, [
      pki$1.publicKeyToRSAPublicKey(t)
    ])
  ]);
};
pki$1.publicKeyToRSAPublicKey = function(t) {
  return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, !0, [
    // modulus (n)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.n)
    ),
    // publicExponent (e)
    asn1$1.create(
      asn1$1.Class.UNIVERSAL,
      asn1$1.Type.INTEGER,
      !1,
      _bnToBytes(t.e)
    )
  ]);
};
function _encodePkcs1_v1_5(t, e, r) {
  var n = forge$2.util.createBuffer(), i = Math.ceil(e.n.bitLength() / 8);
  if (t.length > i - 11) {
    var o = new Error("Message is too long for PKCS#1 v1.5 padding.");
    throw o.length = t.length, o.max = i - 11, o;
  }
  n.putByte(0), n.putByte(r);
  var a = i - 3 - t.length, c;
  if (r === 0 || r === 1) {
    c = r === 0 ? 0 : 255;
    for (var l = 0; l < a; ++l)
      n.putByte(c);
  } else
    for (; a > 0; ) {
      for (var u = 0, f = forge$2.random.getBytes(a), l = 0; l < a; ++l)
        c = f.charCodeAt(l), c === 0 ? ++u : n.putByte(c);
      a = u;
    }
  return n.putByte(0), n.putBytes(t), n;
}
function _decodePkcs1_v1_5(t, e, r, n) {
  var i = Math.ceil(e.n.bitLength() / 8), o = forge$2.util.createBuffer(t), a = o.getByte(), c = o.getByte();
  if (a !== 0 || r && c !== 0 && c !== 1 || !r && c != 2 || r && c === 0 && typeof n > "u")
    throw new Error("Encryption block is invalid.");
  var l = 0;
  if (c === 0) {
    l = i - 3 - n;
    for (var u = 0; u < l; ++u)
      if (o.getByte() !== 0)
        throw new Error("Encryption block is invalid.");
  } else if (c === 1)
    for (l = 0; o.length() > 1; ) {
      if (o.getByte() !== 255) {
        --o.read;
        break;
      }
      ++l;
    }
  else if (c === 2)
    for (l = 0; o.length() > 1; ) {
      if (o.getByte() === 0) {
        --o.read;
        break;
      }
      ++l;
    }
  var f = o.getByte();
  if (f !== 0 || l !== i - 3 - o.length())
    throw new Error("Encryption block is invalid.");
  return o.getBytes();
}
function _generateKeyPair(t, e, r) {
  typeof e == "function" && (r = e, e = {}), e = e || {};
  var n = {
    algorithm: {
      name: e.algorithm || "PRIMEINC",
      options: {
        workers: e.workers || 2,
        workLoad: e.workLoad || 100,
        workerScript: e.workerScript
      }
    }
  };
  "prng" in e && (n.prng = e.prng), i();
  function i() {
    o(t.pBits, function(c, l) {
      if (c)
        return r(c);
      if (t.p = l, t.q !== null)
        return a(c, t.q);
      o(t.qBits, a);
    });
  }
  function o(c, l) {
    forge$2.prime.generateProbablePrime(c, n, l);
  }
  function a(c, l) {
    if (c)
      return r(c);
    if (t.q = l, t.p.compareTo(t.q) < 0) {
      var u = t.p;
      t.p = t.q, t.q = u;
    }
    if (t.p.subtract(BigInteger$1.ONE).gcd(t.e).compareTo(BigInteger$1.ONE) !== 0) {
      t.p = null, i();
      return;
    }
    if (t.q.subtract(BigInteger$1.ONE).gcd(t.e).compareTo(BigInteger$1.ONE) !== 0) {
      t.q = null, o(t.qBits, a);
      return;
    }
    if (t.p1 = t.p.subtract(BigInteger$1.ONE), t.q1 = t.q.subtract(BigInteger$1.ONE), t.phi = t.p1.multiply(t.q1), t.phi.gcd(t.e).compareTo(BigInteger$1.ONE) !== 0) {
      t.p = t.q = null, i();
      return;
    }
    if (t.n = t.p.multiply(t.q), t.n.bitLength() !== t.bits) {
      t.q = null, o(t.qBits, a);
      return;
    }
    var f = t.e.modInverse(t.phi);
    t.keys = {
      privateKey: pki$1.rsa.setPrivateKey(
        t.n,
        t.e,
        f,
        t.p,
        t.q,
        f.mod(t.p1),
        f.mod(t.q1),
        t.q.modInverse(t.p)
      ),
      publicKey: pki$1.rsa.setPublicKey(t.n, t.e)
    }, r(null, t.keys);
  }
}
function _bnToBytes(t) {
  var e = t.toString(16);
  e[0] >= "8" && (e = "00" + e);
  var r = forge$2.util.hexToBytes(e);
  return r.length > 1 && // leading 0x00 for positive integer
  (r.charCodeAt(0) === 0 && !(r.charCodeAt(1) & 128) || // leading 0xFF for negative integer
  r.charCodeAt(0) === 255 && (r.charCodeAt(1) & 128) === 128) ? r.substr(1) : r;
}
function _getMillerRabinTests(t) {
  return t <= 100 ? 27 : t <= 150 ? 18 : t <= 200 ? 15 : t <= 250 ? 12 : t <= 300 ? 9 : t <= 350 ? 8 : t <= 400 ? 7 : t <= 500 ? 6 : t <= 600 ? 5 : t <= 800 ? 4 : t <= 1250 ? 3 : 2;
}
function _detectNodeCrypto(t) {
  return forge$2.util.isNodejs && typeof _crypto[t] == "function";
}
function _detectSubtleCrypto(t) {
  return typeof util$a.globalScope < "u" && typeof util$a.globalScope.crypto == "object" && typeof util$a.globalScope.crypto.subtle == "object" && typeof util$a.globalScope.crypto.subtle[t] == "function";
}
function _detectSubtleMsCrypto(t) {
  return typeof util$a.globalScope < "u" && typeof util$a.globalScope.msCrypto == "object" && typeof util$a.globalScope.msCrypto.subtle == "object" && typeof util$a.globalScope.msCrypto.subtle[t] == "function";
}
function _intToUint8Array(t) {
  for (var e = forge$2.util.hexToBytes(t.toString(16)), r = new Uint8Array(e.length), n = 0; n < e.length; ++n)
    r[n] = e.charCodeAt(n);
  return r;
}
var forge$1 = forge$m;
if (typeof BigInteger > "u")
  var BigInteger = forge$1.jsbn.BigInteger;
var asn1 = forge$1.asn1, pki = forge$1.pki = forge$1.pki || {};
pki.pbe = forge$1.pbe = forge$1.pbe || {};
var oids = pki.oids, encryptedPrivateKeyValidator = {
  name: "EncryptedPrivateKeyInfo",
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: !1,
      capture: "encryptionOid"
    }, {
      name: "AlgorithmIdentifier.parameters",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "encryptionParams"
    }]
  }, {
    // encryptedData
    name: "EncryptedPrivateKeyInfo.encryptedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: !1,
    capture: "encryptedData"
  }]
}, PBES2AlgorithmsValidator = {
  name: "PBES2Algorithms",
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "PBES2Algorithms.keyDerivationFunc",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc.oid",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: !1,
      capture: "kdfOid"
    }, {
      name: "PBES2Algorithms.params",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PBES2Algorithms.params.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: !1,
        capture: "kdfSalt"
      }, {
        name: "PBES2Algorithms.params.iterationCount",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "kdfIterationCount"
      }, {
        name: "PBES2Algorithms.params.keyLength",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        optional: !0,
        capture: "keyLength"
      }, {
        // prf
        name: "PBES2Algorithms.params.prf",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        optional: !0,
        value: [{
          name: "PBES2Algorithms.params.prf.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "prfOid"
        }]
      }]
    }]
  }, {
    name: "PBES2Algorithms.encryptionScheme",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PBES2Algorithms.encryptionScheme.oid",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: !1,
      capture: "encOid"
    }, {
      name: "PBES2Algorithms.encryptionScheme.iv",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: !1,
      capture: "encIv"
    }]
  }]
}, pkcs12PbeParamsValidator = {
  name: "pkcs-12PbeParams",
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "pkcs-12PbeParams.salt",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: !1,
    capture: "salt"
  }, {
    name: "pkcs-12PbeParams.iterations",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: !1,
    capture: "iterations"
  }]
};
pki.encryptPrivateKeyInfo = function(t, e, r) {
  r = r || {}, r.saltSize = r.saltSize || 8, r.count = r.count || 2048, r.algorithm = r.algorithm || "aes128", r.prfAlgorithm = r.prfAlgorithm || "sha1";
  var n = forge$1.random.getBytesSync(r.saltSize), i = r.count, o = asn1.integerToDer(i), a, c, l;
  if (r.algorithm.indexOf("aes") === 0 || r.algorithm === "des") {
    var u, f, d;
    switch (r.algorithm) {
      case "aes128":
        a = 16, u = 16, f = oids["aes128-CBC"], d = forge$1.aes.createEncryptionCipher;
        break;
      case "aes192":
        a = 24, u = 16, f = oids["aes192-CBC"], d = forge$1.aes.createEncryptionCipher;
        break;
      case "aes256":
        a = 32, u = 16, f = oids["aes256-CBC"], d = forge$1.aes.createEncryptionCipher;
        break;
      case "des":
        a = 8, u = 8, f = oids.desCBC, d = forge$1.des.createEncryptionCipher;
        break;
      default:
        var p = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        throw p.algorithm = r.algorithm, p;
    }
    var g = "hmacWith" + r.prfAlgorithm.toUpperCase(), h = prfAlgorithmToMessageDigest(g), m = forge$1.pkcs5.pbkdf2(e, n, i, a, h), y = forge$1.random.getBytesSync(u), b = d(m);
    b.start(y), b.update(asn1.toDer(t)), b.finish(), l = b.output.getBytes();
    var v = createPbkdf2Params(n, o, a, g);
    c = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.SEQUENCE,
      !0,
      [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          !1,
          asn1.oidToDer(oids.pkcs5PBES2).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
          // keyDerivationFunc
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              !1,
              asn1.oidToDer(oids.pkcs5PBKDF2).getBytes()
            ),
            // PBKDF2-params
            v
          ]),
          // encryptionScheme
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              !1,
              asn1.oidToDer(f).getBytes()
            ),
            // iv
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              !1,
              y
            )
          ])
        ])
      ]
    );
  } else if (r.algorithm === "3des") {
    a = 24;
    var _ = new forge$1.util.ByteBuffer(n), m = pki.pbe.generatePkcs12Key(e, _, 1, i, a), y = pki.pbe.generatePkcs12Key(e, _, 2, i, a), b = forge$1.des.createEncryptionCipher(m);
    b.start(y), b.update(asn1.toDer(t)), b.finish(), l = b.output.getBytes(), c = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.SEQUENCE,
      !0,
      [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          !1,
          asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
        ),
        // pkcs-12PbeParams
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
          // salt
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, n),
          // iteration count
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            !1,
            o.getBytes()
          )
        ])
      ]
    );
  } else {
    var p = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
    throw p.algorithm = r.algorithm, p;
  }
  var E = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
    // encryptionAlgorithm
    c,
    // encryptedData
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      !1,
      l
    )
  ]);
  return E;
};
pki.decryptPrivateKeyInfo = function(t, e) {
  var r = null, n = {}, i = [];
  if (!asn1.validate(t, encryptedPrivateKeyValidator, n, i)) {
    var o = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw o.errors = i, o;
  }
  var a = asn1.derToOid(n.encryptionOid), c = pki.pbe.getCipher(a, n.encryptionParams, e), l = forge$1.util.createBuffer(n.encryptedData);
  return c.update(l), c.finish() && (r = asn1.fromDer(c.output)), r;
};
pki.encryptedPrivateKeyToPem = function(t, e) {
  var r = {
    type: "ENCRYPTED PRIVATE KEY",
    body: asn1.toDer(t).getBytes()
  };
  return forge$1.pem.encode(r, { maxline: e });
};
pki.encryptedPrivateKeyFromPem = function(t) {
  var e = forge$1.pem.decode(t)[0];
  if (e.type !== "ENCRYPTED PRIVATE KEY") {
    var r = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    throw r.headerType = e.type, r;
  }
  if (e.procType && e.procType.type === "ENCRYPTED")
    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  return asn1.fromDer(e.body);
};
pki.encryptRsaPrivateKey = function(t, e, r) {
  if (r = r || {}, !r.legacy) {
    var n = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(t));
    return n = pki.encryptPrivateKeyInfo(n, e, r), pki.encryptedPrivateKeyToPem(n);
  }
  var i, o, a, c;
  switch (r.algorithm) {
    case "aes128":
      i = "AES-128-CBC", a = 16, o = forge$1.random.getBytesSync(16), c = forge$1.aes.createEncryptionCipher;
      break;
    case "aes192":
      i = "AES-192-CBC", a = 24, o = forge$1.random.getBytesSync(16), c = forge$1.aes.createEncryptionCipher;
      break;
    case "aes256":
      i = "AES-256-CBC", a = 32, o = forge$1.random.getBytesSync(16), c = forge$1.aes.createEncryptionCipher;
      break;
    case "3des":
      i = "DES-EDE3-CBC", a = 24, o = forge$1.random.getBytesSync(8), c = forge$1.des.createEncryptionCipher;
      break;
    case "des":
      i = "DES-CBC", a = 8, o = forge$1.random.getBytesSync(8), c = forge$1.des.createEncryptionCipher;
      break;
    default:
      var l = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + r.algorithm + '".');
      throw l.algorithm = r.algorithm, l;
  }
  var u = forge$1.pbe.opensslDeriveBytes(e, o.substr(0, 8), a), f = c(u);
  f.start(o), f.update(asn1.toDer(pki.privateKeyToAsn1(t))), f.finish();
  var d = {
    type: "RSA PRIVATE KEY",
    procType: {
      version: "4",
      type: "ENCRYPTED"
    },
    dekInfo: {
      algorithm: i,
      parameters: forge$1.util.bytesToHex(o).toUpperCase()
    },
    body: f.output.getBytes()
  };
  return forge$1.pem.encode(d);
};
pki.decryptRsaPrivateKey = function(t, e) {
  var r = null, n = forge$1.pem.decode(t)[0];
  if (n.type !== "ENCRYPTED PRIVATE KEY" && n.type !== "PRIVATE KEY" && n.type !== "RSA PRIVATE KEY") {
    var i = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    throw i.headerType = i, i;
  }
  if (n.procType && n.procType.type === "ENCRYPTED") {
    var o, a;
    switch (n.dekInfo.algorithm) {
      case "DES-CBC":
        o = 8, a = forge$1.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        o = 24, a = forge$1.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        o = 16, a = forge$1.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        o = 24, a = forge$1.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        o = 32, a = forge$1.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        o = 5, a = function(d) {
          return forge$1.rc2.createDecryptionCipher(d, 40);
        };
        break;
      case "RC2-64-CBC":
        o = 8, a = function(d) {
          return forge$1.rc2.createDecryptionCipher(d, 64);
        };
        break;
      case "RC2-128-CBC":
        o = 16, a = function(d) {
          return forge$1.rc2.createDecryptionCipher(d, 128);
        };
        break;
      default:
        var i = new Error('Could not decrypt private key; unsupported encryption algorithm "' + n.dekInfo.algorithm + '".');
        throw i.algorithm = n.dekInfo.algorithm, i;
    }
    var c = forge$1.util.hexToBytes(n.dekInfo.parameters), l = forge$1.pbe.opensslDeriveBytes(e, c.substr(0, 8), o), u = a(l);
    if (u.start(c), u.update(forge$1.util.createBuffer(n.body)), u.finish())
      r = u.output.getBytes();
    else
      return r;
  } else
    r = n.body;
  return n.type === "ENCRYPTED PRIVATE KEY" ? r = pki.decryptPrivateKeyInfo(asn1.fromDer(r), e) : r = asn1.fromDer(r), r !== null && (r = pki.privateKeyFromAsn1(r)), r;
};
pki.pbe.generatePkcs12Key = function(t, e, r, n, i, o) {
  var a, c;
  if (typeof o > "u" || o === null) {
    if (!("sha1" in forge$1.md))
      throw new Error('"sha1" hash algorithm unavailable.');
    o = forge$1.md.sha1.create();
  }
  var l = o.digestLength, u = o.blockLength, f = new forge$1.util.ByteBuffer(), d = new forge$1.util.ByteBuffer();
  if (t != null) {
    for (c = 0; c < t.length; c++)
      d.putInt16(t.charCodeAt(c));
    d.putInt16(0);
  }
  var p = d.length(), g = e.length(), h = new forge$1.util.ByteBuffer();
  h.fillWithByte(r, u);
  var m = u * Math.ceil(g / u), y = new forge$1.util.ByteBuffer();
  for (c = 0; c < m; c++)
    y.putByte(e.at(c % g));
  var b = u * Math.ceil(p / u), v = new forge$1.util.ByteBuffer();
  for (c = 0; c < b; c++)
    v.putByte(d.at(c % p));
  var _ = y;
  _.putBuffer(v);
  for (var E = Math.ceil(i / l), w = 1; w <= E; w++) {
    var S = new forge$1.util.ByteBuffer();
    S.putBytes(h.bytes()), S.putBytes(_.bytes());
    for (var x = 0; x < n; x++)
      o.start(), o.update(S.getBytes()), S = o.digest();
    var I = new forge$1.util.ByteBuffer();
    for (c = 0; c < u; c++)
      I.putByte(S.at(c % l));
    var C = Math.ceil(g / u) + Math.ceil(p / u), M = new forge$1.util.ByteBuffer();
    for (a = 0; a < C; a++) {
      var O = new forge$1.util.ByteBuffer(_.getBytes(u)), B = 511;
      for (c = I.length() - 1; c >= 0; c--)
        B = B >> 8, B += I.at(c) + O.at(c), O.setAt(c, B & 255);
      M.putBuffer(O);
    }
    _ = M, f.putBuffer(S);
  }
  return f.truncate(f.length() - i), f;
};
pki.pbe.getCipher = function(t, e, r) {
  switch (t) {
    case pki.oids.pkcs5PBES2:
      return pki.pbe.getCipherForPBES2(t, e, r);
    case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return pki.pbe.getCipherForPKCS12PBE(t, e, r);
    default:
      var n = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      throw n.oid = t, n.supportedOids = [
        "pkcs5PBES2",
        "pbeWithSHAAnd3-KeyTripleDES-CBC",
        "pbewithSHAAnd40BitRC2-CBC"
      ], n;
  }
};
pki.pbe.getCipherForPBES2 = function(t, e, r) {
  var n = {}, i = [];
  if (!asn1.validate(e, PBES2AlgorithmsValidator, n, i)) {
    var o = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw o.errors = i, o;
  }
  if (t = asn1.derToOid(n.kdfOid), t !== pki.oids.pkcs5PBKDF2) {
    var o = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
    throw o.oid = t, o.supportedOids = ["pkcs5PBKDF2"], o;
  }
  if (t = asn1.derToOid(n.encOid), t !== pki.oids["aes128-CBC"] && t !== pki.oids["aes192-CBC"] && t !== pki.oids["aes256-CBC"] && t !== pki.oids["des-EDE3-CBC"] && t !== pki.oids.desCBC) {
    var o = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
    throw o.oid = t, o.supportedOids = [
      "aes128-CBC",
      "aes192-CBC",
      "aes256-CBC",
      "des-EDE3-CBC",
      "desCBC"
    ], o;
  }
  var a = n.kdfSalt, c = forge$1.util.createBuffer(n.kdfIterationCount);
  c = c.getInt(c.length() << 3);
  var l, u;
  switch (pki.oids[t]) {
    case "aes128-CBC":
      l = 16, u = forge$1.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      l = 24, u = forge$1.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      l = 32, u = forge$1.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      l = 24, u = forge$1.des.createDecryptionCipher;
      break;
    case "desCBC":
      l = 8, u = forge$1.des.createDecryptionCipher;
      break;
  }
  var f = prfOidToMessageDigest(n.prfOid), d = forge$1.pkcs5.pbkdf2(r, a, c, l, f), p = n.encIv, g = u(d);
  return g.start(p), g;
};
pki.pbe.getCipherForPKCS12PBE = function(t, e, r) {
  var n = {}, i = [];
  if (!asn1.validate(e, pkcs12PbeParamsValidator, n, i)) {
    var o = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw o.errors = i, o;
  }
  var a = forge$1.util.createBuffer(n.salt), c = forge$1.util.createBuffer(n.iterations);
  c = c.getInt(c.length() << 3);
  var l, u, f;
  switch (t) {
    case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      l = 24, u = 8, f = forge$1.des.startDecrypting;
      break;
    case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
      l = 5, u = 8, f = function(m, y) {
        var b = forge$1.rc2.createDecryptionCipher(m, 40);
        return b.start(y, null), b;
      };
      break;
    default:
      var o = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
      throw o.oid = t, o;
  }
  var d = prfOidToMessageDigest(n.prfOid), p = pki.pbe.generatePkcs12Key(r, a, 1, c, l, d);
  d.start();
  var g = pki.pbe.generatePkcs12Key(r, a, 2, c, u, d);
  return f(p, g);
};
pki.pbe.opensslDeriveBytes = function(t, e, r, n) {
  if (typeof n > "u" || n === null) {
    if (!("md5" in forge$1.md))
      throw new Error('"md5" hash algorithm unavailable.');
    n = forge$1.md.md5.create();
  }
  e === null && (e = "");
  for (var i = [hash$2(n, t + e)], o = 16, a = 1; o < r; ++a, o += 16)
    i.push(hash$2(n, i[a - 1] + t + e));
  return i.join("").substr(0, r);
};
function hash$2(t, e) {
  return t.start().update(e).digest().getBytes();
}
function prfOidToMessageDigest(t) {
  var e;
  if (!t)
    e = "hmacWithSHA1";
  else if (e = pki.oids[asn1.derToOid(t)], !e) {
    var r = new Error("Unsupported PRF OID.");
    throw r.oid = t, r.supported = [
      "hmacWithSHA1",
      "hmacWithSHA224",
      "hmacWithSHA256",
      "hmacWithSHA384",
      "hmacWithSHA512"
    ], r;
  }
  return prfAlgorithmToMessageDigest(e);
}
function prfAlgorithmToMessageDigest(t) {
  var e = forge$1.md;
  switch (t) {
    case "hmacWithSHA224":
      e = forge$1.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      t = t.substr(8).toLowerCase();
      break;
    default:
      var r = new Error("Unsupported PRF algorithm.");
      throw r.algorithm = t, r.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ], r;
  }
  if (!e || !(t in e))
    throw new Error("Unknown hash algorithm: " + t);
  return e[t].create();
}
function createPbkdf2Params(t, e, r, n) {
  var i = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
    // salt
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      !1,
      t
    ),
    // iteration count
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      !1,
      e.getBytes()
    )
  ]);
  return n !== "hmacWithSHA1" && i.value.push(
    // key length
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      !1,
      forge$1.util.hexToBytes(r.toString(16))
    ),
    // AlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [
      // algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        !1,
        asn1.oidToDer(pki.oids[n]).getBytes()
      ),
      // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")
    ])
  ), i;
}
var pe;
let AbortError$6 = (pe = class extends Error {
  constructor(r = "The operation was aborted") {
    super(r);
    $(this, "code");
    $(this, "type");
    this.code = pe.code, this.type = pe.type;
  }
}, $(pe, "code", "ABORT_ERR"), $(pe, "type", "aborted"), pe), CodeError$2 = class extends Error {
  constructor(r, n, i) {
    super(r);
    $(this, "code");
    $(this, "props");
    this.code = n, this.name = (i == null ? void 0 : i.name) ?? "CodeError", this.props = i ?? {};
  }
};
const Je = class extends Error {
  constructor(r = "Unexpected Peer") {
    super(r);
    $(this, "code");
    this.code = Je.code;
  }
};
let UnexpectedPeerError = Je;
$(UnexpectedPeerError, "code", "ERR_UNEXPECTED_PEER");
const et = class extends Error {
  constructor(r = "Invalid crypto exchange") {
    super(r);
    $(this, "code");
    this.code = et.code;
  }
};
let InvalidCryptoExchangeError = et;
$(InvalidCryptoExchangeError, "code", "ERR_INVALID_CRYPTO_EXCHANGE");
function asUint8Array(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function base$3(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var o = t.charAt(i), a = o.charCodeAt(0);
    if (r[a] !== 255)
      throw new TypeError(o + " is ambiguous");
    r[a] = i;
  }
  var c = t.length, l = t.charAt(0), u = Math.log(c) / Math.log(256), f = Math.log(256) / Math.log(c);
  function d(h) {
    if (h instanceof Uint8Array || (ArrayBuffer.isView(h) ? h = new Uint8Array(h.buffer, h.byteOffset, h.byteLength) : Array.isArray(h) && (h = Uint8Array.from(h))), !(h instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (h.length === 0)
      return "";
    for (var m = 0, y = 0, b = 0, v = h.length; b !== v && h[b] === 0; )
      b++, m++;
    for (var _ = (v - b) * f + 1 >>> 0, E = new Uint8Array(_); b !== v; ) {
      for (var w = h[b], S = 0, x = _ - 1; (w !== 0 || S < y) && x !== -1; x--, S++)
        w += 256 * E[x] >>> 0, E[x] = w % c >>> 0, w = w / c >>> 0;
      if (w !== 0)
        throw new Error("Non-zero carry");
      y = S, b++;
    }
    for (var I = _ - y; I !== _ && E[I] === 0; )
      I++;
    for (var C = l.repeat(m); I < _; ++I)
      C += t.charAt(E[I]);
    return C;
  }
  function p(h) {
    if (typeof h != "string")
      throw new TypeError("Expected String");
    if (h.length === 0)
      return new Uint8Array();
    var m = 0;
    if (h[m] !== " ") {
      for (var y = 0, b = 0; h[m] === l; )
        y++, m++;
      for (var v = (h.length - m) * u + 1 >>> 0, _ = new Uint8Array(v); h[m]; ) {
        var E = r[h.charCodeAt(m)];
        if (E === 255)
          return;
        for (var w = 0, S = v - 1; (E !== 0 || w < b) && S !== -1; S--, w++)
          E += c * _[S] >>> 0, _[S] = E % 256 >>> 0, E = E / 256 >>> 0;
        if (E !== 0)
          throw new Error("Non-zero carry");
        b = w, m++;
      }
      if (h[m] !== " ") {
        for (var x = v - b; x !== v && _[x] === 0; )
          x++;
        for (var I = new Uint8Array(y + (v - x)), C = y; x !== v; )
          I[C++] = _[x++];
        return I;
      }
    }
  }
  function g(h) {
    var m = p(h);
    if (m)
      return m;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: d,
    decodeUnsafe: p,
    decode: g
  };
}
var src$3 = base$3, _brrp__multiformats_scope_baseX$1 = src$3;
const equals$4 = (t, e) => {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}, coerce$1 = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fromString$4 = (t) => new TextEncoder().encode(t), toString$5 = (t) => new TextDecoder().decode(t);
let Encoder$1 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}, Decoder$2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = /** @type {number} */
    r.codePointAt(0), this.baseDecode = n;
  }
  /**
   * @param {string} text
   */
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return or$3(this, e);
  }
}, ComposedDecoder$1 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(e) {
    this.decoders = e;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return or$3(this, e);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(e) {
    const r = (
      /** @type {Prefix} */
      e[0]
    ), n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const or$3 = (t, e) => new ComposedDecoder$1(
  /** @type {Decoders<L|R>} */
  {
    ...t.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      t.prefix
    ]: t },
    ...e.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      e.prefix
    ]: e }
  }
);
let Codec$1 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new Encoder$1(e, r, n), this.decoder = new Decoder$2(e, r, i);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(e) {
    return this.encoder.encode(e);
  }
  /**
   * @param {string} input
   */
  decode(e) {
    return this.decoder.decode(e);
  }
};
const from$5 = ({ name: t, prefix: e, encode: r, decode: n }) => new Codec$1(t, e, r, n), baseX$1 = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = _brrp__multiformats_scope_baseX$1(r, e);
  return from$5({
    prefix: t,
    name: e,
    encode: n,
    /**
     * @param {string} text
     */
    decode: (o) => coerce$1(i(o))
  });
}, decode$e = (t, e, r, n) => {
  const i = {};
  for (let f = 0; f < e.length; ++f)
    i[e[f]] = f;
  let o = t.length;
  for (; t[o - 1] === "="; )
    --o;
  const a = new Uint8Array(o * r / 8 | 0);
  let c = 0, l = 0, u = 0;
  for (let f = 0; f < o; ++f) {
    const d = i[t[f]];
    if (d === void 0)
      throw new SyntaxError(`Non-${n} character`);
    l = l << r | d, c += r, c >= 8 && (c -= 8, a[u++] = 255 & l >> c);
  }
  if (c >= r || 255 & l << 8 - c)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, encode$b = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let o = "", a = 0, c = 0;
  for (let l = 0; l < t.length; ++l)
    for (c = c << 8 | t[l], a += 8; a > r; )
      a -= r, o += e[i & c >> a];
  if (a && (o += e[i & c << r - a]), n)
    for (; o.length * r & 7; )
      o += "=";
  return o;
}, rfc4648$1 = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => from$5({
  prefix: e,
  name: t,
  encode(i) {
    return encode$b(i, n, r);
  },
  decode(i) {
    return decode$e(i, n, r, t);
  }
}), identity$4 = from$5({
  prefix: "\0",
  name: "identity",
  encode: (t) => toString$5(t),
  decode: (t) => fromString$4(t)
}), identityBase$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$4
}, Symbol.toStringTag, { value: "Module" })), base2$2 = rfc4648$1({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), base2$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: base2$2
}, Symbol.toStringTag, { value: "Module" })), base8$2 = rfc4648$1({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), base8$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: base8$2
}, Symbol.toStringTag, { value: "Module" })), base10$2 = baseX$1({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), base10$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: base10$2
}, Symbol.toStringTag, { value: "Module" })), base16$2 = rfc4648$1({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), base16upper$1 = rfc4648$1({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), base16$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: base16$2,
  base16upper: base16upper$1
}, Symbol.toStringTag, { value: "Module" })), base32$2 = rfc4648$1({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), base32upper$1 = rfc4648$1({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), base32pad$1 = rfc4648$1({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), base32padupper$1 = rfc4648$1({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), base32hex$1 = rfc4648$1({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), base32hexupper$1 = rfc4648$1({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), base32hexpad$1 = rfc4648$1({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), base32hexpadupper$1 = rfc4648$1({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), base32z$1 = rfc4648$1({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), base32$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: base32$2,
  base32hex: base32hex$1,
  base32hexpad: base32hexpad$1,
  base32hexpadupper: base32hexpadupper$1,
  base32hexupper: base32hexupper$1,
  base32pad: base32pad$1,
  base32padupper: base32padupper$1,
  base32upper: base32upper$1,
  base32z: base32z$1
}, Symbol.toStringTag, { value: "Module" })), base36$2 = baseX$1({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), base36upper$1 = baseX$1({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), base36$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: base36$2,
  base36upper: base36upper$1
}, Symbol.toStringTag, { value: "Module" })), base58btc$1 = baseX$1({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), base58flickr$1 = baseX$1({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), base58$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: base58btc$1,
  base58flickr: base58flickr$1
}, Symbol.toStringTag, { value: "Module" })), base64$5 = rfc4648$1({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), base64pad$1 = rfc4648$1({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), base64url$1 = rfc4648$1({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), base64urlpad$1 = rfc4648$1({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), base64$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$5,
  base64pad: base64pad$1,
  base64url: base64url$1,
  base64urlpad: base64urlpad$1
}, Symbol.toStringTag, { value: "Module" })), alphabet$1 = Array.from(""), alphabetBytesToChars$1 = (
  /** @type {string[]} */
  alphabet$1.reduce(
    (t, e, r) => (t[r] = e, t),
    /** @type {string[]} */
    []
  )
), alphabetCharsToBytes$1 = (
  /** @type {number[]} */
  alphabet$1.reduce(
    (t, e, r) => (t[
      /** @type {number} */
      e.codePointAt(0)
    ] = r, t),
    /** @type {number[]} */
    []
  )
);
function encode$a(t) {
  return t.reduce((e, r) => (e += alphabetBytesToChars$1[r], e), "");
}
function decode$d(t) {
  const e = [];
  for (const r of t) {
    const n = alphabetCharsToBytes$1[
      /** @type {number} */
      r.codePointAt(0)
    ];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const base256emoji$2 = from$5({
  prefix: "",
  name: "base256emoji",
  encode: encode$a,
  decode: decode$d
}), base256emoji$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: base256emoji$2
}, Symbol.toStringTag, { value: "Module" }));
var encode_1$2 = encode$9, MSB$4 = 128, REST$4 = 127, MSBALL$2 = ~REST$4, INT$2 = Math.pow(2, 31);
function encode$9(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= INT$2; )
    e[r++] = t & 255 | MSB$4, t /= 128;
  for (; t & MSBALL$2; )
    e[r++] = t & 255 | MSB$4, t >>>= 7;
  return e[r] = t | 0, encode$9.bytes = r - n + 1, e;
}
var decode$c = read$3, MSB$1$2 = 128, REST$1$2 = 127;
function read$3(t, n) {
  var r = 0, n = n || 0, i = 0, o = n, a, c = t.length;
  do {
    if (o >= c)
      throw read$3.bytes = 0, new RangeError("Could not decode varint");
    a = t[o++], r += i < 28 ? (a & REST$1$2) << i : (a & REST$1$2) * Math.pow(2, i), i += 7;
  } while (a >= MSB$1$2);
  return read$3.bytes = o - n, r;
}
var N1$3 = Math.pow(2, 7), N2$3 = Math.pow(2, 14), N3$3 = Math.pow(2, 21), N4$3 = Math.pow(2, 28), N5$3 = Math.pow(2, 35), N6$3 = Math.pow(2, 42), N7$3 = Math.pow(2, 49), N8$2 = Math.pow(2, 56), N9$2 = Math.pow(2, 63), length$2 = function(t) {
  return t < N1$3 ? 1 : t < N2$3 ? 2 : t < N3$3 ? 3 : t < N4$3 ? 4 : t < N5$3 ? 5 : t < N6$3 ? 6 : t < N7$3 ? 7 : t < N8$2 ? 8 : t < N9$2 ? 9 : 10;
}, varint$2 = {
  encode: encode_1$2,
  decode: decode$c,
  encodingLength: length$2
}, _brrp_varint$1 = varint$2;
const decode$b = (t, e = 0) => [_brrp_varint$1.decode(t, e), _brrp_varint$1.decode.bytes], encodeTo$1 = (t, e, r = 0) => (_brrp_varint$1.encode(t, e, r), e), encodingLength$2 = (t) => _brrp_varint$1.encodingLength(t), create$6 = (t, e) => {
  const r = e.byteLength, n = encodingLength$2(t), i = n + encodingLength$2(r), o = new Uint8Array(i + r);
  return encodeTo$1(t, o, 0), encodeTo$1(r, o, n), o.set(e, i), new Digest$1(t, r, e, o);
}, decode$a = (t) => {
  const e = coerce$1(t), [r, n] = decode$b(e), [i, o] = decode$b(e.subarray(n)), a = e.subarray(n + o);
  if (a.byteLength !== i)
    throw new Error("Incorrect length");
  return new Digest$1(r, i, a, e);
}, equals$3 = (t, e) => {
  if (t === e)
    return !0;
  {
    const r = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      e
    );
    return t.code === r.code && t.size === r.size && r.bytes instanceof Uint8Array && equals$4(t.bytes, r.bytes);
  }
};
let Digest$1 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(e, r, n, i) {
    this.code = e, this.size = r, this.digest = n, this.bytes = i;
  }
};
const from$4 = ({ name: t, code: e, encode: r }) => new Hasher$1(t, e, r);
let Hasher$1 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(e, r, n) {
    this.name = e, this.code = r, this.encode = n;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? create$6(this.code, r) : r.then((n) => create$6(this.code, n));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
const sha256$2 = from$4({
  name: "sha2-256",
  code: 18,
  encode: (t) => coerce$1(crypto$3.createHash("sha256").update(t).digest())
}), code = 0, name = "identity", encode$8 = coerce$1, digest = (t) => create$6(code, encode$8(t)), identity$3 = { code, name, encode: encode$8, digest };
new TextEncoder();
new TextDecoder();
const format$6 = (t, e) => {
  const { bytes: r, version: n } = t;
  switch (n) {
    case 0:
      return toStringV0$1(
        r,
        baseCache$1(t),
        /** @type {API.MultibaseEncoder<"z">} */
        e || base58btc$1.encoder
      );
    default:
      return toStringV1$1(
        r,
        baseCache$1(t),
        /** @type {API.MultibaseEncoder<Prefix>} */
        e || base32$2.encoder
      );
  }
}, cache$1 = /* @__PURE__ */ new WeakMap(), baseCache$1 = (t) => {
  const e = cache$1.get(t);
  if (e == null) {
    const r = /* @__PURE__ */ new Map();
    return cache$1.set(t, r), r;
  }
  return e;
};
let CID$1 = class te {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(e, r, n, i) {
    this.code = r, this.version = e, this.multihash = n, this.bytes = i, this["/"] = i;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0:
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      case 1: {
        const { code: e, multihash: r } = this;
        if (e !== DAG_PB_CODE$1)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (r.code !== SHA_256_CODE$1)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          te.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            r
          )
        );
      }
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: r } = this.multihash, n = create$6(e, r);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          te.createV1(this.code, n)
        );
      }
      case 1:
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(e) {
    return te.equals(this, e);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(e, r) {
    const n = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      r
    );
    return n && e.code === n.code && e.version === n.version && equals$3(e.multihash, n.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(e) {
    return format$6(this, e);
  }
  toJSON() {
    return { "/": format$6(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(e) {
    if (e == null)
      return null;
    const r = (
      /** @type {any} */
      e
    );
    if (r instanceof te)
      return r;
    if (r["/"] != null && r["/"] === r.bytes || r.asCID === r) {
      const { version: n, code: i, multihash: o, bytes: a } = r;
      return new te(
        n,
        i,
        /** @type {API.MultihashDigest<Alg>} */
        o,
        a || encodeCID$1(n, i, o.bytes)
      );
    } else if (r[cidSymbol$1] === !0) {
      const { version: n, multihash: i, code: o } = r, a = (
        /** @type {API.MultihashDigest<Alg>} */
        decode$a(i)
      );
      return te.create(n, o, a);
    } else
      return null;
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(e, r, n) {
    if (typeof r != "number")
      throw new Error("String codecs are no longer supported");
    if (!(n.bytes instanceof Uint8Array))
      throw new Error("Invalid digest");
    switch (e) {
      case 0: {
        if (r !== DAG_PB_CODE$1)
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$1}) block encoding`
          );
        return new te(e, r, n, n.bytes);
      }
      case 1: {
        const i = encodeCID$1(e, r, n.bytes);
        return new te(e, r, n, i);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(e) {
    return te.create(0, DAG_PB_CODE$1, e);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(e, r) {
    return te.create(1, e, r);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(e) {
    const [r, n] = te.decodeFirst(e);
    if (n.length)
      throw new Error("Incorrect length");
    return r;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(e) {
    const r = te.inspectBytes(e), n = r.size - r.multihashSize, i = coerce$1(
      e.subarray(n, n + r.multihashSize)
    );
    if (i.byteLength !== r.multihashSize)
      throw new Error("Incorrect length");
    const o = i.subarray(
      r.multihashSize - r.digestSize
    ), a = new Digest$1(
      r.multihashCode,
      r.digestSize,
      o,
      i
    );
    return [r.version === 0 ? te.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      a
    ) : te.createV1(r.codec, a), e.subarray(r.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(e) {
    let r = 0;
    const n = () => {
      const [d, p] = decode$b(e.subarray(r));
      return r += p, d;
    };
    let i = (
      /** @type {V} */
      n()
    ), o = (
      /** @type {C} */
      DAG_PB_CODE$1
    );
    if (/** @type {number} */
    i === 18 ? (i = /** @type {V} */
    0, r = 0) : o = /** @type {C} */
    n(), i !== 0 && i !== 1)
      throw new RangeError(`Invalid CID version ${i}`);
    const a = r, c = (
      /** @type {A} */
      n()
    ), l = n(), u = r + l, f = u - a;
    return { version: i, codec: o, multihashCode: c, digestSize: l, multihashSize: f, size: u };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(e, r) {
    const [n, i] = parseCIDtoBytes$1(e, r), o = te.decode(i);
    if (o.version === 0 && e[0] !== "Q")
      throw Error("Version 0 CID string must not include multibase prefix");
    return baseCache$1(o).set(n, e), o;
  }
};
const parseCIDtoBytes$1 = (t, e) => {
  switch (t[0]) {
    case "Q": {
      const r = e || base58btc$1;
      return [
        /** @type {Prefix} */
        base58btc$1.prefix,
        r.decode(`${base58btc$1.prefix}${t}`)
      ];
    }
    case base58btc$1.prefix: {
      const r = e || base58btc$1;
      return [
        /** @type {Prefix} */
        base58btc$1.prefix,
        r.decode(t)
      ];
    }
    case base32$2.prefix: {
      const r = e || base32$2;
      return [
        /** @type {Prefix} */
        base32$2.prefix,
        r.decode(t)
      ];
    }
    default: {
      if (e == null)
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      return [
        /** @type {Prefix} */
        t[0],
        e.decode(t)
      ];
    }
  }
}, toStringV0$1 = (t, e, r) => {
  const { prefix: n } = r;
  if (n !== base58btc$1.prefix)
    throw Error(`Cannot string encode V0 in ${r.name} encoding`);
  const i = e.get(n);
  if (i == null) {
    const o = r.encode(t).slice(1);
    return e.set(n, o), o;
  } else
    return i;
}, toStringV1$1 = (t, e, r) => {
  const { prefix: n } = r, i = e.get(n);
  if (i == null) {
    const o = r.encode(t);
    return e.set(n, o), o;
  } else
    return i;
}, DAG_PB_CODE$1 = 112, SHA_256_CODE$1 = 18, encodeCID$1 = (t, e, r) => {
  const n = encodingLength$2(t), i = n + encodingLength$2(e), o = new Uint8Array(i + r.byteLength);
  return encodeTo$1(t, o, 0), encodeTo$1(e, o, n), o.set(r, i), o;
}, cidSymbol$1 = Symbol.for("@ipld/js-cid/CID"), bases$1 = { ...identityBase$1, ...base2$3, ...base8$3, ...base10$3, ...base16$3, ...base32$3, ...base36$3, ...base58$1, ...base64$6, ...base256emoji$3 };
function allocUnsafe$1(t = 0) {
  var e;
  return ((e = globalThis.Buffer) == null ? void 0 : e.allocUnsafe) != null ? asUint8Array(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function createCodec$3(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: {
      decode: n
    }
  };
}
const string$1 = createCodec$3("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), ascii$1 = createCodec$3("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = allocUnsafe$1(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), BASES$1 = {
  utf8: string$1,
  "utf-8": string$1,
  hex: bases$1.base16,
  latin1: ascii$1,
  ascii: ascii$1,
  binary: ascii$1,
  ...bases$1
};
function fromString$3(t, e = "utf8") {
  const r = BASES$1[e];
  if (r == null)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? asUint8Array(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
function equals$2(t, e) {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function toString$4(t, e = "utf8") {
  const r = BASES$1[e];
  if (r == null)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
const keypair$1 = promisify(crypto$3.generateKeyPair), PUBLIC_KEY_BYTE_LENGTH = 32, PRIVATE_KEY_BYTE_LENGTH = 64, KEYS_BYTE_LENGTH = 32, SIGNATURE_BYTE_LENGTH = 64;
function derivePublicKey(t) {
  const r = crypto$3.createPrivateKey({
    format: "jwk",
    key: {
      crv: "Ed25519",
      x: "",
      d: toString$4(t, "base64url"),
      kty: "OKP"
    }
  }).export({
    format: "jwk"
  });
  if (r.x == null || r.x === "")
    throw new Error("Could not export JWK public key");
  return fromString$3(r.x, "base64url");
}
async function generateKey$2() {
  const t = await keypair$1("ed25519", {
    publicKeyEncoding: { type: "spki", format: "jwk" },
    privateKeyEncoding: { type: "pkcs8", format: "jwk" }
  }), e = fromString$3(t.privateKey.d, "base64url"), r = fromString$3(t.privateKey.x, "base64url");
  return {
    privateKey: concatKeys(e, r),
    publicKey: r
  };
}
async function generateKeyFromSeed(t) {
  if (t.length !== KEYS_BYTE_LENGTH)
    throw new TypeError('"seed" must be 32 bytes in length.');
  if (!(t instanceof Uint8Array))
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  const e = derivePublicKey(t);
  return {
    privateKey: concatKeys(t, e),
    publicKey: e
  };
}
async function hashAndSign$2(t, e) {
  if (!(t instanceof Uint8Array))
    throw new TypeError('"key" must be a node.js Buffer, or Uint8Array.');
  let r, n;
  if (t.byteLength === PRIVATE_KEY_BYTE_LENGTH)
    r = t.subarray(0, 32), n = t.subarray(32);
  else if (t.byteLength === KEYS_BYTE_LENGTH)
    r = t.subarray(0, 32), n = derivePublicKey(r);
  else
    throw new TypeError('"key" must be 64 or 32 bytes in length.');
  const i = crypto$3.createPrivateKey({
    format: "jwk",
    key: {
      crv: "Ed25519",
      d: toString$4(r, "base64url"),
      x: toString$4(n, "base64url"),
      kty: "OKP"
    }
  });
  return crypto$3.sign(null, e, i);
}
async function hashAndVerify$2(t, e, r) {
  if (t.byteLength !== PUBLIC_KEY_BYTE_LENGTH)
    throw new TypeError('"key" must be 32 bytes in length.');
  if (!(t instanceof Uint8Array))
    throw new TypeError('"key" must be a node.js Buffer, or Uint8Array.');
  if (e.byteLength !== SIGNATURE_BYTE_LENGTH)
    throw new TypeError('"sig" must be 64 bytes in length.');
  if (!(e instanceof Uint8Array))
    throw new TypeError('"sig" must be a node.js Buffer, or Uint8Array.');
  const n = crypto$3.createPublicKey({
    format: "jwk",
    key: {
      crv: "Ed25519",
      x: toString$4(t, "base64url"),
      kty: "OKP"
    }
  });
  return crypto$3.verify(null, r, n, e);
}
function concatKeys(t, e) {
  const r = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let n = 0; n < KEYS_BYTE_LENGTH; n++)
    r[n] = t[n], r[KEYS_BYTE_LENGTH + n] = e[n];
  return r;
}
function concat$6(t, e) {
  e == null && (e = t.reduce((i, o) => i + o.length, 0));
  const r = allocUnsafe$1(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return asUint8Array(r);
}
function create$5(t) {
  const e = (t == null ? void 0 : t.algorithm) ?? "aes-128-gcm", r = (t == null ? void 0 : t.keyLength) ?? 16, n = (t == null ? void 0 : t.nonceLength) ?? 12, i = (t == null ? void 0 : t.digest) ?? "sha256", o = (t == null ? void 0 : t.saltLength) ?? 16, a = (t == null ? void 0 : t.iterations) ?? 32767, c = (t == null ? void 0 : t.algorithmTagLength) ?? 16;
  async function l(g, h) {
    const m = crypto$3.randomBytes(n), y = crypto$3.createCipheriv(e, h, m), b = concat$6([y.update(g), y.final()]);
    return concat$6([m, b, y.getAuthTag()]);
  }
  async function u(g, h) {
    const m = crypto$3.randomBytes(o);
    typeof h == "string" && (h = fromString$3(h));
    const y = crypto$3.pbkdf2Sync(h, m, a, r, i);
    return concat$6([m, await l(Uint8Array.from(g), y)]);
  }
  async function f(g, h) {
    const m = g.subarray(0, n), y = g.subarray(n, g.length - c), b = g.subarray(y.length + n), v = crypto$3.createDecipheriv(e, h, m);
    return v.setAuthTag(b), concat$6([v.update(y), v.final()]);
  }
  async function d(g, h) {
    const m = g.subarray(0, o), y = g.subarray(o);
    typeof h == "string" && (h = fromString$3(h));
    const b = crypto$3.pbkdf2Sync(h, m, a, r, i);
    return f(y, b);
  }
  return {
    encrypt: u,
    decrypt: d
  };
}
async function exporter(t, e) {
  const n = await create$5().encrypt(t, e);
  return base64$5.encode(n);
}
var minimal$1 = {}, aspromise = asPromise;
function asPromise(t, e) {
  for (var r = new Array(arguments.length - 1), n = 0, i = 2, o = !0; i < arguments.length; )
    r[n++] = arguments[i++];
  return new Promise(function(c, l) {
    r[n] = function(f) {
      if (o)
        if (o = !1, f)
          l(f);
        else {
          for (var d = new Array(arguments.length - 1), p = 0; p < d.length; )
            d[p++] = arguments[p];
          c.apply(null, d);
        }
    };
    try {
      t.apply(e || null, r);
    } catch (u) {
      o && (o = !1, l(u));
    }
  });
}
var base64$4 = {};
(function(t) {
  var e = t;
  e.length = function(c) {
    var l = c.length;
    if (!l)
      return 0;
    for (var u = 0; --l % 4 > 1 && c.charAt(l) === "="; )
      ++u;
    return Math.ceil(c.length * 3) / 4 - u;
  };
  for (var r = new Array(64), n = new Array(123), i = 0; i < 64; )
    n[r[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
  e.encode = function(c, l, u) {
    for (var f = null, d = [], p = 0, g = 0, h; l < u; ) {
      var m = c[l++];
      switch (g) {
        case 0:
          d[p++] = r[m >> 2], h = (m & 3) << 4, g = 1;
          break;
        case 1:
          d[p++] = r[h | m >> 4], h = (m & 15) << 2, g = 2;
          break;
        case 2:
          d[p++] = r[h | m >> 6], d[p++] = r[m & 63], g = 0;
          break;
      }
      p > 8191 && ((f || (f = [])).push(String.fromCharCode.apply(String, d)), p = 0);
    }
    return g && (d[p++] = r[h], d[p++] = 61, g === 1 && (d[p++] = 61)), f ? (p && f.push(String.fromCharCode.apply(String, d.slice(0, p))), f.join("")) : String.fromCharCode.apply(String, d.slice(0, p));
  };
  var o = "invalid encoding";
  e.decode = function(c, l, u) {
    for (var f = u, d = 0, p, g = 0; g < c.length; ) {
      var h = c.charCodeAt(g++);
      if (h === 61 && d > 1)
        break;
      if ((h = n[h]) === void 0)
        throw Error(o);
      switch (d) {
        case 0:
          p = h, d = 1;
          break;
        case 1:
          l[u++] = p << 2 | (h & 48) >> 4, p = h, d = 2;
          break;
        case 2:
          l[u++] = (p & 15) << 4 | (h & 60) >> 2, p = h, d = 3;
          break;
        case 3:
          l[u++] = (p & 3) << 6 | h, d = 0;
          break;
      }
    }
    if (d === 1)
      throw Error(o);
    return u - f;
  }, e.test = function(c) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(c);
  };
})(base64$4);
var eventemitter = EventEmitter$3;
function EventEmitter$3() {
  this._listeners = {};
}
EventEmitter$3.prototype.on = function(e, r, n) {
  return (this._listeners[e] || (this._listeners[e] = [])).push({
    fn: r,
    ctx: n || this
  }), this;
};
EventEmitter$3.prototype.off = function(e, r) {
  if (e === void 0)
    this._listeners = {};
  else if (r === void 0)
    this._listeners[e] = [];
  else
    for (var n = this._listeners[e], i = 0; i < n.length; )
      n[i].fn === r ? n.splice(i, 1) : ++i;
  return this;
};
EventEmitter$3.prototype.emit = function(e) {
  var r = this._listeners[e];
  if (r) {
    for (var n = [], i = 1; i < arguments.length; )
      n.push(arguments[i++]);
    for (i = 0; i < r.length; )
      r[i].fn.apply(r[i++].ctx, n);
  }
  return this;
};
var float = factory(factory);
function factory(t) {
  return typeof Float32Array < "u" ? function() {
    var e = new Float32Array([-0]), r = new Uint8Array(e.buffer), n = r[3] === 128;
    function i(l, u, f) {
      e[0] = l, u[f] = r[0], u[f + 1] = r[1], u[f + 2] = r[2], u[f + 3] = r[3];
    }
    function o(l, u, f) {
      e[0] = l, u[f] = r[3], u[f + 1] = r[2], u[f + 2] = r[1], u[f + 3] = r[0];
    }
    t.writeFloatLE = n ? i : o, t.writeFloatBE = n ? o : i;
    function a(l, u) {
      return r[0] = l[u], r[1] = l[u + 1], r[2] = l[u + 2], r[3] = l[u + 3], e[0];
    }
    function c(l, u) {
      return r[3] = l[u], r[2] = l[u + 1], r[1] = l[u + 2], r[0] = l[u + 3], e[0];
    }
    t.readFloatLE = n ? a : c, t.readFloatBE = n ? c : a;
  }() : function() {
    function e(n, i, o, a) {
      var c = i < 0 ? 1 : 0;
      if (c && (i = -i), i === 0)
        n(1 / i > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), o, a);
      else if (isNaN(i))
        n(2143289344, o, a);
      else if (i > 34028234663852886e22)
        n((c << 31 | 2139095040) >>> 0, o, a);
      else if (i < 11754943508222875e-54)
        n((c << 31 | Math.round(i / 1401298464324817e-60)) >>> 0, o, a);
      else {
        var l = Math.floor(Math.log(i) / Math.LN2), u = Math.round(i * Math.pow(2, -l) * 8388608) & 8388607;
        n((c << 31 | l + 127 << 23 | u) >>> 0, o, a);
      }
    }
    t.writeFloatLE = e.bind(null, writeUintLE), t.writeFloatBE = e.bind(null, writeUintBE);
    function r(n, i, o) {
      var a = n(i, o), c = (a >> 31) * 2 + 1, l = a >>> 23 & 255, u = a & 8388607;
      return l === 255 ? u ? NaN : c * (1 / 0) : l === 0 ? c * 1401298464324817e-60 * u : c * Math.pow(2, l - 150) * (u + 8388608);
    }
    t.readFloatLE = r.bind(null, readUintLE), t.readFloatBE = r.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var e = new Float64Array([-0]), r = new Uint8Array(e.buffer), n = r[7] === 128;
    function i(l, u, f) {
      e[0] = l, u[f] = r[0], u[f + 1] = r[1], u[f + 2] = r[2], u[f + 3] = r[3], u[f + 4] = r[4], u[f + 5] = r[5], u[f + 6] = r[6], u[f + 7] = r[7];
    }
    function o(l, u, f) {
      e[0] = l, u[f] = r[7], u[f + 1] = r[6], u[f + 2] = r[5], u[f + 3] = r[4], u[f + 4] = r[3], u[f + 5] = r[2], u[f + 6] = r[1], u[f + 7] = r[0];
    }
    t.writeDoubleLE = n ? i : o, t.writeDoubleBE = n ? o : i;
    function a(l, u) {
      return r[0] = l[u], r[1] = l[u + 1], r[2] = l[u + 2], r[3] = l[u + 3], r[4] = l[u + 4], r[5] = l[u + 5], r[6] = l[u + 6], r[7] = l[u + 7], e[0];
    }
    function c(l, u) {
      return r[7] = l[u], r[6] = l[u + 1], r[5] = l[u + 2], r[4] = l[u + 3], r[3] = l[u + 4], r[2] = l[u + 5], r[1] = l[u + 6], r[0] = l[u + 7], e[0];
    }
    t.readDoubleLE = n ? a : c, t.readDoubleBE = n ? c : a;
  }() : function() {
    function e(n, i, o, a, c, l) {
      var u = a < 0 ? 1 : 0;
      if (u && (a = -a), a === 0)
        n(0, c, l + i), n(1 / a > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), c, l + o);
      else if (isNaN(a))
        n(0, c, l + i), n(2146959360, c, l + o);
      else if (a > 17976931348623157e292)
        n(0, c, l + i), n((u << 31 | 2146435072) >>> 0, c, l + o);
      else {
        var f;
        if (a < 22250738585072014e-324)
          f = a / 5e-324, n(f >>> 0, c, l + i), n((u << 31 | f / 4294967296) >>> 0, c, l + o);
        else {
          var d = Math.floor(Math.log(a) / Math.LN2);
          d === 1024 && (d = 1023), f = a * Math.pow(2, -d), n(f * 4503599627370496 >>> 0, c, l + i), n((u << 31 | d + 1023 << 20 | f * 1048576 & 1048575) >>> 0, c, l + o);
        }
      }
    }
    t.writeDoubleLE = e.bind(null, writeUintLE, 0, 4), t.writeDoubleBE = e.bind(null, writeUintBE, 4, 0);
    function r(n, i, o, a, c) {
      var l = n(a, c + i), u = n(a, c + o), f = (u >> 31) * 2 + 1, d = u >>> 20 & 2047, p = 4294967296 * (u & 1048575) + l;
      return d === 2047 ? p ? NaN : f * (1 / 0) : d === 0 ? f * 5e-324 * p : f * Math.pow(2, d - 1075) * (p + 4503599627370496);
    }
    t.readDoubleLE = r.bind(null, readUintLE, 0, 4), t.readDoubleBE = r.bind(null, readUintBE, 4, 0);
  }(), t;
}
function writeUintLE(t, e, r) {
  e[r] = t & 255, e[r + 1] = t >>> 8 & 255, e[r + 2] = t >>> 16 & 255, e[r + 3] = t >>> 24;
}
function writeUintBE(t, e, r) {
  e[r] = t >>> 24, e[r + 1] = t >>> 16 & 255, e[r + 2] = t >>> 8 & 255, e[r + 3] = t & 255;
}
function readUintLE(t, e) {
  return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0;
}
function readUintBE(t, e) {
  return (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (t) {
  }
  return null;
}
var utf8$4 = {};
(function(t) {
  var e = t;
  e.length = function(n) {
    for (var i = 0, o = 0, a = 0; a < n.length; ++a)
      o = n.charCodeAt(a), o < 128 ? i += 1 : o < 2048 ? i += 2 : (o & 64512) === 55296 && (n.charCodeAt(a + 1) & 64512) === 56320 ? (++a, i += 4) : i += 3;
    return i;
  }, e.read = function(n, i, o) {
    var a = o - i;
    if (a < 1)
      return "";
    for (var c = null, l = [], u = 0, f; i < o; )
      f = n[i++], f < 128 ? l[u++] = f : f > 191 && f < 224 ? l[u++] = (f & 31) << 6 | n[i++] & 63 : f > 239 && f < 365 ? (f = ((f & 7) << 18 | (n[i++] & 63) << 12 | (n[i++] & 63) << 6 | n[i++] & 63) - 65536, l[u++] = 55296 + (f >> 10), l[u++] = 56320 + (f & 1023)) : l[u++] = (f & 15) << 12 | (n[i++] & 63) << 6 | n[i++] & 63, u > 8191 && ((c || (c = [])).push(String.fromCharCode.apply(String, l)), u = 0);
    return c ? (u && c.push(String.fromCharCode.apply(String, l.slice(0, u))), c.join("")) : String.fromCharCode.apply(String, l.slice(0, u));
  }, e.write = function(n, i, o) {
    for (var a = o, c, l, u = 0; u < n.length; ++u)
      c = n.charCodeAt(u), c < 128 ? i[o++] = c : c < 2048 ? (i[o++] = c >> 6 | 192, i[o++] = c & 63 | 128) : (c & 64512) === 55296 && ((l = n.charCodeAt(u + 1)) & 64512) === 56320 ? (c = 65536 + ((c & 1023) << 10) + (l & 1023), ++u, i[o++] = c >> 18 | 240, i[o++] = c >> 12 & 63 | 128, i[o++] = c >> 6 & 63 | 128, i[o++] = c & 63 | 128) : (i[o++] = c >> 12 | 224, i[o++] = c >> 6 & 63 | 128, i[o++] = c & 63 | 128);
    return o - a;
  };
})(utf8$4);
var pool_1 = pool$1;
function pool$1(t, e, r) {
  var n = r || 8192, i = n >>> 1, o = null, a = n;
  return function(l) {
    if (l < 1 || l > i)
      return t(l);
    a + l > n && (o = t(n), a = 0);
    var u = e.call(o, a, a += l);
    return a & 7 && (a = (a | 7) + 1), u;
  };
}
var longbits$1, hasRequiredLongbits$1;
function requireLongbits$1() {
  if (hasRequiredLongbits$1)
    return longbits$1;
  hasRequiredLongbits$1 = 1, longbits$1 = e;
  var t = requireMinimal$1();
  function e(o, a) {
    this.lo = o >>> 0, this.hi = a >>> 0;
  }
  var r = e.zero = new e(0, 0);
  r.toNumber = function() {
    return 0;
  }, r.zzEncode = r.zzDecode = function() {
    return this;
  }, r.length = function() {
    return 1;
  };
  var n = e.zeroHash = "\0\0\0\0\0\0\0\0";
  e.fromNumber = function(a) {
    if (a === 0)
      return r;
    var c = a < 0;
    c && (a = -a);
    var l = a >>> 0, u = (a - l) / 4294967296 >>> 0;
    return c && (u = ~u >>> 0, l = ~l >>> 0, ++l > 4294967295 && (l = 0, ++u > 4294967295 && (u = 0))), new e(l, u);
  }, e.from = function(a) {
    if (typeof a == "number")
      return e.fromNumber(a);
    if (t.isString(a))
      if (t.Long)
        a = t.Long.fromString(a);
      else
        return e.fromNumber(parseInt(a, 10));
    return a.low || a.high ? new e(a.low >>> 0, a.high >>> 0) : r;
  }, e.prototype.toNumber = function(a) {
    if (!a && this.hi >>> 31) {
      var c = ~this.lo + 1 >>> 0, l = ~this.hi >>> 0;
      return c || (l = l + 1 >>> 0), -(c + l * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, e.prototype.toLong = function(a) {
    return t.Long ? new t.Long(this.lo | 0, this.hi | 0, Boolean(a)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(a) };
  };
  var i = String.prototype.charCodeAt;
  return e.fromHash = function(a) {
    return a === n ? r : new e(
      (i.call(a, 0) | i.call(a, 1) << 8 | i.call(a, 2) << 16 | i.call(a, 3) << 24) >>> 0,
      (i.call(a, 4) | i.call(a, 5) << 8 | i.call(a, 6) << 16 | i.call(a, 7) << 24) >>> 0
    );
  }, e.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, e.prototype.zzEncode = function() {
    var a = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ a) >>> 0, this.lo = (this.lo << 1 ^ a) >>> 0, this;
  }, e.prototype.zzDecode = function() {
    var a = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ a) >>> 0, this.hi = (this.hi >>> 1 ^ a) >>> 0, this;
  }, e.prototype.length = function() {
    var a = this.lo, c = (this.lo >>> 28 | this.hi << 4) >>> 0, l = this.hi >>> 24;
    return l === 0 ? c === 0 ? a < 16384 ? a < 128 ? 1 : 2 : a < 2097152 ? 3 : 4 : c < 16384 ? c < 128 ? 5 : 6 : c < 2097152 ? 7 : 8 : l < 128 ? 9 : 10;
  }, longbits$1;
}
var hasRequiredMinimal$1;
function requireMinimal$1() {
  return hasRequiredMinimal$1 || (hasRequiredMinimal$1 = 1, function(t) {
    var e = t;
    e.asPromise = aspromise, e.base64 = base64$4, e.EventEmitter = eventemitter, e.float = float, e.inquire = inquire_1, e.utf8 = utf8$4, e.pool = pool_1, e.LongBits = requireLongbits$1(), e.isNode = Boolean(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), e.global = e.isNode && commonjsGlobal || typeof window < "u" && window || typeof self$1 < "u" && self$1 || commonjsGlobal, e.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), e.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), e.isInteger = Number.isInteger || /* istanbul ignore next */
    function(o) {
      return typeof o == "number" && isFinite(o) && Math.floor(o) === o;
    }, e.isString = function(o) {
      return typeof o == "string" || o instanceof String;
    }, e.isObject = function(o) {
      return o && typeof o == "object";
    }, e.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    e.isSet = function(o, a) {
      var c = o[a];
      return c != null && o.hasOwnProperty(a) ? typeof c != "object" || (Array.isArray(c) ? c.length : Object.keys(c).length) > 0 : !1;
    }, e.Buffer = function() {
      try {
        var i = e.inquire("buffer").Buffer;
        return i.prototype.utf8Write ? i : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), e._Buffer_from = null, e._Buffer_allocUnsafe = null, e.newBuffer = function(o) {
      return typeof o == "number" ? e.Buffer ? e._Buffer_allocUnsafe(o) : new e.Array(o) : e.Buffer ? e._Buffer_from(o) : typeof Uint8Array > "u" ? o : new Uint8Array(o);
    }, e.Array = typeof Uint8Array < "u" ? Uint8Array : Array, e.Long = /* istanbul ignore next */
    e.global.dcodeIO && /* istanbul ignore next */
    e.global.dcodeIO.Long || /* istanbul ignore next */
    e.global.Long || e.inquire("long"), e.key2Re = /^true|false|0|1$/, e.key32Re = /^-?(?:0|[1-9][0-9]*)$/, e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, e.longToHash = function(o) {
      return o ? e.LongBits.from(o).toHash() : e.LongBits.zeroHash;
    }, e.longFromHash = function(o, a) {
      var c = e.LongBits.fromHash(o);
      return e.Long ? e.Long.fromBits(c.lo, c.hi, a) : c.toNumber(Boolean(a));
    };
    function r(i, o, a) {
      for (var c = Object.keys(o), l = 0; l < c.length; ++l)
        (i[c[l]] === void 0 || !a) && (i[c[l]] = o[c[l]]);
      return i;
    }
    e.merge = r, e.lcFirst = function(o) {
      return o.charAt(0).toLowerCase() + o.substring(1);
    };
    function n(i) {
      function o(a, c) {
        if (!(this instanceof o))
          return new o(a, c);
        Object.defineProperty(this, "message", { get: function() {
          return a;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, o) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), c && r(this, c);
      }
      return o.prototype = Object.create(Error.prototype, {
        constructor: {
          value: o,
          writable: !0,
          enumerable: !1,
          configurable: !0
        },
        name: {
          get: function() {
            return i;
          },
          set: void 0,
          enumerable: !1,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: !0
        },
        toString: {
          value: function() {
            return this.name + ": " + this.message;
          },
          writable: !0,
          enumerable: !1,
          configurable: !0
        }
      }), o;
    }
    e.newError = n, e.ProtocolError = n("ProtocolError"), e.oneOfGetter = function(o) {
      for (var a = {}, c = 0; c < o.length; ++c)
        a[o[c]] = 1;
      return function() {
        for (var l = Object.keys(this), u = l.length - 1; u > -1; --u)
          if (a[l[u]] === 1 && this[l[u]] !== void 0 && this[l[u]] !== null)
            return l[u];
      };
    }, e.oneOfSetter = function(o) {
      return function(a) {
        for (var c = 0; c < o.length; ++c)
          o[c] !== a && delete this[o[c]];
      };
    }, e.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, e._configure = function() {
      var i = e.Buffer;
      if (!i) {
        e._Buffer_from = e._Buffer_allocUnsafe = null;
        return;
      }
      e._Buffer_from = i.from !== Uint8Array.from && i.from || /* istanbul ignore next */
      function(a, c) {
        return new i(a, c);
      }, e._Buffer_allocUnsafe = i.allocUnsafe || /* istanbul ignore next */
      function(a) {
        return new i(a);
      };
    };
  }(minimal$1)), minimal$1;
}
var reader$4 = Reader$3, util$9 = requireMinimal$1(), BufferReader$3, LongBits$3 = util$9.LongBits, utf8$3 = util$9.utf8;
function indexOutOfRange$1(t, e) {
  return RangeError("index out of range: " + t.pos + " + " + (e || 1) + " > " + t.len);
}
function Reader$3(t) {
  this.buf = t, this.pos = 0, this.len = t.length;
}
var create_array$1 = typeof Uint8Array < "u" ? function t(e) {
  if (e instanceof Uint8Array || Array.isArray(e))
    return new Reader$3(e);
  throw Error("illegal buffer");
} : function t(e) {
  if (Array.isArray(e))
    return new Reader$3(e);
  throw Error("illegal buffer");
}, create$4 = function t() {
  return util$9.Buffer ? function(r) {
    return (Reader$3.create = function(i) {
      return util$9.Buffer.isBuffer(i) ? new BufferReader$3(i) : create_array$1(i);
    })(r);
  } : create_array$1;
};
Reader$3.create = create$4();
Reader$3.prototype._slice = util$9.Array.prototype.subarray || /* istanbul ignore next */
util$9.Array.prototype.slice;
Reader$3.prototype.uint32 = function t() {
  var e = 4294967295;
  return function() {
    if (e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (e = (e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return e;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange$1(this, 10);
    return e;
  };
}();
Reader$3.prototype.int32 = function t() {
  return this.uint32() | 0;
};
Reader$3.prototype.sint32 = function t() {
  var e = this.uint32();
  return e >>> 1 ^ -(e & 1) | 0;
};
function readLongVarint$1() {
  var t = new LongBits$3(0, 0), e = 0;
  if (this.len - this.pos > 4) {
    for (; e < 4; ++e)
      if (t.lo = (t.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128)
        return t;
    if (t.lo = (t.lo | (this.buf[this.pos] & 127) << 28) >>> 0, t.hi = (t.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return t;
    e = 0;
  } else {
    for (; e < 3; ++e) {
      if (this.pos >= this.len)
        throw indexOutOfRange$1(this);
      if (t.lo = (t.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128)
        return t;
    }
    return t.lo = (t.lo | (this.buf[this.pos++] & 127) << e * 7) >>> 0, t;
  }
  if (this.len - this.pos > 4) {
    for (; e < 5; ++e)
      if (t.hi = (t.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return t;
  } else
    for (; e < 5; ++e) {
      if (this.pos >= this.len)
        throw indexOutOfRange$1(this);
      if (t.hi = (t.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return t;
    }
  throw Error("invalid varint encoding");
}
Reader$3.prototype.bool = function t() {
  return this.uint32() !== 0;
};
function readFixed32_end$1(t, e) {
  return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0;
}
Reader$3.prototype.fixed32 = function t() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange$1(this, 4);
  return readFixed32_end$1(this.buf, this.pos += 4);
};
Reader$3.prototype.sfixed32 = function t() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange$1(this, 4);
  return readFixed32_end$1(this.buf, this.pos += 4) | 0;
};
function readFixed64$1() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange$1(this, 8);
  return new LongBits$3(readFixed32_end$1(this.buf, this.pos += 4), readFixed32_end$1(this.buf, this.pos += 4));
}
Reader$3.prototype.float = function t() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange$1(this, 4);
  var e = util$9.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, e;
};
Reader$3.prototype.double = function t() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange$1(this, 4);
  var e = util$9.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, e;
};
Reader$3.prototype.bytes = function t() {
  var e = this.uint32(), r = this.pos, n = this.pos + e;
  if (n > this.len)
    throw indexOutOfRange$1(this, e);
  return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(r, n) : r === n ? new this.buf.constructor(0) : this._slice.call(this.buf, r, n);
};
Reader$3.prototype.string = function t() {
  var e = this.bytes();
  return utf8$3.read(e, 0, e.length);
};
Reader$3.prototype.skip = function t(e) {
  if (typeof e == "number") {
    if (this.pos + e > this.len)
      throw indexOutOfRange$1(this, e);
    this.pos += e;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange$1(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$3.prototype.skipType = function(t) {
  switch (t) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (t = this.uint32() & 7) !== 4; )
        this.skipType(t);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + t + " at offset " + this.pos);
  }
  return this;
};
Reader$3._configure = function(t) {
  BufferReader$3 = t, Reader$3.create = create$4(), BufferReader$3._configure();
  var e = util$9.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$9.merge(Reader$3.prototype, {
    int64: function() {
      return readLongVarint$1.call(this)[e](!1);
    },
    uint64: function() {
      return readLongVarint$1.call(this)[e](!0);
    },
    sint64: function() {
      return readLongVarint$1.call(this).zzDecode()[e](!1);
    },
    fixed64: function() {
      return readFixed64$1.call(this)[e](!0);
    },
    sfixed64: function() {
      return readFixed64$1.call(this)[e](!1);
    }
  });
};
var reader_buffer$1 = BufferReader$2, Reader$2 = reader$4;
(BufferReader$2.prototype = Object.create(Reader$2.prototype)).constructor = BufferReader$2;
var util$8 = requireMinimal$1();
function BufferReader$2(t) {
  Reader$2.call(this, t);
}
BufferReader$2._configure = function() {
  util$8.Buffer && (BufferReader$2.prototype._slice = util$8.Buffer.prototype.slice);
};
BufferReader$2.prototype.string = function t() {
  var e = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e, this.len));
};
BufferReader$2._configure();
var minimalExports$1 = requireMinimal$1();
const util$7 = /* @__PURE__ */ getDefaultExportFromCjs(minimalExports$1);
var writer$3 = Writer$3, util$6 = requireMinimal$1(), BufferWriter$3, LongBits$2 = util$6.LongBits, base64$3 = util$6.base64, utf8$2 = util$6.utf8;
function Op$1(t, e, r) {
  this.fn = t, this.len = e, this.next = void 0, this.val = r;
}
function noop$3() {
}
function State$1(t) {
  this.head = t.head, this.tail = t.tail, this.len = t.len, this.next = t.states;
}
function Writer$3() {
  this.len = 0, this.head = new Op$1(noop$3, 0, 0), this.tail = this.head, this.states = null;
}
var create$3 = function t() {
  return util$6.Buffer ? function() {
    return (Writer$3.create = function() {
      return new BufferWriter$3();
    })();
  } : function() {
    return new Writer$3();
  };
};
Writer$3.create = create$3();
Writer$3.alloc = function t(e) {
  return new util$6.Array(e);
};
util$6.Array !== Array && (Writer$3.alloc = util$6.pool(Writer$3.alloc, util$6.Array.prototype.subarray));
Writer$3.prototype._push = function t(e, r, n) {
  return this.tail = this.tail.next = new Op$1(e, r, n), this.len += r, this;
};
function writeByte$1(t, e, r) {
  e[r] = t & 255;
}
function writeVarint32$1(t, e, r) {
  for (; t > 127; )
    e[r++] = t & 127 | 128, t >>>= 7;
  e[r] = t;
}
function VarintOp$1(t, e) {
  this.len = t, this.next = void 0, this.val = e;
}
VarintOp$1.prototype = Object.create(Op$1.prototype);
VarintOp$1.prototype.fn = writeVarint32$1;
Writer$3.prototype.uint32 = function t(e) {
  return this.len += (this.tail = this.tail.next = new VarintOp$1(
    (e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5,
    e
  )).len, this;
};
Writer$3.prototype.int32 = function t(e) {
  return e < 0 ? this._push(writeVarint64$1, 10, LongBits$2.fromNumber(e)) : this.uint32(e);
};
Writer$3.prototype.sint32 = function t(e) {
  return this.uint32((e << 1 ^ e >> 31) >>> 0);
};
function writeVarint64$1(t, e, r) {
  for (; t.hi; )
    e[r++] = t.lo & 127 | 128, t.lo = (t.lo >>> 7 | t.hi << 25) >>> 0, t.hi >>>= 7;
  for (; t.lo > 127; )
    e[r++] = t.lo & 127 | 128, t.lo = t.lo >>> 7;
  e[r++] = t.lo;
}
Writer$3.prototype.uint64 = function t(e) {
  var r = LongBits$2.from(e);
  return this._push(writeVarint64$1, r.length(), r);
};
Writer$3.prototype.int64 = Writer$3.prototype.uint64;
Writer$3.prototype.sint64 = function t(e) {
  var r = LongBits$2.from(e).zzEncode();
  return this._push(writeVarint64$1, r.length(), r);
};
Writer$3.prototype.bool = function t(e) {
  return this._push(writeByte$1, 1, e ? 1 : 0);
};
function writeFixed32$1(t, e, r) {
  e[r] = t & 255, e[r + 1] = t >>> 8 & 255, e[r + 2] = t >>> 16 & 255, e[r + 3] = t >>> 24;
}
Writer$3.prototype.fixed32 = function t(e) {
  return this._push(writeFixed32$1, 4, e >>> 0);
};
Writer$3.prototype.sfixed32 = Writer$3.prototype.fixed32;
Writer$3.prototype.fixed64 = function t(e) {
  var r = LongBits$2.from(e);
  return this._push(writeFixed32$1, 4, r.lo)._push(writeFixed32$1, 4, r.hi);
};
Writer$3.prototype.sfixed64 = Writer$3.prototype.fixed64;
Writer$3.prototype.float = function t(e) {
  return this._push(util$6.float.writeFloatLE, 4, e);
};
Writer$3.prototype.double = function t(e) {
  return this._push(util$6.float.writeDoubleLE, 8, e);
};
var writeBytes$1 = util$6.Array.prototype.set ? function t(e, r, n) {
  r.set(e, n);
} : function t(e, r, n) {
  for (var i = 0; i < e.length; ++i)
    r[n + i] = e[i];
};
Writer$3.prototype.bytes = function t(e) {
  var r = e.length >>> 0;
  if (!r)
    return this._push(writeByte$1, 1, 0);
  if (util$6.isString(e)) {
    var n = Writer$3.alloc(r = base64$3.length(e));
    base64$3.decode(e, n, 0), e = n;
  }
  return this.uint32(r)._push(writeBytes$1, r, e);
};
Writer$3.prototype.string = function t(e) {
  var r = utf8$2.length(e);
  return r ? this.uint32(r)._push(utf8$2.write, r, e) : this._push(writeByte$1, 1, 0);
};
Writer$3.prototype.fork = function t() {
  return this.states = new State$1(this), this.head = this.tail = new Op$1(noop$3, 0, 0), this.len = 0, this;
};
Writer$3.prototype.reset = function t() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op$1(noop$3, 0, 0), this.len = 0), this;
};
Writer$3.prototype.ldelim = function t() {
  var e = this.head, r = this.tail, n = this.len;
  return this.reset().uint32(n), n && (this.tail.next = e.next, this.tail = r, this.len += n), this;
};
Writer$3.prototype.finish = function t() {
  for (var e = this.head.next, r = this.constructor.alloc(this.len), n = 0; e; )
    e.fn(e.val, r, n), n += e.len, e = e.next;
  return r;
};
Writer$3._configure = function(t) {
  BufferWriter$3 = t, Writer$3.create = create$3(), BufferWriter$3._configure();
};
var writer_buffer$1 = BufferWriter$2, Writer$2 = writer$3;
(BufferWriter$2.prototype = Object.create(Writer$2.prototype)).constructor = BufferWriter$2;
var util$5 = requireMinimal$1();
function BufferWriter$2() {
  Writer$2.call(this);
}
BufferWriter$2._configure = function() {
  BufferWriter$2.alloc = util$5._Buffer_allocUnsafe, BufferWriter$2.writeBytesBuffer = util$5.Buffer && util$5.Buffer.prototype instanceof Uint8Array && util$5.Buffer.prototype.set.name === "set" ? function(e, r, n) {
    r.set(e, n);
  } : function(e, r, n) {
    if (e.copy)
      e.copy(r, n, 0, e.length);
    else
      for (var i = 0; i < e.length; )
        r[n++] = e[i++];
  };
};
BufferWriter$2.prototype.bytes = function t(e) {
  util$5.isString(e) && (e = util$5._Buffer_from(e, "base64"));
  var r = e.length >>> 0;
  return this.uint32(r), r && this._push(BufferWriter$2.writeBytesBuffer, r, e), this;
};
function writeStringBuffer$1(t, e, r) {
  t.length < 40 ? util$5.utf8.write(t, e, r) : e.utf8Write ? e.utf8Write(t, r) : e.write(t, r);
}
BufferWriter$2.prototype.string = function t(e) {
  var r = util$5.Buffer.byteLength(e);
  return this.uint32(r), r && this._push(writeStringBuffer$1, r, e), this;
};
BufferWriter$2._configure();
function configure$1() {
  util$7._configure(), reader$4._configure(reader_buffer$1), writer$3._configure(writer_buffer$1);
}
configure$1();
const methods$1 = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader$1(t) {
  for (const e of methods$1) {
    if (t[e] == null)
      continue;
    const r = t[e];
    t[e] = function() {
      return BigInt(r.call(this).toString());
    };
  }
  return t;
}
function reader$3(t) {
  return patchReader$1(new reader$4(t));
}
function patchWriter$1(t) {
  for (const e of methods$1) {
    if (t[e] == null)
      continue;
    const r = t[e];
    t[e] = function(n) {
      return r.call(this, n.toString());
    };
  }
  return t;
}
function writer$2() {
  return patchWriter$1(writer$3.create());
}
function decodeMessage$1(t, e) {
  const r = reader$3(t instanceof Uint8Array ? t : t.subarray());
  return e.decode(r);
}
function encodeMessage$1(t, e) {
  const r = writer$2();
  return e.encode(t, r, {
    lengthDelimited: !1
  }), r.finish();
}
var CODEC_TYPES$1;
(function(t) {
  t[t.VARINT = 0] = "VARINT", t[t.BIT64 = 1] = "BIT64", t[t.LENGTH_DELIMITED = 2] = "LENGTH_DELIMITED", t[t.START_GROUP = 3] = "START_GROUP", t[t.END_GROUP = 4] = "END_GROUP", t[t.BIT32 = 5] = "BIT32";
})(CODEC_TYPES$1 || (CODEC_TYPES$1 = {}));
function createCodec$2(t, e, r, n) {
  return {
    name: t,
    type: e,
    encode: r,
    decode: n
  };
}
function enumeration(t) {
  function e(i) {
    if (t[i.toString()] == null)
      throw new Error("Invalid enum value");
    return t[i];
  }
  const r = function(o, a) {
    const c = e(o);
    a.int32(c);
  }, n = function(o) {
    const a = o.int32();
    return e(a);
  };
  return createCodec$2("enum", CODEC_TYPES$1.VARINT, r, n);
}
function message$1(t, e) {
  return createCodec$2("message", CODEC_TYPES$1.LENGTH_DELIMITED, t, e);
}
var KeyType;
(function(t) {
  t.RSA = "RSA", t.Ed25519 = "Ed25519", t.Secp256k1 = "Secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(t) {
  t[t.RSA = 0] = "RSA", t[t.Ed25519 = 1] = "Ed25519", t[t.Secp256k1 = 2] = "Secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(t) {
  t.codec = () => enumeration(__KeyTypeValues);
})(KeyType || (KeyType = {}));
var PublicKey;
(function(t) {
  let e;
  t.codec = () => (e == null && (e = message$1((r, n, i = {}) => {
    i.lengthDelimited !== !1 && n.fork(), r.Type != null && (n.uint32(8), KeyType.codec().encode(r.Type, n)), r.Data != null && (n.uint32(18), n.bytes(r.Data)), i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {}, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.Type = KeyType.codec().decode(r);
          break;
        case 2:
          i.Data = r.bytes();
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage$1(r, t.codec()), t.decode = (r) => decodeMessage$1(r, t.codec());
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(t) {
  let e;
  t.codec = () => (e == null && (e = message$1((r, n, i = {}) => {
    i.lengthDelimited !== !1 && n.fork(), r.Type != null && (n.uint32(8), KeyType.codec().encode(r.Type, n)), r.Data != null && (n.uint32(18), n.bytes(r.Data)), i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {}, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.Type = KeyType.codec().decode(r);
          break;
        case 2:
          i.Data = r.bytes();
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage$1(r, t.codec()), t.decode = (r) => decodeMessage$1(r, t.codec());
})(PrivateKey || (PrivateKey = {}));
class Ed25519PublicKey {
  constructor(e) {
    $(this, "_key");
    this._key = ensureKey(e, PUBLIC_KEY_BYTE_LENGTH);
  }
  async verify(e, r) {
    return hashAndVerify$2(this._key, r, e);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(e) {
    return equals$2(this.bytes, e.bytes);
  }
  async hash() {
    const { bytes: e } = await sha256$2.digest(this.bytes);
    return e;
  }
}
class Ed25519PrivateKey {
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(e, r) {
    $(this, "_key");
    $(this, "_publicKey");
    this._key = ensureKey(e, PRIVATE_KEY_BYTE_LENGTH), this._publicKey = ensureKey(r, PUBLIC_KEY_BYTE_LENGTH);
  }
  async sign(e) {
    return hashAndSign$2(this._key, e);
  }
  get public() {
    return new Ed25519PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(e) {
    return equals$2(this.bytes, e.bytes);
  }
  async hash() {
    const { bytes: e } = await sha256$2.digest(this.bytes);
    return e;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the identity multihash containing its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   *
   * @returns {Promise<string>}
   */
  async id() {
    const e = identity$3.digest(this.public.bytes);
    return base58btc$1.encode(e.bytes).substring(1);
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(e, r = "libp2p-key") {
    if (r === "libp2p-key")
      return exporter(this.bytes, e);
    throw new CodeError$2(`export format '${r}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
  }
}
function unmarshalEd25519PrivateKey(t) {
  if (t.length > PRIVATE_KEY_BYTE_LENGTH) {
    t = ensureKey(t, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const n = t.subarray(0, PRIVATE_KEY_BYTE_LENGTH), i = t.subarray(PRIVATE_KEY_BYTE_LENGTH, t.length);
    return new Ed25519PrivateKey(n, i);
  }
  t = ensureKey(t, PRIVATE_KEY_BYTE_LENGTH);
  const e = t.subarray(0, PRIVATE_KEY_BYTE_LENGTH), r = t.subarray(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(e, r);
}
function unmarshalEd25519PublicKey(t) {
  return t = ensureKey(t, PUBLIC_KEY_BYTE_LENGTH), new Ed25519PublicKey(t);
}
async function generateKeyPair$3() {
  const { privateKey: t, publicKey: e } = await generateKey$2();
  return new Ed25519PrivateKey(t, e);
}
async function generateKeyPairFromSeed$1(t) {
  const { privateKey: e, publicKey: r } = await generateKeyFromSeed(t);
  return new Ed25519PrivateKey(e, r);
}
function ensureKey(t, e) {
  if (t = Uint8Array.from(t ?? []), t.length !== e)
    throw new CodeError$2(`Key must be a Uint8Array of length ${e}, got ${t.length}`, "ERR_INVALID_KEY_TYPE");
  return t;
}
const Ed25519 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ed25519PrivateKey,
  Ed25519PublicKey,
  generateKeyPair: generateKeyPair$3,
  generateKeyPairFromSeed: generateKeyPairFromSeed$1,
  unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey
}, Symbol.toStringTag, { value: "Module" })), curves = {
  "P-256": "prime256v1",
  "P-384": "secp384r1",
  "P-521": "secp521r1"
}, curveTypes = Object.keys(curves);
curveTypes.join(" / ");
async function importer(t, e) {
  const r = base64$5.decode(t);
  return create$5().decrypt(r, e);
}
var forge = forge$m, sha512$1 = forge.sha512 = forge.sha512 || {};
forge.md.sha512 = forge.md.algorithms.sha512 = sha512$1;
var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
sha384.create = function() {
  return sha512$1.create("SHA-384");
};
forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
forge.sha512.sha256 = forge.sha512.sha256 || {
  create: function() {
    return sha512$1.create("SHA-512/256");
  }
};
forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
forge.sha512.sha224 = forge.sha512.sha224 || {
  create: function() {
    return sha512$1.create("SHA-512/224");
  }
};
forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
sha512$1.create = function(t) {
  if (_initialized || _init(), typeof t > "u" && (t = "SHA-512"), !(t in _states))
    throw new Error("Invalid SHA-512 algorithm: " + t);
  for (var e = _states[t], r = null, n = forge.util.createBuffer(), i = new Array(80), o = 0; o < 80; ++o)
    i[o] = new Array(2);
  var a = 64;
  switch (t) {
    case "SHA-384":
      a = 48;
      break;
    case "SHA-512/256":
      a = 32;
      break;
    case "SHA-512/224":
      a = 28;
      break;
  }
  var c = {
    // SHA-512 => sha512
    algorithm: t.replace("-", "").toLowerCase(),
    blockLength: 128,
    digestLength: a,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };
  return c.start = function() {
    c.messageLength = 0, c.fullMessageLength = c.messageLength128 = [];
    for (var l = c.messageLengthSize / 4, u = 0; u < l; ++u)
      c.fullMessageLength.push(0);
    n = forge.util.createBuffer(), r = new Array(e.length);
    for (var u = 0; u < e.length; ++u)
      r[u] = e[u].slice(0);
    return c;
  }, c.start(), c.update = function(l, u) {
    u === "utf8" && (l = forge.util.encodeUtf8(l));
    var f = l.length;
    c.messageLength += f, f = [f / 4294967296 >>> 0, f >>> 0];
    for (var d = c.fullMessageLength.length - 1; d >= 0; --d)
      c.fullMessageLength[d] += f[1], f[1] = f[0] + (c.fullMessageLength[d] / 4294967296 >>> 0), c.fullMessageLength[d] = c.fullMessageLength[d] >>> 0, f[0] = f[1] / 4294967296 >>> 0;
    return n.putBytes(l), _update(r, i, n), (n.read > 2048 || n.length() === 0) && n.compact(), c;
  }, c.digest = function() {
    var l = forge.util.createBuffer();
    l.putBytes(n.bytes());
    var u = c.fullMessageLength[c.fullMessageLength.length - 1] + c.messageLengthSize, f = u & c.blockLength - 1;
    l.putBytes(_padding.substr(0, c.blockLength - f));
    for (var d, p, g = c.fullMessageLength[0] * 8, h = 0; h < c.fullMessageLength.length - 1; ++h)
      d = c.fullMessageLength[h + 1] * 8, p = d / 4294967296 >>> 0, g += p, l.putInt32(g >>> 0), g = d >>> 0;
    l.putInt32(g);
    for (var m = new Array(r.length), h = 0; h < r.length; ++h)
      m[h] = r[h].slice(0);
    _update(m, i, l);
    var y = forge.util.createBuffer(), b;
    t === "SHA-512" ? b = m.length : t === "SHA-384" ? b = m.length - 2 : b = m.length - 4;
    for (var h = 0; h < b; ++h)
      y.putInt32(m[h][0]), (h !== b - 1 || t !== "SHA-512/224") && y.putInt32(m[h][1]);
    return y;
  }, c;
};
var _padding = null, _initialized = !1, _k = null, _states = null;
function _init() {
  _padding = String.fromCharCode(128), _padding += forge.util.fillString(String.fromCharCode(0), 128), _k = [
    [1116352408, 3609767458],
    [1899447441, 602891725],
    [3049323471, 3964484399],
    [3921009573, 2173295548],
    [961987163, 4081628472],
    [1508970993, 3053834265],
    [2453635748, 2937671579],
    [2870763221, 3664609560],
    [3624381080, 2734883394],
    [310598401, 1164996542],
    [607225278, 1323610764],
    [1426881987, 3590304994],
    [1925078388, 4068182383],
    [2162078206, 991336113],
    [2614888103, 633803317],
    [3248222580, 3479774868],
    [3835390401, 2666613458],
    [4022224774, 944711139],
    [264347078, 2341262773],
    [604807628, 2007800933],
    [770255983, 1495990901],
    [1249150122, 1856431235],
    [1555081692, 3175218132],
    [1996064986, 2198950837],
    [2554220882, 3999719339],
    [2821834349, 766784016],
    [2952996808, 2566594879],
    [3210313671, 3203337956],
    [3336571891, 1034457026],
    [3584528711, 2466948901],
    [113926993, 3758326383],
    [338241895, 168717936],
    [666307205, 1188179964],
    [773529912, 1546045734],
    [1294757372, 1522805485],
    [1396182291, 2643833823],
    [1695183700, 2343527390],
    [1986661051, 1014477480],
    [2177026350, 1206759142],
    [2456956037, 344077627],
    [2730485921, 1290863460],
    [2820302411, 3158454273],
    [3259730800, 3505952657],
    [3345764771, 106217008],
    [3516065817, 3606008344],
    [3600352804, 1432725776],
    [4094571909, 1467031594],
    [275423344, 851169720],
    [430227734, 3100823752],
    [506948616, 1363258195],
    [659060556, 3750685593],
    [883997877, 3785050280],
    [958139571, 3318307427],
    [1322822218, 3812723403],
    [1537002063, 2003034995],
    [1747873779, 3602036899],
    [1955562222, 1575990012],
    [2024104815, 1125592928],
    [2227730452, 2716904306],
    [2361852424, 442776044],
    [2428436474, 593698344],
    [2756734187, 3733110249],
    [3204031479, 2999351573],
    [3329325298, 3815920427],
    [3391569614, 3928383900],
    [3515267271, 566280711],
    [3940187606, 3454069534],
    [4118630271, 4000239992],
    [116418474, 1914138554],
    [174292421, 2731055270],
    [289380356, 3203993006],
    [460393269, 320620315],
    [685471733, 587496836],
    [852142971, 1086792851],
    [1017036298, 365543100],
    [1126000580, 2618297676],
    [1288033470, 3409855158],
    [1501505948, 4234509866],
    [1607167915, 987167468],
    [1816402316, 1246189591]
  ], _states = {}, _states["SHA-512"] = [
    [1779033703, 4089235720],
    [3144134277, 2227873595],
    [1013904242, 4271175723],
    [2773480762, 1595750129],
    [1359893119, 2917565137],
    [2600822924, 725511199],
    [528734635, 4215389547],
    [1541459225, 327033209]
  ], _states["SHA-384"] = [
    [3418070365, 3238371032],
    [1654270250, 914150663],
    [2438529370, 812702999],
    [355462360, 4144912697],
    [1731405415, 4290775857],
    [2394180231, 1750603025],
    [3675008525, 1694076839],
    [1203062813, 3204075428]
  ], _states["SHA-512/256"] = [
    [573645204, 4230739756],
    [2673172387, 3360449730],
    [596883563, 1867755857],
    [2520282905, 1497426621],
    [2519219938, 2827943907],
    [3193839141, 1401305490],
    [721525244, 746961066],
    [246885852, 2177182882]
  ], _states["SHA-512/224"] = [
    [2352822216, 424955298],
    [1944164710, 2312950998],
    [502970286, 855612546],
    [1738396948, 1479516111],
    [258812777, 2077511080],
    [2011393907, 79989058],
    [1067287976, 1780299464],
    [286451373, 2446758561]
  ], _initialized = !0;
}
function _update(t, e, r) {
  for (var n, i, o, a, c, l, u, f, d, p, g, h, m, y, b, v, _, E, w, S, x, I, C, M, O, B, k, U, R, P, T, L, A, N, D, F = r.length(); F >= 128; ) {
    for (R = 0; R < 16; ++R)
      e[R][0] = r.getInt32() >>> 0, e[R][1] = r.getInt32() >>> 0;
    for (; R < 80; ++R)
      L = e[R - 2], P = L[0], T = L[1], n = ((P >>> 19 | T << 13) ^ // ROTR 19
      (T >>> 29 | P << 3) ^ // ROTR 61/(swap + ROTR 29)
      P >>> 6) >>> 0, i = ((P << 13 | T >>> 19) ^ // ROTR 19
      (T << 3 | P >>> 29) ^ // ROTR 61/(swap + ROTR 29)
      (P << 26 | T >>> 6)) >>> 0, N = e[R - 15], P = N[0], T = N[1], o = ((P >>> 1 | T << 31) ^ // ROTR 1
      (P >>> 8 | T << 24) ^ // ROTR 8
      P >>> 7) >>> 0, a = ((P << 31 | T >>> 1) ^ // ROTR 1
      (P << 24 | T >>> 8) ^ // ROTR 8
      (P << 25 | T >>> 7)) >>> 0, A = e[R - 7], D = e[R - 16], T = i + A[1] + a + D[1], e[R][0] = n + A[0] + o + D[0] + (T / 4294967296 >>> 0) >>> 0, e[R][1] = T >>> 0;
    for (m = t[0][0], y = t[0][1], b = t[1][0], v = t[1][1], _ = t[2][0], E = t[2][1], w = t[3][0], S = t[3][1], x = t[4][0], I = t[4][1], C = t[5][0], M = t[5][1], O = t[6][0], B = t[6][1], k = t[7][0], U = t[7][1], R = 0; R < 80; ++R)
      u = ((x >>> 14 | I << 18) ^ // ROTR 14
      (x >>> 18 | I << 14) ^ // ROTR 18
      (I >>> 9 | x << 23)) >>> 0, f = ((x << 18 | I >>> 14) ^ // ROTR 14
      (x << 14 | I >>> 18) ^ // ROTR 18
      (I << 23 | x >>> 9)) >>> 0, d = (O ^ x & (C ^ O)) >>> 0, p = (B ^ I & (M ^ B)) >>> 0, c = ((m >>> 28 | y << 4) ^ // ROTR 28
      (y >>> 2 | m << 30) ^ // ROTR 34/(swap + ROTR 2)
      (y >>> 7 | m << 25)) >>> 0, l = ((m << 4 | y >>> 28) ^ // ROTR 28
      (y << 30 | m >>> 2) ^ // ROTR 34/(swap + ROTR 2)
      (y << 25 | m >>> 7)) >>> 0, g = (m & b | _ & (m ^ b)) >>> 0, h = (y & v | E & (y ^ v)) >>> 0, T = U + f + p + _k[R][1] + e[R][1], n = k + u + d + _k[R][0] + e[R][0] + (T / 4294967296 >>> 0) >>> 0, i = T >>> 0, T = l + h, o = c + g + (T / 4294967296 >>> 0) >>> 0, a = T >>> 0, k = O, U = B, O = C, B = M, C = x, M = I, T = S + i, x = w + n + (T / 4294967296 >>> 0) >>> 0, I = T >>> 0, w = _, S = E, _ = b, E = v, b = m, v = y, T = i + a, m = n + o + (T / 4294967296 >>> 0) >>> 0, y = T >>> 0;
    T = t[0][1] + y, t[0][0] = t[0][0] + m + (T / 4294967296 >>> 0) >>> 0, t[0][1] = T >>> 0, T = t[1][1] + v, t[1][0] = t[1][0] + b + (T / 4294967296 >>> 0) >>> 0, t[1][1] = T >>> 0, T = t[2][1] + E, t[2][0] = t[2][0] + _ + (T / 4294967296 >>> 0) >>> 0, t[2][1] = T >>> 0, T = t[3][1] + S, t[3][0] = t[3][0] + w + (T / 4294967296 >>> 0) >>> 0, t[3][1] = T >>> 0, T = t[4][1] + I, t[4][0] = t[4][0] + x + (T / 4294967296 >>> 0) >>> 0, t[4][1] = T >>> 0, T = t[5][1] + M, t[5][0] = t[5][0] + C + (T / 4294967296 >>> 0) >>> 0, t[5][1] = T >>> 0, T = t[6][1] + B, t[6][0] = t[6][0] + O + (T / 4294967296 >>> 0) >>> 0, t[6][1] = T >>> 0, T = t[7][1] + U, t[7][0] = t[7][0] + k + (T / 4294967296 >>> 0) >>> 0, t[7][1] = T >>> 0, F -= 128;
  }
}
const crypto$1 = nc && typeof nc == "object" && "webcrypto" in nc ? nc.webcrypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$2 = (t) => t instanceof Uint8Array, createView$1 = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), rotr = (t, e) => t << 32 - e | t >>> e, isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$1)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function utf8ToBytes$2(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function toBytes$3(t) {
  if (typeof t == "string" && (t = utf8ToBytes$2(t)), !u8a$2(t))
    throw new Error(`expected Uint8Array, got ${typeof t}`);
  return t;
}
function concatBytes$1(...t) {
  const e = new Uint8Array(t.reduce((n, i) => n + i.length, 0));
  let r = 0;
  return t.forEach((n) => {
    if (!u8a$2(n))
      throw new Error("Uint8Array expected");
    e.set(n, r), r += n.length;
  }), e;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(t) {
  const e = (n) => t().update(toBytes$3(n)).digest(), r = t();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;
}
function randomBytes$2(t = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues == "function")
    return crypto$1.getRandomValues(new Uint8Array(t));
  throw new Error("crypto.getRandomValues must be defined");
}
function randomBytes$1(t) {
  if (isNaN(t) || t <= 0)
    throw new CodeError$2("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
  return randomBytes$2(t);
}
function bigIntegerToUintBase64url(t, e) {
  let r = Uint8Array.from(t.abs().toByteArray());
  if (r = r[0] === 0 ? r.subarray(1) : r, e != null) {
    if (r.length > e)
      throw new Error("byte array longer than desired length");
    r = concat$6([new Uint8Array(e - r.length), r]);
  }
  return toString$4(r, "base64url");
}
function base64urlToBigInteger(t) {
  const e = base64urlToBuffer(t);
  return new forge$m.jsbn.BigInteger(toString$4(e, "base16"), 16);
}
function base64urlToBuffer(t, e) {
  let r = fromString$3(t, "base64urlpad");
  if (e != null) {
    if (r.length > e)
      throw new Error("byte array longer than desired length");
    r = concat$6([new Uint8Array(e - r.length), r]);
  }
  return r;
}
function pkcs1ToJwk(t) {
  const e = forge$m.asn1.fromDer(toString$4(t, "ascii")), r = forge$m.pki.privateKeyFromAsn1(e);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(r.n),
    e: bigIntegerToUintBase64url(r.e),
    d: bigIntegerToUintBase64url(r.d),
    p: bigIntegerToUintBase64url(r.p),
    q: bigIntegerToUintBase64url(r.q),
    dp: bigIntegerToUintBase64url(r.dP),
    dq: bigIntegerToUintBase64url(r.dQ),
    qi: bigIntegerToUintBase64url(r.qInv),
    alg: "RS256"
  };
}
function jwkToPkcs1(t) {
  if (t.n == null || t.e == null || t.d == null || t.p == null || t.q == null || t.dp == null || t.dq == null || t.qi == null)
    throw new CodeError$2("JWK was missing components", "ERR_INVALID_PARAMETERS");
  const e = forge$m.pki.privateKeyToAsn1({
    n: base64urlToBigInteger(t.n),
    e: base64urlToBigInteger(t.e),
    d: base64urlToBigInteger(t.d),
    p: base64urlToBigInteger(t.p),
    q: base64urlToBigInteger(t.q),
    dP: base64urlToBigInteger(t.dp),
    dQ: base64urlToBigInteger(t.dq),
    qInv: base64urlToBigInteger(t.qi)
  });
  return fromString$3(forge$m.asn1.toDer(e).getBytes(), "ascii");
}
function pkixToJwk(t) {
  const e = forge$m.asn1.fromDer(toString$4(t, "ascii")), r = forge$m.pki.publicKeyFromAsn1(e);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(r.n),
    e: bigIntegerToUintBase64url(r.e)
  };
}
function jwkToPkix(t) {
  if (t.n == null || t.e == null)
    throw new CodeError$2("JWK was missing components", "ERR_INVALID_PARAMETERS");
  const e = forge$m.pki.publicKeyToAsn1({
    n: base64urlToBigInteger(t.n),
    e: base64urlToBigInteger(t.e)
  });
  return fromString$3(forge$m.asn1.toDer(e).getBytes(), "ascii");
}
const keypair = promisify(crypto$3.generateKeyPair);
async function generateKey$1(t) {
  const e = await keypair("rsa", {
    modulusLength: t,
    publicKeyEncoding: { type: "pkcs1", format: "jwk" },
    privateKeyEncoding: { type: "pkcs1", format: "jwk" }
  });
  return {
    // @ts-expect-error node types are missing jwk as a format
    privateKey: e.privateKey,
    // @ts-expect-error node types are missing jwk as a format
    publicKey: e.publicKey
  };
}
async function unmarshalPrivateKey$1(t) {
  if (t == null)
    throw new CodeError$2("Missing key parameter", "ERR_MISSING_KEY");
  return {
    privateKey: t,
    publicKey: {
      kty: t.kty,
      n: t.n,
      e: t.e
    }
  };
}
async function hashAndSign$1(t, e) {
  return crypto$3.createSign("RSA-SHA256").update(e).sign({ format: "jwk", key: t });
}
async function hashAndVerify$1(t, e, r) {
  return crypto$3.createVerify("RSA-SHA256").update(r).verify({ format: "jwk", key: t }, e);
}
const padding = crypto$3.constants.RSA_PKCS1_PADDING;
function encrypt(t, e) {
  return crypto$3.publicEncrypt({ format: "jwk", key: t, padding }, e);
}
function decrypt(t, e) {
  return crypto$3.privateDecrypt({ format: "jwk", key: t, padding }, e);
}
function keySize(t) {
  if (t.kty !== "RSA")
    throw new CodeError$2("invalid key type", "ERR_INVALID_KEY_TYPE");
  if (t.n == null)
    throw new CodeError$2("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
  return Buffer.from(t.n, "base64").length * 8;
}
const MAX_KEY_SIZE = 8192;
class RsaPublicKey {
  constructor(e) {
    $(this, "_key");
    this._key = e;
  }
  async verify(e, r) {
    return hashAndVerify$1(this._key, r, e);
  }
  marshal() {
    return jwkToPkix(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  encrypt(e) {
    return encrypt(this._key, e);
  }
  equals(e) {
    return equals$2(this.bytes, e.bytes);
  }
  async hash() {
    const { bytes: e } = await sha256$2.digest(this.bytes);
    return e;
  }
}
class RsaPrivateKey {
  constructor(e, r) {
    $(this, "_key");
    $(this, "_publicKey");
    this._key = e, this._publicKey = r;
  }
  genSecret() {
    return randomBytes$1(16);
  }
  async sign(e) {
    return hashAndSign$1(this._key, e);
  }
  get public() {
    if (this._publicKey == null)
      throw new CodeError$2("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
    return new RsaPublicKey(this._publicKey);
  }
  decrypt(e) {
    return decrypt(this._key, e);
  }
  marshal() {
    return jwkToPkcs1(this._key);
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(e) {
    return equals$2(this.bytes, e.bytes);
  }
  async hash() {
    const { bytes: e } = await sha256$2.digest(this.bytes);
    return e;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const e = await this.public.hash();
    return toString$4(e, "base58btc");
  }
  /**
   * Exports the key into a password protected PEM format
   */
  async export(e, r = "pkcs-8") {
    if (r === "pkcs-8") {
      const n = new forge$m.util.ByteBuffer(this.marshal()), i = forge$m.asn1.fromDer(n), o = forge$m.pki.privateKeyFromAsn1(i), a = {
        algorithm: "aes256",
        count: 1e4,
        saltSize: 128 / 8,
        prfAlgorithm: "sha512"
      };
      return forge$m.pki.encryptRsaPrivateKey(o, e, a);
    } else {
      if (r === "libp2p-key")
        return exporter(this.bytes, e);
      throw new CodeError$2(`export format '${r}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
}
async function unmarshalRsaPrivateKey(t) {
  const e = pkcs1ToJwk(t);
  if (keySize(e) > MAX_KEY_SIZE)
    throw new CodeError$2("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  const r = await unmarshalPrivateKey$1(e);
  return new RsaPrivateKey(r.privateKey, r.publicKey);
}
function unmarshalRsaPublicKey(t) {
  const e = pkixToJwk(t);
  if (keySize(e) > MAX_KEY_SIZE)
    throw new CodeError$2("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  return new RsaPublicKey(e);
}
async function fromJwk(t) {
  if (keySize(t) > MAX_KEY_SIZE)
    throw new CodeError$2("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  const e = await unmarshalPrivateKey$1(t);
  return new RsaPrivateKey(e.privateKey, e.publicKey);
}
async function generateKeyPair$2(t) {
  if (t > MAX_KEY_SIZE)
    throw new CodeError$2("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  const e = await generateKey$1(t);
  return new RsaPrivateKey(e.privateKey, e.publicKey);
}
const RSA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MAX_KEY_SIZE,
  RsaPrivateKey,
  RsaPublicKey,
  fromJwk,
  generateKeyPair: generateKeyPair$2,
  unmarshalRsaPrivateKey,
  unmarshalRsaPublicKey
}, Symbol.toStringTag, { value: "Module" }));
function number$1(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`Wrong positive integer: ${t}`);
}
function bool$1(t) {
  if (typeof t != "boolean")
    throw new Error(`Expected boolean, not ${t}`);
}
function bytes$1(t, ...e) {
  if (!(t instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);
}
function hash$1(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(t.outputLen), number$1(t.blockLen);
}
function exists$1(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(t, e) {
  bytes$1(t);
  const r = e.outputLen;
  if (t.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const assert$1 = {
  number: number$1,
  bool: bool$1,
  bytes: bytes$1,
  hash: hash$1,
  exists: exists$1,
  output: output$1
};
function setBigUint64$1(t, e, r, n) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, r, n);
  const i = BigInt(32), o = BigInt(4294967295), a = Number(r >> i & o), c = Number(r & o), l = n ? 4 : 0, u = n ? 0 : 4;
  t.setUint32(e + l, a, n), t.setUint32(e + u, c, n);
}
class SHA2 extends Hash {
  constructor(e, r, n, i) {
    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = createView$1(this.buffer);
  }
  update(e) {
    assert$1.exists(this);
    const { view: r, buffer: n, blockLen: i } = this;
    e = toBytes$3(e);
    const o = e.length;
    for (let a = 0; a < o; ) {
      const c = Math.min(i - this.pos, o - a);
      if (c === i) {
        const l = createView$1(e);
        for (; i <= o - a; a += i)
          this.process(l, a);
        continue;
      }
      n.set(e.subarray(a, a + c), this.pos), this.pos += c, a += c, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    assert$1.exists(this), assert$1.output(e, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: a } = this;
    r[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > i - a && (this.process(n, 0), a = 0);
    for (let d = a; d < i; d++)
      r[d] = 0;
    setBigUint64$1(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const c = createView$1(e), l = this.outputLen;
    if (l % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = l / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      c.setUint32(4 * d, f[d], o);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const n = e.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: a, pos: c } = this;
    return e.length = i, e.pos = c, e.finished = o, e.destroyed = a, i % r && e.buffer.set(n), e;
  }
}
const Chi = (t, e, r) => t & e ^ ~t & r, Maj = (t, e, r) => t & e ^ t & r ^ e & r, SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: e, B: r, C: n, D: i, E: o, F: a, G: c, H: l } = this;
    return [e, r, n, i, o, a, c, l];
  }
  // prettier-ignore
  set(e, r, n, i, o, a, c, l) {
    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = a | 0, this.G = c | 0, this.H = l | 0;
  }
  process(e, r) {
    for (let d = 0; d < 16; d++, r += 4)
      SHA256_W[d] = e.getUint32(r, !1);
    for (let d = 16; d < 64; d++) {
      const p = SHA256_W[d - 15], g = SHA256_W[d - 2], h = rotr(p, 7) ^ rotr(p, 18) ^ p >>> 3, m = rotr(g, 17) ^ rotr(g, 19) ^ g >>> 10;
      SHA256_W[d] = m + SHA256_W[d - 7] + h + SHA256_W[d - 16] | 0;
    }
    let { A: n, B: i, C: o, D: a, E: c, F: l, G: u, H: f } = this;
    for (let d = 0; d < 64; d++) {
      const p = rotr(c, 6) ^ rotr(c, 11) ^ rotr(c, 25), g = f + p + Chi(c, l, u) + SHA256_K[d] + SHA256_W[d] | 0, m = (rotr(n, 2) ^ rotr(n, 13) ^ rotr(n, 22)) + Maj(n, i, o) | 0;
      f = u, u = l, l = c, c = a + g | 0, a = o, o = i, i = n, n = g + m | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, c = c + this.E | 0, l = l + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, i, o, a, c, l, u, f);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
const sha256$1 = wrapConstructor(() => new SHA256());
wrapConstructor(() => new SHA224());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$5 = BigInt(0), _1n$7 = BigInt(1), _2n$4 = BigInt(2), u8a$1 = (t) => t instanceof Uint8Array, hexes = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function bytesToHex(t) {
  if (!u8a$1(t))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += hexes[t[r]];
  return e;
}
function numberToHexUnpadded(t) {
  const e = t.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function hexToNumber(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return BigInt(t === "" ? "0" : `0x${t}`);
}
function hexToBytes(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(e / 2);
  for (let n = 0; n < r.length; n++) {
    const i = n * 2, o = t.slice(i, i + 2), a = Number.parseInt(o, 16);
    if (Number.isNaN(a) || a < 0)
      throw new Error("Invalid byte sequence");
    r[n] = a;
  }
  return r;
}
function bytesToNumberBE(t) {
  return hexToNumber(bytesToHex(t));
}
function bytesToNumberLE(t) {
  if (!u8a$1(t))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(t).reverse()));
}
function numberToBytesBE(t, e) {
  return hexToBytes(t.toString(16).padStart(e * 2, "0"));
}
function numberToBytesLE(t, e) {
  return numberToBytesBE(t, e).reverse();
}
function numberToVarBytesBE(t) {
  return hexToBytes(numberToHexUnpadded(t));
}
function ensureBytes$1(t, e, r) {
  let n;
  if (typeof e == "string")
    try {
      n = hexToBytes(e);
    } catch (o) {
      throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${o}`);
    }
  else if (u8a$1(e))
    n = Uint8Array.from(e);
  else
    throw new Error(`${t} must be hex string or Uint8Array`);
  const i = n.length;
  if (typeof r == "number" && i !== r)
    throw new Error(`${t} expected ${r} bytes, got ${i}`);
  return n;
}
function concatBytes(...t) {
  const e = new Uint8Array(t.reduce((n, i) => n + i.length, 0));
  let r = 0;
  return t.forEach((n) => {
    if (!u8a$1(n))
      throw new Error("Uint8Array expected");
    e.set(n, r), r += n.length;
  }), e;
}
function equalBytes$1(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function utf8ToBytes$1(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function bitLen(t) {
  let e;
  for (e = 0; t > _0n$5; t >>= _1n$7, e += 1)
    ;
  return e;
}
function bitGet(t, e) {
  return t >> BigInt(e) & _1n$7;
}
const bitSet = (t, e, r) => t | (r ? _1n$7 : _0n$5) << BigInt(e), bitMask = (t) => (_2n$4 << BigInt(t - 1)) - _1n$7, u8n = (t) => new Uint8Array(t), u8fr = (t) => Uint8Array.from(t);
function createHmacDrbg(t, e, r) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = u8n(t), i = u8n(t), o = 0;
  const a = () => {
    n.fill(1), i.fill(0), o = 0;
  }, c = (...d) => r(i, n, ...d), l = (d = u8n()) => {
    i = c(u8fr([0]), d), n = c(), d.length !== 0 && (i = c(u8fr([1]), d), n = c());
  }, u = () => {
    if (o++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let d = 0;
    const p = [];
    for (; d < e; ) {
      n = c();
      const g = n.slice();
      p.push(g), d += n.length;
    }
    return concatBytes(...p);
  };
  return (d, p) => {
    a(), l(d);
    let g;
    for (; !(g = p(u())); )
      l();
    return a(), g;
  };
}
const validatorFns = {
  bigint: (t) => typeof t == "bigint",
  function: (t) => typeof t == "function",
  boolean: (t) => typeof t == "boolean",
  string: (t) => typeof t == "string",
  isSafeInteger: (t) => Number.isSafeInteger(t),
  array: (t) => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen)
};
function validateObject(t, e, r = {}) {
  const n = (i, o, a) => {
    const c = validatorFns[o];
    if (typeof c != "function")
      throw new Error(`Invalid validator "${o}", expected function`);
    const l = t[i];
    if (!(a && l === void 0) && !c(l, t))
      throw new Error(`Invalid param ${String(i)}=${l} (${typeof l}), expected ${o}`);
  };
  for (const [i, o] of Object.entries(e))
    n(i, o, !1);
  for (const [i, o] of Object.entries(r))
    n(i, o, !0);
  return t;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes: ensureBytes$1,
  equalBytes: equalBytes$1,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes: utf8ToBytes$1,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0), _1n$6 = BigInt(1), _2n$3 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n$1 = BigInt(5), _8n$1 = BigInt(8);
BigInt(9);
BigInt(16);
function mod(t, e) {
  const r = t % e;
  return r >= _0n$4 ? r : e + r;
}
function pow(t, e, r) {
  if (r <= _0n$4 || e < _0n$4)
    throw new Error("Expected power/modulo > 0");
  if (r === _1n$6)
    return _0n$4;
  let n = _1n$6;
  for (; e > _0n$4; )
    e & _1n$6 && (n = n * t % r), t = t * t % r, e >>= _1n$6;
  return n;
}
function pow2(t, e, r) {
  let n = t;
  for (; e-- > _0n$4; )
    n *= n, n %= r;
  return n;
}
function invert(t, e) {
  if (t === _0n$4 || e <= _0n$4)
    throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
  let r = mod(t, e), n = e, i = _0n$4, o = _1n$6;
  for (; r !== _0n$4; ) {
    const c = n / r, l = n % r, u = i - o * c;
    n = r, r = l, i = o, o = u;
  }
  if (n !== _1n$6)
    throw new Error("invert: does not exist");
  return mod(i, e);
}
function tonelliShanks(t) {
  const e = (t - _1n$6) / _2n$3;
  let r, n, i;
  for (r = t - _1n$6, n = 0; r % _2n$3 === _0n$4; r /= _2n$3, n++)
    ;
  for (i = _2n$3; i < t && pow(i, e, t) !== t - _1n$6; i++)
    ;
  if (n === 1) {
    const a = (t + _1n$6) / _4n;
    return function(l, u) {
      const f = l.pow(u, a);
      if (!l.eql(l.sqr(f), u))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const o = (r + _1n$6) / _2n$3;
  return function(c, l) {
    if (c.pow(l, e) === c.neg(c.ONE))
      throw new Error("Cannot find square root");
    let u = n, f = c.pow(c.mul(c.ONE, i), r), d = c.pow(l, o), p = c.pow(l, r);
    for (; !c.eql(p, c.ONE); ) {
      if (c.eql(p, c.ZERO))
        return c.ZERO;
      let g = 1;
      for (let m = c.sqr(p); g < u && !c.eql(m, c.ONE); g++)
        m = c.sqr(m);
      const h = c.pow(f, _1n$6 << BigInt(u - g - 1));
      f = c.sqr(h), d = c.mul(d, h), p = c.mul(p, f), u = g;
    }
    return d;
  };
}
function FpSqrt(t) {
  if (t % _4n === _3n$1) {
    const e = (t + _1n$6) / _4n;
    return function(n, i) {
      const o = n.pow(i, e);
      if (!n.eql(n.sqr(o), i))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (t % _8n$1 === _5n$1) {
    const e = (t - _5n$1) / _8n$1;
    return function(n, i) {
      const o = n.mul(i, _2n$3), a = n.pow(o, e), c = n.mul(i, a), l = n.mul(n.mul(c, _2n$3), a), u = n.mul(c, n.sub(l, n.ONE));
      if (!n.eql(n.sqr(u), i))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return tonelliShanks(t);
}
const isNegativeLE = (t, e) => (mod(t, e) & _1n$6) === _1n$6, FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(t) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = FIELD_FIELDS.reduce((n, i) => (n[i] = "function", n), e);
  return validateObject(t, r);
}
function FpPow(t, e, r) {
  if (r < _0n$4)
    throw new Error("Expected power > 0");
  if (r === _0n$4)
    return t.ONE;
  if (r === _1n$6)
    return e;
  let n = t.ONE, i = e;
  for (; r > _0n$4; )
    r & _1n$6 && (n = t.mul(n, i)), i = t.sqr(i), r >>= _1n$6;
  return n;
}
function FpInvertBatch(t, e) {
  const r = new Array(e.length), n = e.reduce((o, a, c) => t.is0(a) ? o : (r[c] = o, t.mul(o, a)), t.ONE), i = t.inv(n);
  return e.reduceRight((o, a, c) => t.is0(a) ? o : (r[c] = t.mul(o, r[c]), t.mul(o, a)), i), r;
}
function nLength(t, e) {
  const r = e !== void 0 ? e : t.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function Field(t, e, r = !1, n = {}) {
  if (t <= _0n$4)
    throw new Error(`Expected Fp ORDER > 0, got ${t}`);
  const { nBitLength: i, nByteLength: o } = nLength(t, e);
  if (o > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const a = FpSqrt(t), c = Object.freeze({
    ORDER: t,
    BITS: i,
    BYTES: o,
    MASK: bitMask(i),
    ZERO: _0n$4,
    ONE: _1n$6,
    create: (l) => mod(l, t),
    isValid: (l) => {
      if (typeof l != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);
      return _0n$4 <= l && l < t;
    },
    is0: (l) => l === _0n$4,
    isOdd: (l) => (l & _1n$6) === _1n$6,
    neg: (l) => mod(-l, t),
    eql: (l, u) => l === u,
    sqr: (l) => mod(l * l, t),
    add: (l, u) => mod(l + u, t),
    sub: (l, u) => mod(l - u, t),
    mul: (l, u) => mod(l * u, t),
    pow: (l, u) => FpPow(c, l, u),
    div: (l, u) => mod(l * invert(u, t), t),
    // Same as above, but doesn't normalize
    sqrN: (l) => l * l,
    addN: (l, u) => l + u,
    subN: (l, u) => l - u,
    mulN: (l, u) => l * u,
    inv: (l) => invert(l, t),
    sqrt: n.sqrt || ((l) => a(c, l)),
    invertBatch: (l) => FpInvertBatch(c, l),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (l, u, f) => f ? u : l,
    toBytes: (l) => r ? numberToBytesLE(l, o) : numberToBytesBE(l, o),
    fromBytes: (l) => {
      if (l.length !== o)
        throw new Error(`Fp.fromBytes: expected ${o}, got ${l.length}`);
      return r ? bytesToNumberLE(l) : bytesToNumberBE(l);
    }
  });
  return Object.freeze(c);
}
function FpSqrtEven(t, e) {
  if (!t.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = t.sqrt(e);
  return t.isOdd(r) ? t.neg(r) : r;
}
function hashToPrivateScalar(t, e, r = !1) {
  t = ensureBytes$1("privateHash", t);
  const n = t.length, i = nLength(e).nByteLength + 8;
  if (i < 24 || n < i || n > 1024)
    throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);
  const o = r ? bytesToNumberLE(t) : bytesToNumberBE(t);
  return mod(o, e - _1n$6) + _1n$6;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$5 = BigInt(1);
function wNAF(t, e) {
  const r = (i, o) => {
    const a = o.negate();
    return i ? a : o;
  }, n = (i) => {
    const o = Math.ceil(e / i) + 1, a = 2 ** (i - 1);
    return { windows: o, windowSize: a };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(i, o) {
      let a = t.ZERO, c = i;
      for (; o > _0n$3; )
        o & _1n$5 && (a = a.add(c)), c = c.double(), o >>= _1n$5;
      return a;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, o) {
      const { windows: a, windowSize: c } = n(o), l = [];
      let u = i, f = u;
      for (let d = 0; d < a; d++) {
        f = u, l.push(f);
        for (let p = 1; p < c; p++)
          f = f.add(u), l.push(f);
        u = f.double();
      }
      return l;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, o, a) {
      const { windows: c, windowSize: l } = n(i);
      let u = t.ZERO, f = t.BASE;
      const d = BigInt(2 ** i - 1), p = 2 ** i, g = BigInt(i);
      for (let h = 0; h < c; h++) {
        const m = h * l;
        let y = Number(a & d);
        a >>= g, y > l && (y -= p, a += _1n$5);
        const b = m, v = m + Math.abs(y) - 1, _ = h % 2 !== 0, E = y < 0;
        y === 0 ? f = f.add(r(_, o[b])) : u = u.add(r(E, o[v]));
      }
      return { p: u, f };
    },
    wNAFCached(i, o, a, c) {
      const l = i._WINDOW_SIZE || 1;
      let u = o.get(i);
      return u || (u = this.precomputeWindow(i, l), l !== 1 && o.set(i, c(u))), this.wNAF(l, u, a);
    }
  };
}
function validateBasic(t) {
  return validateField(t.Fp), validateObject(t, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(t.n, t.nBitLength),
    ...t,
    p: t.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(t) {
  const e = validateBasic(t);
  validateObject(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: i } = e;
  if (r) {
    if (!n.eql(i, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(t) {
    const { Err: e } = DER;
    if (t.length < 2 || t[0] !== 2)
      throw new e("Invalid signature integer tag");
    const r = t[1], n = t.subarray(2, r + 2);
    if (!r || n.length !== r)
      throw new e("Invalid signature integer: wrong length");
    if (n[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (n[0] === 0 && !(n[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(n), l: t.subarray(r + 2) };
  },
  toSig(t) {
    const { Err: e } = DER, r = typeof t == "string" ? h2b(t) : t;
    if (!(r instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = r.length;
    if (n < 2 || r[0] != 48)
      throw new e("Invalid signature tag");
    if (r[1] !== n - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: i, l: o } = DER._parseInt(r.subarray(2)), { d: a, l: c } = DER._parseInt(o);
    if (c.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: i, s: a };
  },
  hexFromSig(t) {
    const e = (u) => Number.parseInt(u[0], 16) & 8 ? "00" + u : u, r = (u) => {
      const f = u.toString(16);
      return f.length & 1 ? `0${f}` : f;
    }, n = e(r(t.s)), i = e(r(t.r)), o = n.length / 2, a = i.length / 2, c = r(o), l = r(a);
    return `30${r(a + o + 4)}02${l}${i}02${c}${n}`;
  }
}, _0n$2 = BigInt(0), _1n$4 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(t) {
  const e = validatePointOpts(t), { Fp: r } = e, n = e.toBytes || ((h, m, y) => {
    const b = m.toAffine();
    return concatBytes(Uint8Array.from([4]), r.toBytes(b.x), r.toBytes(b.y));
  }), i = e.fromBytes || ((h) => {
    const m = h.subarray(1), y = r.fromBytes(m.subarray(0, r.BYTES)), b = r.fromBytes(m.subarray(r.BYTES, 2 * r.BYTES));
    return { x: y, y: b };
  });
  function o(h) {
    const { a: m, b: y } = e, b = r.sqr(h), v = r.mul(b, h);
    return r.add(r.add(v, r.mul(h, m)), y);
  }
  if (!r.eql(r.sqr(e.Gy), o(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(h) {
    return typeof h == "bigint" && _0n$2 < h && h < e.n;
  }
  function c(h) {
    if (!a(h))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function l(h) {
    const { allowedPrivateKeyLengths: m, nByteLength: y, wrapPrivateKey: b, n: v } = e;
    if (m && typeof h != "bigint") {
      if (h instanceof Uint8Array && (h = bytesToHex(h)), typeof h != "string" || !m.includes(h.length))
        throw new Error("Invalid key");
      h = h.padStart(y * 2, "0");
    }
    let _;
    try {
      _ = typeof h == "bigint" ? h : bytesToNumberBE(ensureBytes$1("private key", h, y));
    } catch {
      throw new Error(`private key must be ${y} bytes, hex or bigint, not ${typeof h}`);
    }
    return b && (_ = mod(_, v)), c(_), _;
  }
  const u = /* @__PURE__ */ new Map();
  function f(h) {
    if (!(h instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  class d {
    constructor(m, y, b) {
      if (this.px = m, this.py = y, this.pz = b, m == null || !r.isValid(m))
        throw new Error("x required");
      if (y == null || !r.isValid(y))
        throw new Error("y required");
      if (b == null || !r.isValid(b))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(m) {
      const { x: y, y: b } = m || {};
      if (!m || !r.isValid(y) || !r.isValid(b))
        throw new Error("invalid affine point");
      if (m instanceof d)
        throw new Error("projective point not allowed");
      const v = (_) => r.eql(_, r.ZERO);
      return v(y) && v(b) ? d.ZERO : new d(y, b, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(m) {
      const y = r.invertBatch(m.map((b) => b.pz));
      return m.map((b, v) => b.toAffine(y[v])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(m) {
      const y = d.fromAffine(i(ensureBytes$1("pointHex", m)));
      return y.assertValidity(), y;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(m) {
      return d.BASE.multiply(l(m));
    }
    // "Private method", don't use it directly
    _setWindowSize(m) {
      this._WINDOW_SIZE = m, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: m, y } = this.toAffine();
      if (!r.isValid(m) || !r.isValid(y))
        throw new Error("bad point: x or y not FE");
      const b = r.sqr(y), v = o(m);
      if (!r.eql(b, v))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: m } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(m);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(m) {
      f(m);
      const { px: y, py: b, pz: v } = this, { px: _, py: E, pz: w } = m, S = r.eql(r.mul(y, w), r.mul(_, v)), x = r.eql(r.mul(b, w), r.mul(E, v));
      return S && x;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: m, b: y } = e, b = r.mul(y, _3n), { px: v, py: _, pz: E } = this;
      let w = r.ZERO, S = r.ZERO, x = r.ZERO, I = r.mul(v, v), C = r.mul(_, _), M = r.mul(E, E), O = r.mul(v, _);
      return O = r.add(O, O), x = r.mul(v, E), x = r.add(x, x), w = r.mul(m, x), S = r.mul(b, M), S = r.add(w, S), w = r.sub(C, S), S = r.add(C, S), S = r.mul(w, S), w = r.mul(O, w), x = r.mul(b, x), M = r.mul(m, M), O = r.sub(I, M), O = r.mul(m, O), O = r.add(O, x), x = r.add(I, I), I = r.add(x, I), I = r.add(I, M), I = r.mul(I, O), S = r.add(S, I), M = r.mul(_, E), M = r.add(M, M), I = r.mul(M, O), w = r.sub(w, I), x = r.mul(M, C), x = r.add(x, x), x = r.add(x, x), new d(w, S, x);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(m) {
      f(m);
      const { px: y, py: b, pz: v } = this, { px: _, py: E, pz: w } = m;
      let S = r.ZERO, x = r.ZERO, I = r.ZERO;
      const C = e.a, M = r.mul(e.b, _3n);
      let O = r.mul(y, _), B = r.mul(b, E), k = r.mul(v, w), U = r.add(y, b), R = r.add(_, E);
      U = r.mul(U, R), R = r.add(O, B), U = r.sub(U, R), R = r.add(y, v);
      let P = r.add(_, w);
      return R = r.mul(R, P), P = r.add(O, k), R = r.sub(R, P), P = r.add(b, v), S = r.add(E, w), P = r.mul(P, S), S = r.add(B, k), P = r.sub(P, S), I = r.mul(C, R), S = r.mul(M, k), I = r.add(S, I), S = r.sub(B, I), I = r.add(B, I), x = r.mul(S, I), B = r.add(O, O), B = r.add(B, O), k = r.mul(C, k), R = r.mul(M, R), B = r.add(B, k), k = r.sub(O, k), k = r.mul(C, k), R = r.add(R, k), O = r.mul(B, R), x = r.add(x, O), O = r.mul(P, R), S = r.mul(U, S), S = r.sub(S, O), O = r.mul(U, B), I = r.mul(P, I), I = r.add(I, O), new d(S, x, I);
    }
    subtract(m) {
      return this.add(m.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(m) {
      return g.wNAFCached(this, u, m, (y) => {
        const b = r.invertBatch(y.map((v) => v.pz));
        return y.map((v, _) => v.toAffine(b[_])).map(d.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(m) {
      const y = d.ZERO;
      if (m === _0n$2)
        return y;
      if (c(m), m === _1n$4)
        return this;
      const { endo: b } = e;
      if (!b)
        return g.unsafeLadder(this, m);
      let { k1neg: v, k1: _, k2neg: E, k2: w } = b.splitScalar(m), S = y, x = y, I = this;
      for (; _ > _0n$2 || w > _0n$2; )
        _ & _1n$4 && (S = S.add(I)), w & _1n$4 && (x = x.add(I)), I = I.double(), _ >>= _1n$4, w >>= _1n$4;
      return v && (S = S.negate()), E && (x = x.negate()), x = new d(r.mul(x.px, b.beta), x.py, x.pz), S.add(x);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(m) {
      c(m);
      let y = m, b, v;
      const { endo: _ } = e;
      if (_) {
        const { k1neg: E, k1: w, k2neg: S, k2: x } = _.splitScalar(y);
        let { p: I, f: C } = this.wNAF(w), { p: M, f: O } = this.wNAF(x);
        I = g.constTimeNegate(E, I), M = g.constTimeNegate(S, M), M = new d(r.mul(M.px, _.beta), M.py, M.pz), b = I.add(M), v = C.add(O);
      } else {
        const { p: E, f: w } = this.wNAF(y);
        b = E, v = w;
      }
      return d.normalizeZ([b, v])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(m, y, b) {
      const v = d.BASE, _ = (w, S) => S === _0n$2 || S === _1n$4 || !w.equals(v) ? w.multiplyUnsafe(S) : w.multiply(S), E = _(this, y).add(_(m, b));
      return E.is0() ? void 0 : E;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(m) {
      const { px: y, py: b, pz: v } = this, _ = this.is0();
      m == null && (m = _ ? r.ONE : r.inv(v));
      const E = r.mul(y, m), w = r.mul(b, m), S = r.mul(v, m);
      if (_)
        return { x: r.ZERO, y: r.ZERO };
      if (!r.eql(S, r.ONE))
        throw new Error("invZ was invalid");
      return { x: E, y: w };
    }
    isTorsionFree() {
      const { h: m, isTorsionFree: y } = e;
      if (m === _1n$4)
        return !0;
      if (y)
        return y(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: m, clearCofactor: y } = e;
      return m === _1n$4 ? this : y ? y(d, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(m = !0) {
      return this.assertValidity(), n(d, this, m);
    }
    toHex(m = !0) {
      return bytesToHex(this.toRawBytes(m));
    }
  }
  d.BASE = new d(e.Gx, e.Gy, r.ONE), d.ZERO = new d(r.ZERO, r.ONE, r.ZERO);
  const p = e.nBitLength, g = wNAF(d, e.endo ? Math.ceil(p / 2) : p);
  return {
    CURVE: e,
    ProjectivePoint: d,
    normPrivateKeyToScalar: l,
    weierstrassEquation: o,
    isWithinCurveOrder: a
  };
}
function validateOpts$2(t) {
  const e = validateBasic(t);
  return validateObject(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function weierstrass(t) {
  const e = validateOpts$2(t), { Fp: r, n } = e, i = r.BYTES + 1, o = 2 * r.BYTES + 1;
  function a(R) {
    return _0n$2 < R && R < r.ORDER;
  }
  function c(R) {
    return mod(R, n);
  }
  function l(R) {
    return invert(R, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: f, weierstrassEquation: d, isWithinCurveOrder: p } = weierstrassPoints({
    ...e,
    toBytes(R, P, T) {
      const L = P.toAffine(), A = r.toBytes(L.x), N = concatBytes;
      return T ? N(Uint8Array.from([P.hasEvenY() ? 2 : 3]), A) : N(Uint8Array.from([4]), A, r.toBytes(L.y));
    },
    fromBytes(R) {
      const P = R.length, T = R[0], L = R.subarray(1);
      if (P === i && (T === 2 || T === 3)) {
        const A = bytesToNumberBE(L);
        if (!a(A))
          throw new Error("Point is not on curve");
        const N = d(A);
        let D = r.sqrt(N);
        const F = (D & _1n$4) === _1n$4;
        return (T & 1) === 1 !== F && (D = r.neg(D)), { x: A, y: D };
      } else if (P === o && T === 4) {
        const A = r.fromBytes(L.subarray(0, r.BYTES)), N = r.fromBytes(L.subarray(r.BYTES, 2 * r.BYTES));
        return { x: A, y: N };
      } else
        throw new Error(`Point of length ${P} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`);
    }
  }), g = (R) => bytesToHex(numberToBytesBE(R, e.nByteLength));
  function h(R) {
    const P = n >> _1n$4;
    return R > P;
  }
  function m(R) {
    return h(R) ? c(-R) : R;
  }
  const y = (R, P, T) => bytesToNumberBE(R.slice(P, T));
  class b {
    constructor(P, T, L) {
      this.r = P, this.s = T, this.recovery = L, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(P) {
      const T = e.nByteLength;
      return P = ensureBytes$1("compactSignature", P, T * 2), new b(y(P, 0, T), y(P, T, 2 * T));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(P) {
      const { r: T, s: L } = DER.toSig(ensureBytes$1("DER", P));
      return new b(T, L);
    }
    assertValidity() {
      if (!p(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!p(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(P) {
      return new b(this.r, this.s, P);
    }
    recoverPublicKey(P) {
      const { r: T, s: L, recovery: A } = this, N = x(ensureBytes$1("msgHash", P));
      if (A == null || ![0, 1, 2, 3].includes(A))
        throw new Error("recovery id invalid");
      const D = A === 2 || A === 3 ? T + e.n : T;
      if (D >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const F = A & 1 ? "03" : "02", j = u.fromHex(F + g(D)), K = l(D), G = c(-N * K), W = c(L * K), H = u.BASE.multiplyAndAddUnsafe(j, G, W);
      if (!H)
        throw new Error("point at infinify");
      return H.assertValidity(), H;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return h(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new b(this.r, c(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return g(this.r) + g(this.s);
    }
  }
  const v = {
    isValidPrivateKey(R) {
      try {
        return f(R), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const R = e.randomBytes(r.BYTES + 8), P = hashToPrivateScalar(R, n);
      return numberToBytesBE(P, e.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(R = 8, P = u.BASE) {
      return P._setWindowSize(R), P.multiply(BigInt(3)), P;
    }
  };
  function _(R, P = !0) {
    return u.fromPrivateKey(R).toRawBytes(P);
  }
  function E(R) {
    const P = R instanceof Uint8Array, T = typeof R == "string", L = (P || T) && R.length;
    return P ? L === i || L === o : T ? L === 2 * i || L === 2 * o : R instanceof u;
  }
  function w(R, P, T = !0) {
    if (E(R))
      throw new Error("first arg must be private key");
    if (!E(P))
      throw new Error("second arg must be public key");
    return u.fromHex(P).multiply(f(R)).toRawBytes(T);
  }
  const S = e.bits2int || function(R) {
    const P = bytesToNumberBE(R), T = R.length * 8 - e.nBitLength;
    return T > 0 ? P >> BigInt(T) : P;
  }, x = e.bits2int_modN || function(R) {
    return c(S(R));
  }, I = bitMask(e.nBitLength);
  function C(R) {
    if (typeof R != "bigint")
      throw new Error("bigint expected");
    if (!(_0n$2 <= R && R < I))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return numberToBytesBE(R, e.nByteLength);
  }
  function M(R, P, T = O) {
    if (["recovered", "canonical"].some((z) => z in T))
      throw new Error("sign() legacy options not supported");
    const { hash: L, randomBytes: A } = e;
    let { lowS: N, prehash: D, extraEntropy: F } = T;
    N == null && (N = !0), R = ensureBytes$1("msgHash", R), D && (R = ensureBytes$1("prehashed msgHash", L(R)));
    const j = x(R), K = f(P), G = [C(K), C(j)];
    if (F != null) {
      const z = F === !0 ? A(r.BYTES) : F;
      G.push(ensureBytes$1("extraEntropy", z, r.BYTES));
    }
    const W = concatBytes(...G), H = j;
    function q(z) {
      const Z = S(z);
      if (!p(Z))
        return;
      const J = l(Z), ee = u.BASE.multiply(Z).toAffine(), Q = c(ee.x);
      if (Q === _0n$2)
        return;
      const ne = c(J * c(H + Q * K));
      if (ne === _0n$2)
        return;
      let ae = (ee.x === Q ? 0 : 2) | Number(ee.y & _1n$4), me = ne;
      return N && h(ne) && (me = m(ne), ae ^= 1), new b(Q, me, ae);
    }
    return { seed: W, k2sig: q };
  }
  const O = { lowS: e.lowS, prehash: !1 }, B = { lowS: e.lowS, prehash: !1 };
  function k(R, P, T = O) {
    const { seed: L, k2sig: A } = M(R, P, T), N = e;
    return createHmacDrbg(N.hash.outputLen, N.nByteLength, N.hmac)(L, A);
  }
  u.BASE._setWindowSize(8);
  function U(R, P, T, L = B) {
    var ee;
    const A = R;
    if (P = ensureBytes$1("msgHash", P), T = ensureBytes$1("publicKey", T), "strict" in L)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: N, prehash: D } = L;
    let F, j;
    try {
      if (typeof A == "string" || A instanceof Uint8Array)
        try {
          F = b.fromDER(A);
        } catch (Q) {
          if (!(Q instanceof DER.Err))
            throw Q;
          F = b.fromCompact(A);
        }
      else if (typeof A == "object" && typeof A.r == "bigint" && typeof A.s == "bigint") {
        const { r: Q, s: ne } = A;
        F = new b(Q, ne);
      } else
        throw new Error("PARSE");
      j = u.fromHex(T);
    } catch (Q) {
      if (Q.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (N && F.hasHighS())
      return !1;
    D && (P = e.hash(P));
    const { r: K, s: G } = F, W = x(P), H = l(G), q = c(W * H), z = c(K * H), Z = (ee = u.BASE.multiplyAndAddUnsafe(j, q, z)) == null ? void 0 : ee.toAffine();
    return Z ? c(Z.x) === K : !1;
  }
  return {
    CURVE: e,
    getPublicKey: _,
    getSharedSecret: w,
    sign: k,
    verify: U,
    ProjectivePoint: u,
    Signature: b,
    utils: v
  };
}
class HMAC extends Hash {
  constructor(e, r) {
    super(), this.finished = !1, this.destroyed = !1, assert$1.hash(e);
    const n = toBytes$3(r);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, o = new Uint8Array(i);
    o.set(n.length > i ? e.create().update(n).digest() : n);
    for (let a = 0; a < o.length; a++)
      o[a] ^= 54;
    this.iHash.update(o), this.oHash = e.create();
    for (let a = 0; a < o.length; a++)
      o[a] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(e) {
    return assert$1.exists(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    assert$1.exists(this), assert$1.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: a, outputLen: c } = this;
    return e = e, e.finished = i, e.destroyed = o, e.blockLen = a, e.outputLen = c, e.oHash = r._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (t, e, r) => new HMAC(t, e).update(r).digest();
hmac.create = (t, e) => new HMAC(t, e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(t) {
  return {
    hash: t,
    hmac: (e, ...r) => hmac(t, e, concatBytes$1(...r)),
    randomBytes: randomBytes$2
  };
}
function createCurve(t, e) {
  const r = (n) => weierstrass({ ...t, ...getHash(n) });
  return Object.freeze({ ...r(e), create: r });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n$3 = BigInt(1), _2n$2 = BigInt(2), divNearest = (t, e) => (t + e / _2n$2) / e;
function sqrtMod(t) {
  const e = secp256k1P, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), a = BigInt(23), c = BigInt(44), l = BigInt(88), u = t * t * t % e, f = u * u * t % e, d = pow2(f, r, e) * f % e, p = pow2(d, r, e) * f % e, g = pow2(p, _2n$2, e) * u % e, h = pow2(g, i, e) * g % e, m = pow2(h, o, e) * h % e, y = pow2(m, c, e) * m % e, b = pow2(y, l, e) * y % e, v = pow2(b, c, e) * m % e, _ = pow2(v, r, e) * f % e, E = pow2(_, a, e) * h % e, w = pow2(E, n, e) * u % e, S = pow2(w, _2n$2, e);
  if (!Fp$1.eql(Fp$1.sqr(S), t))
    throw new Error("Cannot find square root");
  return S;
}
const Fp$1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp$1,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (t) => {
      const e = secp256k1N, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -_1n$3 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, a = BigInt("0x100000000000000000000000000000000"), c = divNearest(o * t, e), l = divNearest(-n * t, e);
      let u = mod(t - c * r - l * i, e), f = mod(-c * n - l * o, e);
      const d = u > a, p = f > a;
      if (d && (u = e - u), p && (f = e - f), u > a || f > a)
        throw new Error("splitScalar: Endomorphism failed, k=" + t);
      return { k1neg: d, k1: u, k2neg: p, k2: f };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
function generateKey() {
  return secp256k1.utils.randomPrivateKey();
}
async function hashAndSign(t, e) {
  const { digest: r } = await sha256$2.digest(e);
  try {
    return secp256k1.sign(r, t).toDERRawBytes();
  } catch (n) {
    throw new CodeError$2(String(n), "ERR_INVALID_INPUT");
  }
}
async function hashAndVerify(t, e, r) {
  try {
    const { digest: n } = await sha256$2.digest(r);
    return secp256k1.verify(e, n, t);
  } catch (n) {
    throw new CodeError$2(String(n), "ERR_INVALID_INPUT");
  }
}
function compressPublicKey(t) {
  return secp256k1.ProjectivePoint.fromHex(t).toRawBytes(!0);
}
function validatePrivateKey(t) {
  try {
    secp256k1.getPublicKey(t, !0);
  } catch (e) {
    throw new CodeError$2(String(e), "ERR_INVALID_PRIVATE_KEY");
  }
}
function validatePublicKey(t) {
  try {
    secp256k1.ProjectivePoint.fromHex(t);
  } catch (e) {
    throw new CodeError$2(String(e), "ERR_INVALID_PUBLIC_KEY");
  }
}
function computePublicKey(t) {
  try {
    return secp256k1.getPublicKey(t, !0);
  } catch (e) {
    throw new CodeError$2(String(e), "ERR_INVALID_PRIVATE_KEY");
  }
}
class Secp256k1PublicKey {
  constructor(e) {
    $(this, "_key");
    validatePublicKey(e), this._key = e;
  }
  async verify(e, r) {
    return hashAndVerify(this._key, r, e);
  }
  marshal() {
    return compressPublicKey(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(e) {
    return equals$2(this.bytes, e.bytes);
  }
  async hash() {
    const { bytes: e } = await sha256$2.digest(this.bytes);
    return e;
  }
}
class Secp256k1PrivateKey {
  constructor(e, r) {
    $(this, "_key");
    $(this, "_publicKey");
    this._key = e, this._publicKey = r ?? computePublicKey(e), validatePrivateKey(this._key), validatePublicKey(this._publicKey);
  }
  async sign(e) {
    return hashAndSign(this._key, e);
  }
  get public() {
    return new Secp256k1PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(e) {
    return equals$2(this.bytes, e.bytes);
  }
  async hash() {
    const { bytes: e } = await sha256$2.digest(this.bytes);
    return e;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const e = await this.public.hash();
    return toString$4(e, "base58btc");
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(e, r = "libp2p-key") {
    if (r === "libp2p-key")
      return exporter(this.bytes, e);
    throw new CodeError$2(`export format '${r}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
  }
}
function unmarshalSecp256k1PrivateKey(t) {
  return new Secp256k1PrivateKey(t);
}
function unmarshalSecp256k1PublicKey(t) {
  return new Secp256k1PublicKey(t);
}
async function generateKeyPair$1() {
  const t = generateKey();
  return new Secp256k1PrivateKey(t);
}
const Secp256k1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Secp256k1PrivateKey,
  Secp256k1PublicKey,
  generateKeyPair: generateKeyPair$1,
  unmarshalSecp256k1PrivateKey,
  unmarshalSecp256k1PublicKey
}, Symbol.toStringTag, { value: "Module" })), supportedKeys = {
  rsa: RSA,
  ed25519: Ed25519,
  secp256k1: Secp256k1
};
function unsupportedKey(t) {
  const e = Object.keys(supportedKeys).join(" / ");
  return new CodeError$2(`invalid or unsupported key type ${t}. Must be ${e}`, "ERR_UNSUPPORTED_KEY_TYPE");
}
function typeToKey(t) {
  if (t = t.toLowerCase(), t === "rsa" || t === "ed25519" || t === "secp256k1")
    return supportedKeys[t];
  throw unsupportedKey(t);
}
async function generateKeyPair(t, e) {
  return typeToKey(t).generateKeyPair(e ?? 2048);
}
async function generateKeyPairFromSeed(t, e, r) {
  if (t.toLowerCase() !== "ed25519")
    throw new CodeError$2("Seed key derivation is unimplemented for RSA or secp256k1", "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
  return generateKeyPairFromSeed$1(e);
}
function unmarshalPublicKey(t) {
  const e = PublicKey.decode(t), r = e.Data ?? new Uint8Array();
  switch (e.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(r);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(r);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(r);
    default:
      throw unsupportedKey(e.Type ?? "RSA");
  }
}
function marshalPublicKey(t, e) {
  return e = (e ?? "rsa").toLowerCase(), typeToKey(e), t.bytes;
}
async function unmarshalPrivateKey(t) {
  const e = PrivateKey.decode(t), r = e.Data ?? new Uint8Array();
  switch (e.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPrivateKey(r);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(r);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(r);
    default:
      throw unsupportedKey(e.Type ?? "RSA");
  }
}
function marshalPrivateKey(t, e) {
  return e = (e ?? "rsa").toLowerCase(), typeToKey(e), t.bytes;
}
async function importKey(t, e) {
  try {
    const i = await importer(t, e);
    return await unmarshalPrivateKey(i);
  } catch {
  }
  const r = forge$m.pki.decryptRsaPrivateKey(t, e);
  if (r === null)
    throw new CodeError$2("Cannot read the key, most likely the password is wrong or not a RSA key", "ERR_CANNOT_DECRYPT_PEM");
  let n = forge$m.asn1.toDer(forge$m.pki.privateKeyToAsn1(r));
  return n = fromString$3(n.getBytes(), "ascii"), supportedKeys.rsa.unmarshalRsaPrivateKey(n);
}
const contentRouting = Symbol.for("@libp2p/content-routing");
var se, tt;
let EventEmitter$2 = (tt = class extends EventTarget {
  constructor() {
    super(...arguments);
    ie(this, se, /* @__PURE__ */ new Map());
  }
  listenerCount(r) {
    const n = Y(this, se).get(r);
    return n == null ? 0 : n.length;
  }
  addEventListener(r, n, i) {
    super.addEventListener(r, n, i);
    let o = Y(this, se).get(r);
    o == null && (o = [], Y(this, se).set(r, o)), o.push({
      callback: n,
      once: (i !== !0 && i !== !1 && (i == null ? void 0 : i.once)) ?? !1
    });
  }
  removeEventListener(r, n, i) {
    super.removeEventListener(r.toString(), n ?? null, i);
    let o = Y(this, se).get(r);
    o != null && (o = o.filter(({ callback: a }) => a !== n), Y(this, se).set(r, o));
  }
  dispatchEvent(r) {
    const n = super.dispatchEvent(r);
    let i = Y(this, se).get(r.type);
    return i == null || (i = i.filter(({ once: o }) => !o), Y(this, se).set(r.type, i)), n;
  }
  safeDispatchEvent(r, n) {
    return this.dispatchEvent(new CustomEvent(r, n));
  }
}, se = new WeakMap(), tt);
class CustomEventPolyfill extends Event {
  constructor(r, n) {
    super(r, n);
    /** Returns any custom data event was created with. Typically used for synthetic events. */
    $(this, "detail");
    this.detail = n == null ? void 0 : n.detail;
  }
}
const CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill, peerDiscovery = Symbol.for("@libp2p/peer-discovery"), peerRouting = Symbol.for("@libp2p/peer-routing");
crypto$3.createCipheriv;
crypto$3.createDecipheriv;
const hashName = {
  sha1: "sha1",
  "sha2-256": "sha256",
  "sha2-512": "sha512"
};
function pbkdf2(t, e, r, n, i) {
  if (i !== "sha1" && i !== "sha2-256" && i !== "sha2-512") {
    const c = Object.keys(hashName).join(" / ");
    throw new CodeError$2(`Hash '${i}' is unknown or not supported. Must be ${c}`, "ERR_UNSUPPORTED_HASH_TYPE");
  }
  const o = hashName[i], a = pbkdf2$1(t, e, r, n, o);
  return utilExports.encode64(a, null);
}
var srcExports = {}, src$2 = {
  get exports() {
    return srcExports;
  },
  set exports(t) {
    srcExports = t;
  }
}, browserExports = {}, browser = {
  get exports() {
    return browserExports;
  },
  set exports(t) {
    browserExports = t;
  }
}, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 7, o = n * 365.25;
  ms = function(f, d) {
    d = d || {};
    var p = typeof f;
    if (p === "string" && f.length > 0)
      return a(f);
    if (p === "number" && isFinite(f))
      return d.long ? l(f) : c(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(f)
    );
  };
  function a(f) {
    if (f = String(f), !(f.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        f
      );
      if (d) {
        var p = parseFloat(d[1]), g = (d[2] || "ms").toLowerCase();
        switch (g) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * o;
          case "weeks":
          case "week":
          case "w":
            return p * i;
          case "days":
          case "day":
          case "d":
            return p * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function c(f) {
    var d = Math.abs(f);
    return d >= n ? Math.round(f / n) + "d" : d >= r ? Math.round(f / r) + "h" : d >= e ? Math.round(f / e) + "m" : d >= t ? Math.round(f / t) + "s" : f + "ms";
  }
  function l(f) {
    var d = Math.abs(f);
    return d >= n ? u(f, d, n, "day") : d >= r ? u(f, d, r, "hour") : d >= e ? u(f, d, e, "minute") : d >= t ? u(f, d, t, "second") : f + " ms";
  }
  function u(f, d, p, g) {
    var h = d >= p * 1.5;
    return Math.round(f / p) + " " + g + (h ? "s" : "");
  }
  return ms;
}
var common, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  function t(e) {
    n.debug = n, n.default = n, n.coerce = u, n.disable = a, n.enable = o, n.enabled = c, n.humanize = requireMs(), n.destroy = f, Object.keys(e).forEach((d) => {
      n[d] = e[d];
    }), n.names = [], n.skips = [], n.formatters = {};
    function r(d) {
      let p = 0;
      for (let g = 0; g < d.length; g++)
        p = (p << 5) - p + d.charCodeAt(g), p |= 0;
      return n.colors[Math.abs(p) % n.colors.length];
    }
    n.selectColor = r;
    function n(d) {
      let p, g = null, h, m;
      function y(...b) {
        if (!y.enabled)
          return;
        const v = y, _ = Number(new Date()), E = _ - (p || _);
        v.diff = E, v.prev = p, v.curr = _, p = _, b[0] = n.coerce(b[0]), typeof b[0] != "string" && b.unshift("%O");
        let w = 0;
        b[0] = b[0].replace(/%([a-zA-Z%])/g, (x, I) => {
          if (x === "%%")
            return "%";
          w++;
          const C = n.formatters[I];
          if (typeof C == "function") {
            const M = b[w];
            x = C.call(v, M), b.splice(w, 1), w--;
          }
          return x;
        }), n.formatArgs.call(v, b), (v.log || n.log).apply(v, b);
      }
      return y.namespace = d, y.useColors = n.useColors(), y.color = n.selectColor(d), y.extend = i, y.destroy = n.destroy, Object.defineProperty(y, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => g !== null ? g : (h !== n.namespaces && (h = n.namespaces, m = n.enabled(d)), m),
        set: (b) => {
          g = b;
        }
      }), typeof n.init == "function" && n.init(y), y;
    }
    function i(d, p) {
      const g = n(this.namespace + (typeof p > "u" ? ":" : p) + d);
      return g.log = this.log, g;
    }
    function o(d) {
      n.save(d), n.namespaces = d, n.names = [], n.skips = [];
      let p;
      const g = (typeof d == "string" ? d : "").split(/[\s,]+/), h = g.length;
      for (p = 0; p < h; p++)
        g[p] && (d = g[p].replace(/\*/g, ".*?"), d[0] === "-" ? n.skips.push(new RegExp("^" + d.slice(1) + "$")) : n.names.push(new RegExp("^" + d + "$")));
    }
    function a() {
      const d = [
        ...n.names.map(l),
        ...n.skips.map(l).map((p) => "-" + p)
      ].join(",");
      return n.enable(""), d;
    }
    function c(d) {
      if (d[d.length - 1] === "*")
        return !0;
      let p, g;
      for (p = 0, g = n.skips.length; p < g; p++)
        if (n.skips[p].test(d))
          return !1;
      for (p = 0, g = n.names.length; p < g; p++)
        if (n.names[p].test(d))
          return !0;
      return !1;
    }
    function l(d) {
      return d.toString().substring(2, d.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function u(d) {
      return d instanceof Error ? d.stack || d.message : d;
    }
    function f() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return n.enable(n.load()), n;
  }
  return common = t, common;
}
var hasRequiredBrowser;
function requireBrowser() {
  return hasRequiredBrowser || (hasRequiredBrowser = 1, function(t, e) {
    e.formatArgs = n, e.save = i, e.load = o, e.useColors = r, e.storage = a(), e.destroy = (() => {
      let l = !1;
      return () => {
        l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), e.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(l) {
      if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
        return;
      const u = "color: " + this.color;
      l.splice(1, 0, u, "color: inherit");
      let f = 0, d = 0;
      l[0].replace(/%[a-zA-Z%]/g, (p) => {
        p !== "%%" && (f++, p === "%c" && (d = f));
      }), l.splice(d, 0, u);
    }
    e.log = console.debug || console.log || (() => {
    });
    function i(l) {
      try {
        l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
      } catch {
      }
    }
    function o() {
      let l;
      try {
        l = e.storage.getItem("debug");
      } catch {
      }
      return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
    }
    function a() {
      try {
        return localStorage;
      } catch {
      }
    }
    t.exports = requireCommon()(e);
    const { formatters: c } = t.exports;
    c.j = function(l) {
      try {
        return JSON.stringify(l);
      } catch (u) {
        return "[UnexpectedJSONParseError]: " + u.message;
      }
    };
  }(browser, browserExports)), browserExports;
}
var nodeExports = {}, node$1 = {
  get exports() {
    return nodeExports;
  },
  set exports(t) {
    nodeExports = t;
  }
}, hasFlag, hasRequiredHasFlag;
function requireHasFlag() {
  return hasRequiredHasFlag || (hasRequiredHasFlag = 1, hasFlag = (t, e = process.argv) => {
    const r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", n = e.indexOf(r + t), i = e.indexOf("--");
    return n !== -1 && (i === -1 || n < i);
  }), hasFlag;
}
var supportsColor_1, hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor)
    return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const t = require$$0, e = require$$1, r = requireHasFlag(), { env: n } = process;
  let i;
  r("no-color") || r("no-colors") || r("color=false") || r("color=never") ? i = 0 : (r("color") || r("colors") || r("color=true") || r("color=always")) && (i = 1);
  function o() {
    if ("FORCE_COLOR" in n)
      return n.FORCE_COLOR === "true" ? 1 : n.FORCE_COLOR === "false" ? 0 : n.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(n.FORCE_COLOR, 10), 3);
  }
  function a(u) {
    return u === 0 ? !1 : {
      level: u,
      hasBasic: !0,
      has256: u >= 2,
      has16m: u >= 3
    };
  }
  function c(u, { streamIsTTY: f, sniffFlags: d = !0 } = {}) {
    const p = o();
    p !== void 0 && (i = p);
    const g = d ? i : p;
    if (g === 0)
      return 0;
    if (d) {
      if (r("color=16m") || r("color=full") || r("color=truecolor"))
        return 3;
      if (r("color=256"))
        return 2;
    }
    if (u && !f && g === void 0)
      return 0;
    const h = g || 0;
    if (n.TERM === "dumb")
      return h;
    if (process.platform === "win32") {
      const m = t.release().split(".");
      return Number(m[0]) >= 10 && Number(m[2]) >= 10586 ? Number(m[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in n)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((m) => m in n) || n.CI_NAME === "codeship" ? 1 : h;
    if ("TEAMCITY_VERSION" in n)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(n.TEAMCITY_VERSION) ? 1 : 0;
    if (n.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in n) {
      const m = Number.parseInt((n.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (n.TERM_PROGRAM) {
        case "iTerm.app":
          return m >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(n.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(n.TERM) || "COLORTERM" in n ? 1 : h;
  }
  function l(u, f = {}) {
    const d = c(u, {
      streamIsTTY: u && u.isTTY,
      ...f
    });
    return a(d);
  }
  return supportsColor_1 = {
    supportsColor: l,
    stdout: l({ isTTY: e.isatty(1) }),
    stderr: l({ isTTY: e.isatty(2) })
  }, supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  return hasRequiredNode || (hasRequiredNode = 1, function(t, e) {
    const r = require$$1, n = require$$1$1;
    e.init = f, e.log = c, e.formatArgs = o, e.save = l, e.load = u, e.useColors = i, e.destroy = n.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), e.colors = [6, 2, 3, 4, 5, 1];
    try {
      const p = requireSupportsColor();
      p && (p.stderr || p).level >= 2 && (e.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    e.inspectOpts = Object.keys(process.env).filter((p) => /^debug_/i.test(p)).reduce((p, g) => {
      const h = g.substring(6).toLowerCase().replace(/_([a-z])/g, (y, b) => b.toUpperCase());
      let m = process.env[g];
      return /^(yes|on|true|enabled)$/i.test(m) ? m = !0 : /^(no|off|false|disabled)$/i.test(m) ? m = !1 : m === "null" ? m = null : m = Number(m), p[h] = m, p;
    }, {});
    function i() {
      return "colors" in e.inspectOpts ? Boolean(e.inspectOpts.colors) : r.isatty(process.stderr.fd);
    }
    function o(p) {
      const { namespace: g, useColors: h } = this;
      if (h) {
        const m = this.color, y = "\x1B[3" + (m < 8 ? m : "8;5;" + m), b = `  ${y};1m${g} \x1B[0m`;
        p[0] = b + p[0].split(`
`).join(`
` + b), p.push(y + "m+" + t.exports.humanize(this.diff) + "\x1B[0m");
      } else
        p[0] = a() + g + " " + p[0];
    }
    function a() {
      return e.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
    }
    function c(...p) {
      return process.stderr.write(n.format(...p) + `
`);
    }
    function l(p) {
      p ? process.env.DEBUG = p : delete process.env.DEBUG;
    }
    function u() {
      return process.env.DEBUG;
    }
    function f(p) {
      p.inspectOpts = {};
      const g = Object.keys(e.inspectOpts);
      for (let h = 0; h < g.length; h++)
        p.inspectOpts[g[h]] = e.inspectOpts[g[h]];
    }
    t.exports = requireCommon()(e);
    const { formatters: d } = t.exports;
    d.o = function(p) {
      return this.inspectOpts.colors = this.useColors, n.inspect(p, this.inspectOpts).split(`
`).map((g) => g.trim()).join(" ");
    }, d.O = function(p) {
      return this.inspectOpts.colors = this.useColors, n.inspect(p, this.inspectOpts);
    };
  }(node$1, nodeExports)), nodeExports;
}
(function(t) {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? t.exports = requireBrowser() : t.exports = requireNode();
})(src$2);
const DebugLogger = /* @__PURE__ */ getDefaultExportFromCjs(srcExports);
DebugLogger.formatters.b = (t) => t == null ? "undefined" : base58btc$1.baseEncode(t);
DebugLogger.formatters.t = (t) => t == null ? "undefined" : base32$2.baseEncode(t);
DebugLogger.formatters.m = (t) => t == null ? "undefined" : base64$5.baseEncode(t);
DebugLogger.formatters.p = (t) => t == null ? "undefined" : t.toString();
DebugLogger.formatters.c = (t) => t == null ? "undefined" : t.toString();
DebugLogger.formatters.k = (t) => t == null ? "undefined" : t.toString();
DebugLogger.formatters.a = (t) => t == null ? "undefined" : t.toString();
function createDisabledLogger(t) {
  const e = () => {
  };
  return e.enabled = !1, e.color = "", e.diff = 0, e.log = () => {
  }, e.namespace = t, e.destroy = () => !0, e.extend = () => e, e;
}
function logger$1(t) {
  let e = createDisabledLogger(`${t}:trace`);
  return DebugLogger.enabled(`${t}:trace`) && DebugLogger.names.map((r) => r.toString()).find((r) => r.includes(":trace")) != null && (e = DebugLogger(`${t}:trace`)), Object.assign(DebugLogger(t), {
    error: DebugLogger(`${t}:error`),
    trace: e
  });
}
const symbol$4 = Symbol.for("@libp2p/peer-id");
function isPeerId(t) {
  return t != null && Boolean(t[symbol$4]);
}
const inspect$2 = Symbol.for("nodejs.util.inspect.custom"), baseDecoder = Object.values(bases$1).map((t) => t.decoder).reduce((t, e) => t.or(e), bases$1.identity.decoder), LIBP2P_KEY_CODE = 114, MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36, MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
var sn;
class PeerIdImpl {
  constructor(e) {
    $(this, "type");
    $(this, "multihash");
    $(this, "privateKey");
    $(this, "publicKey");
    $(this, "string");
    $(this, sn, !0);
    this.type = e.type, this.multihash = e.multihash, this.privateKey = e.privateKey, Object.defineProperty(this, "string", {
      enumerable: !1,
      writable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    return this.string == null && (this.string = base58btc$1.encode(this.multihash.bytes).slice(1)), this.string;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID$1.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  /**
   * Returns Multiaddr as a JSON string
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(e) {
    var r;
    if (e instanceof Uint8Array)
      return equals$2(this.multihash.bytes, e);
    if (typeof e == "string")
      return peerIdFromString(e).equals(this);
    if (((r = e == null ? void 0 : e.multihash) == null ? void 0 : r.bytes) != null)
      return equals$2(this.multihash.bytes, e.multihash.bytes);
    throw new Error("not valid Id");
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(sn = symbol$4, inspect$2)]() {
    return `PeerId(${this.toString()})`;
  }
}
class RSAPeerIdImpl extends PeerIdImpl {
  constructor(r) {
    super({ ...r, type: "RSA" });
    $(this, "type", "RSA");
    $(this, "publicKey");
    this.publicKey = r.publicKey;
  }
}
class Ed25519PeerIdImpl extends PeerIdImpl {
  constructor(r) {
    super({ ...r, type: "Ed25519" });
    $(this, "type", "Ed25519");
    $(this, "publicKey");
    this.publicKey = r.multihash.digest;
  }
}
class Secp256k1PeerIdImpl extends PeerIdImpl {
  constructor(r) {
    super({ ...r, type: "secp256k1" });
    $(this, "type", "secp256k1");
    $(this, "publicKey");
    this.publicKey = r.multihash.digest;
  }
}
function peerIdFromPeerId(t) {
  if (t.type === "RSA")
    return new RSAPeerIdImpl(t);
  if (t.type === "Ed25519")
    return new Ed25519PeerIdImpl(t);
  if (t.type === "secp256k1")
    return new Secp256k1PeerIdImpl(t);
  throw new CodeError$2("Not a PeerId", "ERR_INVALID_PARAMETERS");
}
function peerIdFromString(t, e) {
  if (t.charAt(0) === "1" || t.charAt(0) === "Q") {
    const r = decode$a(base58btc$1.decode(`z${t}`));
    return t.startsWith("12D") ? new Ed25519PeerIdImpl({ multihash: r }) : t.startsWith("16U") ? new Secp256k1PeerIdImpl({ multihash: r }) : new RSAPeerIdImpl({ multihash: r });
  }
  return peerIdFromBytes(baseDecoder.decode(t));
}
function peerIdFromBytes(t) {
  try {
    const e = decode$a(t);
    if (e.code === identity$3.code) {
      if (e.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH)
        return new Ed25519PeerIdImpl({ multihash: e });
      if (e.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH)
        return new Secp256k1PeerIdImpl({ multihash: e });
    }
    if (e.code === sha256$2.code)
      return new RSAPeerIdImpl({ multihash: e });
  } catch {
    return peerIdFromCID(CID$1.decode(t));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(t) {
  if (t == null || t.multihash == null || t.version == null || t.version === 1 && t.code !== LIBP2P_KEY_CODE)
    throw new Error("Supplied PeerID CID is invalid");
  const e = t.multihash;
  if (e.code === sha256$2.code)
    return new RSAPeerIdImpl({ multihash: t.multihash });
  if (e.code === identity$3.code) {
    if (e.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH)
      return new Ed25519PeerIdImpl({ multihash: t.multihash });
    if (e.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH)
      return new Secp256k1PeerIdImpl({ multihash: t.multihash });
  }
  throw new Error("Supplied PeerID CID is invalid");
}
async function peerIdFromKeys(t, e) {
  return t.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH ? new Ed25519PeerIdImpl({ multihash: create$6(identity$3.code, t), privateKey: e }) : t.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH ? new Secp256k1PeerIdImpl({ multihash: create$6(identity$3.code, t), privateKey: e }) : new RSAPeerIdImpl({ multihash: await sha256$2.digest(t), publicKey: t, privateKey: e });
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", POOL_SIZE_MULTIPLIER = 128;
let pool, poolOffset, fillPool = (t) => {
  !pool || pool.length < t ? (pool = Buffer.allocUnsafe(t * POOL_SIZE_MULTIPLIER), randomFillSync$1(pool), poolOffset = 0) : poolOffset + t > pool.length && (randomFillSync$1(pool), poolOffset = 0), poolOffset += t;
}, nanoid = (t = 21) => {
  fillPool(t -= 0);
  let e = "";
  for (let r = poolOffset - t; r < poolOffset; r++)
    e += urlAlphabet[pool[r] & 63];
  return e;
};
function base$2(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var o = t.charAt(i), a = o.charCodeAt(0);
    if (r[a] !== 255)
      throw new TypeError(o + " is ambiguous");
    r[a] = i;
  }
  var c = t.length, l = t.charAt(0), u = Math.log(c) / Math.log(256), f = Math.log(256) / Math.log(c);
  function d(h) {
    if (h instanceof Uint8Array || (ArrayBuffer.isView(h) ? h = new Uint8Array(h.buffer, h.byteOffset, h.byteLength) : Array.isArray(h) && (h = Uint8Array.from(h))), !(h instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (h.length === 0)
      return "";
    for (var m = 0, y = 0, b = 0, v = h.length; b !== v && h[b] === 0; )
      b++, m++;
    for (var _ = (v - b) * f + 1 >>> 0, E = new Uint8Array(_); b !== v; ) {
      for (var w = h[b], S = 0, x = _ - 1; (w !== 0 || S < y) && x !== -1; x--, S++)
        w += 256 * E[x] >>> 0, E[x] = w % c >>> 0, w = w / c >>> 0;
      if (w !== 0)
        throw new Error("Non-zero carry");
      y = S, b++;
    }
    for (var I = _ - y; I !== _ && E[I] === 0; )
      I++;
    for (var C = l.repeat(m); I < _; ++I)
      C += t.charAt(E[I]);
    return C;
  }
  function p(h) {
    if (typeof h != "string")
      throw new TypeError("Expected String");
    if (h.length === 0)
      return new Uint8Array();
    var m = 0;
    if (h[m] !== " ") {
      for (var y = 0, b = 0; h[m] === l; )
        y++, m++;
      for (var v = (h.length - m) * u + 1 >>> 0, _ = new Uint8Array(v); h[m]; ) {
        var E = r[h.charCodeAt(m)];
        if (E === 255)
          return;
        for (var w = 0, S = v - 1; (E !== 0 || w < b) && S !== -1; S--, w++)
          E += c * _[S] >>> 0, _[S] = E % 256 >>> 0, E = E / 256 >>> 0;
        if (E !== 0)
          throw new Error("Non-zero carry");
        b = w, m++;
      }
      if (h[m] !== " ") {
        for (var x = v - b; x !== v && _[x] === 0; )
          x++;
        for (var I = new Uint8Array(y + (v - x)), C = y; x !== v; )
          I[C++] = _[x++];
        return I;
      }
    }
  }
  function g(h) {
    var m = p(h);
    if (m)
      return m;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: d,
    decodeUnsafe: p,
    decode: g
  };
}
var src$1 = base$2, _brrp__multiformats_scope_baseX = src$1;
const equals$1 = (t, e) => {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}, coerce = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fromString$2 = (t) => new TextEncoder().encode(t), toString$3 = (t) => new TextDecoder().decode(t);
class Encoder {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
let Decoder$1 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = /** @type {number} */
    r.codePointAt(0), this.baseDecode = n;
  }
  /**
   * @param {string} text
   */
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return or$2(this, e);
  }
};
class ComposedDecoder {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(e) {
    this.decoders = e;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return or$2(this, e);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(e) {
    const r = (
      /** @type {Prefix} */
      e[0]
    ), n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$2 = (t, e) => new ComposedDecoder(
  /** @type {Decoders<L|R>} */
  {
    ...t.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      t.prefix
    ]: t },
    ...e.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      e.prefix
    ]: e }
  }
);
class Codec {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new Encoder(e, r, n), this.decoder = new Decoder$1(e, r, i);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(e) {
    return this.encoder.encode(e);
  }
  /**
   * @param {string} input
   */
  decode(e) {
    return this.decoder.decode(e);
  }
}
const from$3 = ({ name: t, prefix: e, encode: r, decode: n }) => new Codec(t, e, r, n), baseX = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = _brrp__multiformats_scope_baseX(r, e);
  return from$3({
    prefix: t,
    name: e,
    encode: n,
    /**
     * @param {string} text
     */
    decode: (o) => coerce(i(o))
  });
}, decode$9 = (t, e, r, n) => {
  const i = {};
  for (let f = 0; f < e.length; ++f)
    i[e[f]] = f;
  let o = t.length;
  for (; t[o - 1] === "="; )
    --o;
  const a = new Uint8Array(o * r / 8 | 0);
  let c = 0, l = 0, u = 0;
  for (let f = 0; f < o; ++f) {
    const d = i[t[f]];
    if (d === void 0)
      throw new SyntaxError(`Non-${n} character`);
    l = l << r | d, c += r, c >= 8 && (c -= 8, a[u++] = 255 & l >> c);
  }
  if (c >= r || 255 & l << 8 - c)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, encode$7 = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let o = "", a = 0, c = 0;
  for (let l = 0; l < t.length; ++l)
    for (c = c << 8 | t[l], a += 8; a > r; )
      a -= r, o += e[i & c >> a];
  if (a && (o += e[i & c << r - a]), n)
    for (; o.length * r & 7; )
      o += "=";
  return o;
}, rfc4648 = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => from$3({
  prefix: e,
  name: t,
  encode(i) {
    return encode$7(i, n, r);
  },
  decode(i) {
    return decode$9(i, n, r, t);
  }
}), identity$2 = from$3({
  prefix: "\0",
  name: "identity",
  encode: (t) => toString$3(t),
  decode: (t) => fromString$2(t)
}), identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$2
}, Symbol.toStringTag, { value: "Module" })), base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" })), base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" })), base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" })), base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" })), base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" })), base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" })), base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" })), base64$1 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), base64$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$1,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" })), alphabet = Array.from(""), alphabetBytesToChars = (
  /** @type {string[]} */
  alphabet.reduce(
    (t, e, r) => (t[r] = e, t),
    /** @type {string[]} */
    []
  )
), alphabetCharsToBytes = (
  /** @type {number[]} */
  alphabet.reduce(
    (t, e, r) => (t[
      /** @type {number} */
      e.codePointAt(0)
    ] = r, t),
    /** @type {number[]} */
    []
  )
);
function encode$6(t) {
  return t.reduce((e, r) => (e += alphabetBytesToChars[r], e), "");
}
function decode$8(t) {
  const e = [];
  for (const r of t) {
    const n = alphabetCharsToBytes[
      /** @type {number} */
      r.codePointAt(0)
    ];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const base256emoji = from$3({
  prefix: "",
  name: "base256emoji",
  encode: encode$6,
  decode: decode$8
}), base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
var encode_1$1 = encode$5, MSB$3 = 128, REST$3 = 127, MSBALL$1 = ~REST$3, INT$1 = Math.pow(2, 31);
function encode$5(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= INT$1; )
    e[r++] = t & 255 | MSB$3, t /= 128;
  for (; t & MSBALL$1; )
    e[r++] = t & 255 | MSB$3, t >>>= 7;
  return e[r] = t | 0, encode$5.bytes = r - n + 1, e;
}
var decode$7 = read$2, MSB$1$1 = 128, REST$1$1 = 127;
function read$2(t, n) {
  var r = 0, n = n || 0, i = 0, o = n, a, c = t.length;
  do {
    if (o >= c)
      throw read$2.bytes = 0, new RangeError("Could not decode varint");
    a = t[o++], r += i < 28 ? (a & REST$1$1) << i : (a & REST$1$1) * Math.pow(2, i), i += 7;
  } while (a >= MSB$1$1);
  return read$2.bytes = o - n, r;
}
var N1$2 = Math.pow(2, 7), N2$2 = Math.pow(2, 14), N3$2 = Math.pow(2, 21), N4$2 = Math.pow(2, 28), N5$2 = Math.pow(2, 35), N6$2 = Math.pow(2, 42), N7$2 = Math.pow(2, 49), N8$1 = Math.pow(2, 56), N9$1 = Math.pow(2, 63), length$1 = function(t) {
  return t < N1$2 ? 1 : t < N2$2 ? 2 : t < N3$2 ? 3 : t < N4$2 ? 4 : t < N5$2 ? 5 : t < N6$2 ? 6 : t < N7$2 ? 7 : t < N8$1 ? 8 : t < N9$1 ? 9 : 10;
}, varint$1 = {
  encode: encode_1$1,
  decode: decode$7,
  encodingLength: length$1
}, _brrp_varint = varint$1;
const decode$6 = (t, e = 0) => [_brrp_varint.decode(t, e), _brrp_varint.decode.bytes], encodeTo = (t, e, r = 0) => (_brrp_varint.encode(t, e, r), e), encodingLength$1 = (t) => _brrp_varint.encodingLength(t), create$2 = (t, e) => {
  const r = e.byteLength, n = encodingLength$1(t), i = n + encodingLength$1(r), o = new Uint8Array(i + r);
  return encodeTo(t, o, 0), encodeTo(r, o, n), o.set(e, i), new Digest(t, r, e, o);
}, decode$5 = (t) => {
  const e = coerce(t), [r, n] = decode$6(e), [i, o] = decode$6(e.subarray(n)), a = e.subarray(n + o);
  if (a.byteLength !== i)
    throw new Error("Incorrect length");
  return new Digest(r, i, a, e);
}, equals = (t, e) => {
  if (t === e)
    return !0;
  {
    const r = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      e
    );
    return t.code === r.code && t.size === r.size && r.bytes instanceof Uint8Array && equals$1(t.bytes, r.bytes);
  }
};
class Digest {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(e, r, n, i) {
    this.code = e, this.size = r, this.digest = n, this.bytes = i;
  }
}
const from$2 = ({ name: t, code: e, encode: r }) => new Hasher(t, e, r);
class Hasher {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(e, r, n) {
    this.name = e, this.code = r, this.encode = n;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? create$2(this.code, r) : r.then((n) => create$2(this.code, n));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const sha256 = from$2({
  name: "sha2-256",
  code: 18,
  encode: (t) => coerce(crypto$3.createHash("sha256").update(t).digest())
});
new TextEncoder();
new TextDecoder();
const format$5 = (t, e) => {
  const { bytes: r, version: n } = t;
  switch (n) {
    case 0:
      return toStringV0(
        r,
        baseCache(t),
        /** @type {API.MultibaseEncoder<"z">} */
        e || base58btc.encoder
      );
    default:
      return toStringV1(
        r,
        baseCache(t),
        /** @type {API.MultibaseEncoder<Prefix>} */
        e || base32.encoder
      );
  }
}, cache = /* @__PURE__ */ new WeakMap(), baseCache = (t) => {
  const e = cache.get(t);
  if (e == null) {
    const r = /* @__PURE__ */ new Map();
    return cache.set(t, r), r;
  }
  return e;
};
class CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(e, r, n, i) {
    this.code = r, this.version = e, this.multihash = n, this.bytes = i, this["/"] = i;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0:
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      case 1: {
        const { code: e, multihash: r } = this;
        if (e !== DAG_PB_CODE)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (r.code !== SHA_256_CODE)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            r
          )
        );
      }
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: r } = this.multihash, n = create$2(e, r);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          CID.createV1(this.code, n)
        );
      }
      case 1:
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(e) {
    return CID.equals(this, e);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(e, r) {
    const n = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      r
    );
    return n && e.code === n.code && e.version === n.version && equals(e.multihash, n.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(e) {
    return format$5(this, e);
  }
  toJSON() {
    return { "/": format$5(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(e) {
    if (e == null)
      return null;
    const r = (
      /** @type {any} */
      e
    );
    if (r instanceof CID)
      return r;
    if (r["/"] != null && r["/"] === r.bytes || r.asCID === r) {
      const { version: n, code: i, multihash: o, bytes: a } = r;
      return new CID(
        n,
        i,
        /** @type {API.MultihashDigest<Alg>} */
        o,
        a || encodeCID(n, i, o.bytes)
      );
    } else if (r[cidSymbol] === !0) {
      const { version: n, multihash: i, code: o } = r, a = (
        /** @type {API.MultihashDigest<Alg>} */
        decode$5(i)
      );
      return CID.create(n, o, a);
    } else
      return null;
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(e, r, n) {
    if (typeof r != "number")
      throw new Error("String codecs are no longer supported");
    if (!(n.bytes instanceof Uint8Array))
      throw new Error("Invalid digest");
    switch (e) {
      case 0: {
        if (r !== DAG_PB_CODE)
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`
          );
        return new CID(e, r, n, n.bytes);
      }
      case 1: {
        const i = encodeCID(e, r, n.bytes);
        return new CID(e, r, n, i);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(e) {
    return CID.create(0, DAG_PB_CODE, e);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(e, r) {
    return CID.create(1, e, r);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(e) {
    const [r, n] = CID.decodeFirst(e);
    if (n.length)
      throw new Error("Incorrect length");
    return r;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(e) {
    const r = CID.inspectBytes(e), n = r.size - r.multihashSize, i = coerce(
      e.subarray(n, n + r.multihashSize)
    );
    if (i.byteLength !== r.multihashSize)
      throw new Error("Incorrect length");
    const o = i.subarray(
      r.multihashSize - r.digestSize
    ), a = new Digest(
      r.multihashCode,
      r.digestSize,
      o,
      i
    );
    return [r.version === 0 ? CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      a
    ) : CID.createV1(r.codec, a), e.subarray(r.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(e) {
    let r = 0;
    const n = () => {
      const [d, p] = decode$6(e.subarray(r));
      return r += p, d;
    };
    let i = (
      /** @type {V} */
      n()
    ), o = (
      /** @type {C} */
      DAG_PB_CODE
    );
    if (/** @type {number} */
    i === 18 ? (i = /** @type {V} */
    0, r = 0) : o = /** @type {C} */
    n(), i !== 0 && i !== 1)
      throw new RangeError(`Invalid CID version ${i}`);
    const a = r, c = (
      /** @type {A} */
      n()
    ), l = n(), u = r + l, f = u - a;
    return { version: i, codec: o, multihashCode: c, digestSize: l, multihashSize: f, size: u };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(e, r) {
    const [n, i] = parseCIDtoBytes(e, r), o = CID.decode(i);
    if (o.version === 0 && e[0] !== "Q")
      throw Error("Version 0 CID string must not include multibase prefix");
    return baseCache(o).set(n, e), o;
  }
}
const parseCIDtoBytes = (t, e) => {
  switch (t[0]) {
    case "Q": {
      const r = e || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        r.decode(`${base58btc.prefix}${t}`)
      ];
    }
    case base58btc.prefix: {
      const r = e || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        r.decode(t)
      ];
    }
    case base32.prefix: {
      const r = e || base32;
      return [
        /** @type {Prefix} */
        base32.prefix,
        r.decode(t)
      ];
    }
    default: {
      if (e == null)
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      return [
        /** @type {Prefix} */
        t[0],
        e.decode(t)
      ];
    }
  }
}, toStringV0 = (t, e, r) => {
  const { prefix: n } = r;
  if (n !== base58btc.prefix)
    throw Error(`Cannot string encode V0 in ${r.name} encoding`);
  const i = e.get(n);
  if (i == null) {
    const o = r.encode(t).slice(1);
    return e.set(n, o), o;
  } else
    return i;
}, toStringV1 = (t, e, r) => {
  const { prefix: n } = r, i = e.get(n);
  if (i == null) {
    const o = r.encode(t);
    return e.set(n, o), o;
  } else
    return i;
}, DAG_PB_CODE = 112, SHA_256_CODE = 18, encodeCID = (t, e, r) => {
  const n = encodingLength$1(t), i = n + encodingLength$1(e), o = new Uint8Array(i + r.byteLength);
  return encodeTo(t, o, 0), encodeTo(e, o, n), o.set(r, i), o;
}, cidSymbol = Symbol.for("@ipld/js-cid/CID"), bases = { ...identityBase, ...base2$1, ...base8$1, ...base10$1, ...base16$1, ...base32$1, ...base36$1, ...base58, ...base64$2, ...base256emoji$1 };
function createCodec$1(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: {
      decode: n
    }
  };
}
const string = createCodec$1("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), ascii = createCodec$1("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = allocUnsafe$3(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString$1(t, e = "utf8") {
  const r = BASES[e];
  if (r == null)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? asUint8Array$1(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
function toString$2(t, e = "utf8") {
  const r = BASES[e];
  if (r == null)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
const pathSepS = "/", pathSepB = new TextEncoder().encode(pathSepS), pathSep = pathSepB[0];
class Key {
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(e, r) {
    $(this, "_buf");
    if (typeof e == "string")
      this._buf = fromString$1(e);
    else if (e instanceof Uint8Array)
      this._buf = e;
    else
      throw new Error("Invalid key, should be String of Uint8Array");
    if (r == null && (r = !0), r && this.clean(), this._buf.byteLength === 0 || this._buf[0] !== pathSep)
      throw new Error("Invalid key");
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(e = "utf8") {
    return toString$2(this._buf, e);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(e) {
    return new Key(e.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')
   * ```
   */
  static random() {
    return new Key(nanoid().replace(/-/g, ""));
  }
  /**
   * @param {*} other
   */
  static asKey(e) {
    return e instanceof Uint8Array || typeof e == "string" ? new Key(e) : typeof e.uint8Array == "function" ? new Key(e.uint8Array()) : null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if ((this._buf == null || this._buf.byteLength === 0) && (this._buf = pathSepB), this._buf[0] !== pathSep) {
      const e = new Uint8Array(this._buf.byteLength + 1);
      e.fill(pathSep, 0, 1), e.set(this._buf, 1), this._buf = e;
    }
    for (; this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep; )
      this._buf = this._buf.subarray(0, -1);
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(e) {
    const r = this.list(), n = e.list();
    for (let i = 0; i < r.length; i++) {
      if (n.length < i + 1)
        return !1;
      const o = r[i], a = n[i];
      if (o < a)
        return !0;
      if (o > a)
        return !1;
    }
    return r.length < n.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const e = this.namespaces();
    return e[e.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(e) {
    return new Key(this.toString() + ":" + e);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let e = this.parent().toString();
    return e.endsWith(pathSepS) || (e += pathSepS), e += this.type(), new Key(e);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const e = this.list();
    return e.length === 1 ? new Key(pathSepS) : new Key(e.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(e) {
    return this.toString() === pathSepS ? e : e.toString() === pathSepS ? this : new Key(this.toString() + e.toString(), !1);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(e) {
    return e.toString() === this.toString() ? !1 : e.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(e) {
    return e.toString() === this.toString() ? !1 : this.toString().startsWith(e.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...e) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(e.map((r) => r.namespaces()))]);
  }
}
function namespaceType(t) {
  const e = t.split(":");
  return e.length < 2 ? "" : e.slice(0, -1).join(":");
}
function namespaceValue(t) {
  const e = t.split(":");
  return e[e.length - 1];
}
function flatten(t) {
  return [].concat(...t);
}
var isPlainObj = (t) => {
  if (Object.prototype.toString.call(t) !== "[object Object]")
    return !1;
  const e = Object.getPrototypeOf(t);
  return e === null || e === Object.prototype;
};
const isOptionObject = isPlainObj, { hasOwnProperty } = Object.prototype, { propertyIsEnumerable } = Object, defineProperty = (t, e, r) => Object.defineProperty(t, e, {
  value: r,
  writable: !0,
  enumerable: !0,
  configurable: !0
}), globalThis$1 = commonjsGlobal, defaultMergeOptions = {
  concatArrays: !1,
  ignoreUndefined: !1
}, getEnumerableOwnPropertyKeys = (t) => {
  const e = [];
  for (const r in t)
    hasOwnProperty.call(t, r) && e.push(r);
  if (Object.getOwnPropertySymbols) {
    const r = Object.getOwnPropertySymbols(t);
    for (const n of r)
      propertyIsEnumerable.call(t, n) && e.push(n);
  }
  return e;
};
function clone(t) {
  return Array.isArray(t) ? cloneArray(t) : isOptionObject(t) ? cloneOptionObject(t) : t;
}
function cloneArray(t) {
  const e = t.slice(0, 0);
  return getEnumerableOwnPropertyKeys(t).forEach((r) => {
    defineProperty(e, r, clone(t[r]));
  }), e;
}
function cloneOptionObject(t) {
  const e = Object.getPrototypeOf(t) === null ? /* @__PURE__ */ Object.create(null) : {};
  return getEnumerableOwnPropertyKeys(t).forEach((r) => {
    defineProperty(e, r, clone(t[r]));
  }), e;
}
const mergeKeys = (t, e, r, n) => (r.forEach((i) => {
  typeof e[i] > "u" && n.ignoreUndefined || (i in t && t[i] !== Object.getPrototypeOf(t) ? defineProperty(t, i, merge$6(t[i], e[i], n)) : defineProperty(t, i, clone(e[i])));
}), t), concatArrays = (t, e, r) => {
  let n = t.slice(0, 0), i = 0;
  return [t, e].forEach((o) => {
    const a = [];
    for (let c = 0; c < o.length; c++)
      hasOwnProperty.call(o, c) && (a.push(String(c)), o === t ? defineProperty(n, i++, o[c]) : defineProperty(n, i++, clone(o[c])));
    n = mergeKeys(n, o, getEnumerableOwnPropertyKeys(o).filter((c) => !a.includes(c)), r);
  }), n;
};
function merge$6(t, e, r) {
  return r.concatArrays && Array.isArray(t) && Array.isArray(e) ? concatArrays(t, e, r) : !isOptionObject(e) || !isOptionObject(t) ? clone(e) : mergeKeys(t, e, getEnumerableOwnPropertyKeys(e), r);
}
var mergeOptions = function(...t) {
  const e = merge$6(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);
  let r = { _: {} };
  for (const n of t)
    if (n !== void 0) {
      if (!isOptionObject(n))
        throw new TypeError("`" + n + "` is not an Option Object");
      r = merge$6(r, { _: n }, e);
    }
  return r._;
};
function isHighSurrogate(t) {
  return t >= 55296 && t <= 56319;
}
function isLowSurrogate(t) {
  return t >= 56320 && t <= 57343;
}
var truncate$2 = function t(e, r, n) {
  if (typeof r != "string")
    throw new Error("Input must be string");
  for (var i = r.length, o = 0, a, c, l = 0; l < i; l += 1) {
    if (a = r.charCodeAt(l), c = r[l], isHighSurrogate(a) && isLowSurrogate(r.charCodeAt(l + 1)) && (l += 1, c += r[l]), o += e(c), o === n)
      return r.slice(0, l + 1);
    if (o > n)
      return r.slice(0, l - c.length + 1);
  }
  return r;
}, truncate$1 = truncate$2, getLength = Buffer.byteLength.bind(Buffer), truncateUtf8Bytes = truncate$1.bind(null, getLength), truncate = truncateUtf8Bytes, illegalRe = /[\/\?<>\\:\*\|"]/g, controlRe = /[\x00-\x1f\x80-\x9f]/g, reservedRe = /^\.+$/, windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i, windowsTrailingRe = /[\. ]+$/;
function sanitize(t, e) {
  if (typeof t != "string")
    throw new Error("Input must be string");
  var r = t.replace(illegalRe, e).replace(controlRe, e).replace(reservedRe, e).replace(windowsReservedRe, e).replace(windowsTrailingRe, e);
  return truncate(r, 255);
}
var sanitizeFilename = function(t, e) {
  var r = e && e.replacement || "", n = sanitize(t, r);
  return r === "" ? n : sanitize(n, "");
}, codes$5;
(function(t) {
  t.ERR_INVALID_PARAMETERS = "ERR_INVALID_PARAMETERS", t.ERR_INVALID_KEY_NAME = "ERR_INVALID_KEY_NAME", t.ERR_INVALID_KEY_TYPE = "ERR_INVALID_KEY_TYPE", t.ERR_KEY_ALREADY_EXISTS = "ERR_KEY_ALREADY_EXISTS", t.ERR_INVALID_KEY_SIZE = "ERR_INVALID_KEY_SIZE", t.ERR_KEY_NOT_FOUND = "ERR_KEY_NOT_FOUND", t.ERR_OLD_KEY_NAME_INVALID = "ERR_OLD_KEY_NAME_INVALID", t.ERR_NEW_KEY_NAME_INVALID = "ERR_NEW_KEY_NAME_INVALID", t.ERR_PASSWORD_REQUIRED = "ERR_PASSWORD_REQUIRED", t.ERR_PEM_REQUIRED = "ERR_PEM_REQUIRED", t.ERR_CANNOT_READ_KEY = "ERR_CANNOT_READ_KEY", t.ERR_MISSING_PRIVATE_KEY = "ERR_MISSING_PRIVATE_KEY", t.ERR_INVALID_OLD_PASS_TYPE = "ERR_INVALID_OLD_PASS_TYPE", t.ERR_INVALID_NEW_PASS_TYPE = "ERR_INVALID_NEW_PASS_TYPE", t.ERR_INVALID_PASS_LENGTH = "ERR_INVALID_PASS_LENGTH";
})(codes$5 || (codes$5 = {}));
const log$s = logger$1("libp2p:keychain"), keyPrefix = "/pkcs8/", infoPrefix = "/info/", privates = /* @__PURE__ */ new WeakMap(), NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
}, defaultOptions$5 = {
  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(t) {
  return t == null || typeof t != "string" ? !1 : t === sanitizeFilename(t.trim()) && t.length > 0;
}
async function randomDelay() {
  const r = Math.random() * 800 + 200;
  await new Promise((n) => setTimeout(n, r));
}
function DsName(t) {
  return new Key(keyPrefix + t);
}
function DsInfoName(t) {
  return new Key(infoPrefix + t);
}
class DefaultKeyChain {
  /**
   * Creates a new instance of a key chain
   */
  constructor(e, r) {
    $(this, "components");
    $(this, "init");
    var i, o, a, c, l, u, f, d, p, g;
    if (this.components = e, this.init = mergeOptions(defaultOptions$5, r), this.init.pass != null && ((i = this.init.pass) == null ? void 0 : i.length) < 20)
      throw new Error("pass must be least 20 characters");
    if (((o = this.init.dek) == null ? void 0 : o.keyLength) != null && this.init.dek.keyLength < NIST.minKeyLength)
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    if (((c = (a = this.init.dek) == null ? void 0 : a.salt) == null ? void 0 : c.length) != null && this.init.dek.salt.length < NIST.minSaltLength)
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    if (((l = this.init.dek) == null ? void 0 : l.iterationCount) != null && this.init.dek.iterationCount < NIST.minIterationCount)
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    const n = this.init.pass != null && ((u = this.init.dek) == null ? void 0 : u.salt) != null ? pbkdf2(this.init.pass, (f = this.init.dek) == null ? void 0 : f.salt, (d = this.init.dek) == null ? void 0 : d.iterationCount, (p = this.init.dek) == null ? void 0 : p.keyLength, (g = this.init.dek) == null ? void 0 : g.hash) : "";
    privates.set(this, { dek: n });
  }
  /**
   * Generates the options for a keychain.  A random salt is produced.
   *
   * @returns {object}
   */
  static generateOptions() {
    const e = Object.assign({}, defaultOptions$5), r = Math.ceil(NIST.minSaltLength / 3) * 3;
    return e.dek.salt = toString$4(randomBytes$1(r), "base64"), e;
  }
  /**
   * Gets an object that can encrypt/decrypt protected data.
   * The default options for a keychain.
   *
   * @returns {object}
   */
  static get options() {
    return defaultOptions$5;
  }
  /**
   * Create a new key.
   *
   * @param {string} name - The local key name; cannot already exist.
   * @param {string} type - One of the key types; 'rsa'.
   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only
   */
  async createKey(e, r, n = 2048) {
    if (!validateKeyName(e) || e === "self")
      throw await randomDelay(), new CodeError$2("Invalid key name", codes$5.ERR_INVALID_KEY_NAME);
    if (typeof r != "string")
      throw await randomDelay(), new CodeError$2("Invalid key type", codes$5.ERR_INVALID_KEY_TYPE);
    const i = DsName(e);
    if (await this.components.datastore.has(i))
      throw await randomDelay(), new CodeError$2("Key name already exists", codes$5.ERR_KEY_ALREADY_EXISTS);
    switch (r.toLowerCase()) {
      case "rsa":
        if (!Number.isSafeInteger(n) || n < 2048)
          throw await randomDelay(), new CodeError$2("Invalid RSA key size", codes$5.ERR_INVALID_KEY_SIZE);
        break;
    }
    let a;
    try {
      const c = await generateKeyPair(r, n), l = await c.id(), u = privates.get(this);
      if (u == null)
        throw new CodeError$2("dek missing", codes$5.ERR_INVALID_PARAMETERS);
      const f = u.dek, d = await c.export(f);
      a = {
        name: e,
        id: l
      };
      const p = this.components.datastore.batch();
      p.put(i, fromString$3(d)), p.put(DsInfoName(e), fromString$3(JSON.stringify(a))), await p.commit();
    } catch (c) {
      throw await randomDelay(), c;
    }
    return a;
  }
  /**
   * List all the keys.
   *
   * @returns {Promise<KeyInfo[]>}
   */
  async listKeys() {
    const e = {
      prefix: infoPrefix
    }, r = [];
    for await (const n of this.components.datastore.query(e))
      r.push(JSON.parse(toString$4(n.value)));
    return r;
  }
  /**
   * Find a key by it's id
   */
  async findKeyById(e) {
    try {
      const n = (await this.listKeys()).find((i) => i.id === e);
      if (n == null)
        throw new CodeError$2(`Key with id '${e}' does not exist.`, codes$5.ERR_KEY_NOT_FOUND);
      return n;
    } catch (r) {
      throw await randomDelay(), r;
    }
  }
  /**
   * Find a key by it's name.
   *
   * @param {string} name - The local key name.
   * @returns {Promise<KeyInfo>}
   */
  async findKeyByName(e) {
    if (!validateKeyName(e))
      throw await randomDelay(), new CodeError$2(`Invalid key name '${e}'`, codes$5.ERR_INVALID_KEY_NAME);
    const r = DsInfoName(e);
    try {
      const n = await this.components.datastore.get(r);
      return JSON.parse(toString$4(n));
    } catch (n) {
      throw await randomDelay(), log$s.error(n), new CodeError$2(`Key '${e}' does not exist.`, codes$5.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Remove an existing key.
   *
   * @param {string} name - The local key name; must already exist.
   * @returns {Promise<KeyInfo>}
   */
  async removeKey(e) {
    if (!validateKeyName(e) || e === "self")
      throw await randomDelay(), new CodeError$2(`Invalid key name '${e}'`, codes$5.ERR_INVALID_KEY_NAME);
    const r = DsName(e), n = await this.findKeyByName(e), i = this.components.datastore.batch();
    return i.delete(r), i.delete(DsInfoName(e)), await i.commit(), n;
  }
  /**
   * Rename a key
   *
   * @param {string} oldName - The old local key name; must already exist.
   * @param {string} newName - The new local key name; must not already exist.
   * @returns {Promise<KeyInfo>}
   */
  async renameKey(e, r) {
    if (!validateKeyName(e) || e === "self")
      throw await randomDelay(), new CodeError$2(`Invalid old key name '${e}'`, codes$5.ERR_OLD_KEY_NAME_INVALID);
    if (!validateKeyName(r) || r === "self")
      throw await randomDelay(), new CodeError$2(`Invalid new key name '${r}'`, codes$5.ERR_NEW_KEY_NAME_INVALID);
    const n = DsName(e), i = DsName(r), o = DsInfoName(e), a = DsInfoName(r);
    if (await this.components.datastore.has(i))
      throw await randomDelay(), new CodeError$2(`Key '${r}' already exists`, codes$5.ERR_KEY_ALREADY_EXISTS);
    try {
      const l = await this.components.datastore.get(n), u = await this.components.datastore.get(o), f = JSON.parse(toString$4(u));
      f.name = r;
      const d = this.components.datastore.batch();
      return d.put(i, l), d.put(a, fromString$3(JSON.stringify(f))), d.delete(n), d.delete(o), await d.commit(), f;
    } catch (l) {
      throw await randomDelay(), l;
    }
  }
  /**
   * Export an existing key as a PEM encrypted PKCS #8 string
   */
  async exportKey(e, r) {
    if (!validateKeyName(e))
      throw await randomDelay(), new CodeError$2(`Invalid key name '${e}'`, codes$5.ERR_INVALID_KEY_NAME);
    if (r == null)
      throw await randomDelay(), new CodeError$2("Password is required", codes$5.ERR_PASSWORD_REQUIRED);
    const n = DsName(e);
    try {
      const i = await this.components.datastore.get(n), o = toString$4(i), a = privates.get(this);
      if (a == null)
        throw new CodeError$2("dek missing", codes$5.ERR_INVALID_PARAMETERS);
      const c = a.dek;
      return await (await importKey(o, c)).export(r);
    } catch (i) {
      throw await randomDelay(), i;
    }
  }
  /**
   * Export an existing key as a PeerId
   */
  async exportPeerId(e) {
    const r = "temporary-password", n = await this.exportKey(e, r), i = await importKey(n, r);
    return peerIdFromKeys(i.public.bytes, i.bytes);
  }
  /**
   * Import a new key from a PEM encoded PKCS #8 string
   *
   * @param {string} name - The local key name; must not already exist.
   * @param {string} pem - The PEM encoded PKCS #8 string
   * @param {string} password - The password.
   * @returns {Promise<KeyInfo>}
   */
  async importKey(e, r, n) {
    if (!validateKeyName(e) || e === "self")
      throw await randomDelay(), new CodeError$2(`Invalid key name '${e}'`, codes$5.ERR_INVALID_KEY_NAME);
    if (r == null)
      throw await randomDelay(), new CodeError$2("PEM encoded key is required", codes$5.ERR_PEM_REQUIRED);
    const i = DsName(e);
    if (await this.components.datastore.has(i))
      throw await randomDelay(), new CodeError$2(`Key '${e}' already exists`, codes$5.ERR_KEY_ALREADY_EXISTS);
    let a;
    try {
      a = await importKey(r, n);
    } catch {
      throw await randomDelay(), new CodeError$2("Cannot read the key, most likely the password is wrong", codes$5.ERR_CANNOT_READ_KEY);
    }
    let c;
    try {
      c = await a.id();
      const f = privates.get(this);
      if (f == null)
        throw new CodeError$2("dek missing", codes$5.ERR_INVALID_PARAMETERS);
      const d = f.dek;
      r = await a.export(d);
    } catch (f) {
      throw await randomDelay(), f;
    }
    const l = {
      name: e,
      id: c
    }, u = this.components.datastore.batch();
    return u.put(i, fromString$3(r)), u.put(DsInfoName(e), fromString$3(JSON.stringify(l))), await u.commit(), l;
  }
  /**
   * Import a peer key
   */
  async importPeer(e, r) {
    try {
      if (!validateKeyName(e))
        throw new CodeError$2(`Invalid key name '${e}'`, codes$5.ERR_INVALID_KEY_NAME);
      if (r == null)
        throw new CodeError$2("PeerId is required", codes$5.ERR_MISSING_PRIVATE_KEY);
      if (r.privateKey == null)
        throw new CodeError$2("PeerId.privKey is required", codes$5.ERR_MISSING_PRIVATE_KEY);
      const n = await unmarshalPrivateKey(r.privateKey), i = DsName(e);
      if (await this.components.datastore.has(i))
        throw await randomDelay(), new CodeError$2(`Key '${e}' already exists`, codes$5.ERR_KEY_ALREADY_EXISTS);
      const a = privates.get(this);
      if (a == null)
        throw new CodeError$2("dek missing", codes$5.ERR_INVALID_PARAMETERS);
      const c = a.dek, l = await n.export(c), u = {
        name: e,
        id: r.toString()
      }, f = this.components.datastore.batch();
      return f.put(i, fromString$3(l)), f.put(DsInfoName(e), fromString$3(JSON.stringify(u))), await f.commit(), u;
    } catch (n) {
      throw await randomDelay(), n;
    }
  }
  /**
   * Gets the private key as PEM encoded PKCS #8 string
   */
  async getPrivateKey(e) {
    if (!validateKeyName(e))
      throw await randomDelay(), new CodeError$2(`Invalid key name '${e}'`, codes$5.ERR_INVALID_KEY_NAME);
    try {
      const r = DsName(e), n = await this.components.datastore.get(r);
      return toString$4(n);
    } catch (r) {
      throw await randomDelay(), log$s.error(r), new CodeError$2(`Key '${e}' does not exist.`, codes$5.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Rotate keychain password and re-encrypt all associated keys
   */
  async rotateKeychainPass(e, r) {
    var c, l, u, f;
    if (typeof e != "string")
      throw await randomDelay(), new CodeError$2(`Invalid old pass type '${typeof e}'`, codes$5.ERR_INVALID_OLD_PASS_TYPE);
    if (typeof r != "string")
      throw await randomDelay(), new CodeError$2(`Invalid new pass type '${typeof r}'`, codes$5.ERR_INVALID_NEW_PASS_TYPE);
    if (r.length < 20)
      throw await randomDelay(), new CodeError$2(`Invalid pass length ${r.length}`, codes$5.ERR_INVALID_PASS_LENGTH);
    log$s("recreating keychain");
    const n = privates.get(this);
    if (n == null)
      throw new CodeError$2("dek missing", codes$5.ERR_INVALID_PARAMETERS);
    const i = n.dek;
    this.init.pass = r;
    const o = r != null && ((c = this.init.dek) == null ? void 0 : c.salt) != null ? pbkdf2(r, this.init.dek.salt, (l = this.init.dek) == null ? void 0 : l.iterationCount, (u = this.init.dek) == null ? void 0 : u.keyLength, (f = this.init.dek) == null ? void 0 : f.hash) : "";
    privates.set(this, { dek: o });
    const a = await this.listKeys();
    for (const d of a) {
      const p = await this.components.datastore.get(DsName(d.name)), g = toString$4(p), h = await importKey(g, i), m = o.toString(), y = await h.export(m), b = this.components.datastore.batch(), v = {
        name: d.name,
        id: d.id
      };
      b.put(DsName(d.name), fromString$3(y)), b.put(DsInfoName(d.name), fromString$3(JSON.stringify(v))), await b.commit();
    }
    log$s("keychain reconstructed");
  }
}
function mapIterable(t, e) {
  const r = {
    [Symbol.iterator]: () => r,
    next: () => {
      const n = t.next(), i = n.value;
      return n.done === !0 || i == null ? {
        done: !0,
        value: void 0
      } : {
        done: !1,
        value: e(i)
      };
    }
  };
  return r;
}
class PeerMap {
  constructor(e) {
    $(this, "map");
    if (this.map = /* @__PURE__ */ new Map(), e != null)
      for (const [r, n] of e.entries())
        this.map.set(r.toString(), n);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(e) {
    this.map.delete(e.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (e) => [peerIdFromString(e[0]), e[1]]);
  }
  forEach(e) {
    this.map.forEach((r, n) => {
      e(r, peerIdFromString(n), this);
    });
  }
  get(e) {
    return this.map.get(e.toString());
  }
  has(e) {
    return this.map.has(e.toString());
  }
  set(e, r) {
    this.map.set(e.toString(), r);
  }
  keys() {
    return mapIterable(this.map.keys(), (e) => peerIdFromString(e));
  }
  values() {
    return this.map.values();
  }
  get size() {
    return this.map.size;
  }
}
class PeerSet {
  constructor(e) {
    $(this, "set");
    if (this.set = /* @__PURE__ */ new Set(), e != null)
      for (const r of e)
        this.set.add(r.toString());
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(e) {
    this.set.add(e.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(e) {
    this.set.delete(e.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (e) => {
      const r = peerIdFromString(e[0]);
      return [r, r];
    });
  }
  forEach(e) {
    this.set.forEach((r) => {
      const n = peerIdFromString(r);
      e(n, n, this);
    });
  }
  has(e) {
    return this.set.has(e.toString());
  }
  values() {
    return mapIterable(this.set.values(), (e) => peerIdFromString(e));
  }
  intersection(e) {
    const r = new PeerSet();
    for (const n of e)
      this.has(n) && r.add(n);
    return r;
  }
  difference(e) {
    const r = new PeerSet();
    for (const n of this)
      e.has(n) || r.add(n);
    return r;
  }
  union(e) {
    const r = new PeerSet();
    for (const n of e)
      r.add(n);
    for (const n of this)
      r.add(n);
    return r;
  }
}
var PeerIdProto;
(function(t) {
  let e;
  t.codec = () => (e == null && (e = message$1((r, n, i = {}) => {
    i.lengthDelimited !== !1 && n.fork(), r.id != null && (n.uint32(10), n.bytes(r.id)), r.pubKey != null && (n.uint32(18), n.bytes(r.pubKey)), r.privKey != null && (n.uint32(26), n.bytes(r.privKey)), i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {}, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.id = r.bytes();
          break;
        case 2:
          i.pubKey = r.bytes();
          break;
        case 3:
          i.privKey = r.bytes();
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage$1(r, t.codec()), t.decode = (r) => decodeMessage$1(r, t.codec());
})(PeerIdProto || (PeerIdProto = {}));
const createEd25519PeerId = async () => {
  const t = await generateKeyPair("Ed25519"), e = await createFromPrivKey(t);
  if (e.type === "Ed25519")
    return e;
  throw new Error(`Generated unexpected PeerId type "${e.type}"`);
};
async function createFromPrivKey(t) {
  return peerIdFromKeys(marshalPublicKey(t.public), marshalPrivateKey(t));
}
const codes$4 = {
  ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
};
var minimal = {}, longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = e;
  var t = requireMinimal();
  function e(o, a) {
    this.lo = o >>> 0, this.hi = a >>> 0;
  }
  var r = e.zero = new e(0, 0);
  r.toNumber = function() {
    return 0;
  }, r.zzEncode = r.zzDecode = function() {
    return this;
  }, r.length = function() {
    return 1;
  };
  var n = e.zeroHash = "\0\0\0\0\0\0\0\0";
  e.fromNumber = function(a) {
    if (a === 0)
      return r;
    var c = a < 0;
    c && (a = -a);
    var l = a >>> 0, u = (a - l) / 4294967296 >>> 0;
    return c && (u = ~u >>> 0, l = ~l >>> 0, ++l > 4294967295 && (l = 0, ++u > 4294967295 && (u = 0))), new e(l, u);
  }, e.from = function(a) {
    if (typeof a == "number")
      return e.fromNumber(a);
    if (t.isString(a))
      if (t.Long)
        a = t.Long.fromString(a);
      else
        return e.fromNumber(parseInt(a, 10));
    return a.low || a.high ? new e(a.low >>> 0, a.high >>> 0) : r;
  }, e.prototype.toNumber = function(a) {
    if (!a && this.hi >>> 31) {
      var c = ~this.lo + 1 >>> 0, l = ~this.hi >>> 0;
      return c || (l = l + 1 >>> 0), -(c + l * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, e.prototype.toLong = function(a) {
    return t.Long ? new t.Long(this.lo | 0, this.hi | 0, Boolean(a)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(a) };
  };
  var i = String.prototype.charCodeAt;
  return e.fromHash = function(a) {
    return a === n ? r : new e(
      (i.call(a, 0) | i.call(a, 1) << 8 | i.call(a, 2) << 16 | i.call(a, 3) << 24) >>> 0,
      (i.call(a, 4) | i.call(a, 5) << 8 | i.call(a, 6) << 16 | i.call(a, 7) << 24) >>> 0
    );
  }, e.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, e.prototype.zzEncode = function() {
    var a = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ a) >>> 0, this.lo = (this.lo << 1 ^ a) >>> 0, this;
  }, e.prototype.zzDecode = function() {
    var a = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ a) >>> 0, this.hi = (this.hi >>> 1 ^ a) >>> 0, this;
  }, e.prototype.length = function() {
    var a = this.lo, c = (this.lo >>> 28 | this.hi << 4) >>> 0, l = this.hi >>> 24;
    return l === 0 ? c === 0 ? a < 16384 ? a < 128 ? 1 : 2 : a < 2097152 ? 3 : 4 : c < 16384 ? c < 128 ? 5 : 6 : c < 2097152 ? 7 : 8 : l < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(t) {
    var e = t;
    e.asPromise = aspromise, e.base64 = base64$4, e.EventEmitter = eventemitter, e.float = float, e.inquire = inquire_1, e.utf8 = utf8$4, e.pool = pool_1, e.LongBits = requireLongbits(), e.isNode = Boolean(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), e.global = e.isNode && commonjsGlobal || typeof window < "u" && window || typeof self$1 < "u" && self$1 || commonjsGlobal, e.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), e.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), e.isInteger = Number.isInteger || /* istanbul ignore next */
    function(o) {
      return typeof o == "number" && isFinite(o) && Math.floor(o) === o;
    }, e.isString = function(o) {
      return typeof o == "string" || o instanceof String;
    }, e.isObject = function(o) {
      return o && typeof o == "object";
    }, e.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    e.isSet = function(o, a) {
      var c = o[a];
      return c != null && o.hasOwnProperty(a) ? typeof c != "object" || (Array.isArray(c) ? c.length : Object.keys(c).length) > 0 : !1;
    }, e.Buffer = function() {
      try {
        var i = e.inquire("buffer").Buffer;
        return i.prototype.utf8Write ? i : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), e._Buffer_from = null, e._Buffer_allocUnsafe = null, e.newBuffer = function(o) {
      return typeof o == "number" ? e.Buffer ? e._Buffer_allocUnsafe(o) : new e.Array(o) : e.Buffer ? e._Buffer_from(o) : typeof Uint8Array > "u" ? o : new Uint8Array(o);
    }, e.Array = typeof Uint8Array < "u" ? Uint8Array : Array, e.Long = /* istanbul ignore next */
    e.global.dcodeIO && /* istanbul ignore next */
    e.global.dcodeIO.Long || /* istanbul ignore next */
    e.global.Long || e.inquire("long"), e.key2Re = /^true|false|0|1$/, e.key32Re = /^-?(?:0|[1-9][0-9]*)$/, e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, e.longToHash = function(o) {
      return o ? e.LongBits.from(o).toHash() : e.LongBits.zeroHash;
    }, e.longFromHash = function(o, a) {
      var c = e.LongBits.fromHash(o);
      return e.Long ? e.Long.fromBits(c.lo, c.hi, a) : c.toNumber(Boolean(a));
    };
    function r(i, o, a) {
      for (var c = Object.keys(o), l = 0; l < c.length; ++l)
        (i[c[l]] === void 0 || !a) && (i[c[l]] = o[c[l]]);
      return i;
    }
    e.merge = r, e.lcFirst = function(o) {
      return o.charAt(0).toLowerCase() + o.substring(1);
    };
    function n(i) {
      function o(a, c) {
        if (!(this instanceof o))
          return new o(a, c);
        Object.defineProperty(this, "message", { get: function() {
          return a;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, o) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), c && r(this, c);
      }
      return o.prototype = Object.create(Error.prototype, {
        constructor: {
          value: o,
          writable: !0,
          enumerable: !1,
          configurable: !0
        },
        name: {
          get: function() {
            return i;
          },
          set: void 0,
          enumerable: !1,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: !0
        },
        toString: {
          value: function() {
            return this.name + ": " + this.message;
          },
          writable: !0,
          enumerable: !1,
          configurable: !0
        }
      }), o;
    }
    e.newError = n, e.ProtocolError = n("ProtocolError"), e.oneOfGetter = function(o) {
      for (var a = {}, c = 0; c < o.length; ++c)
        a[o[c]] = 1;
      return function() {
        for (var l = Object.keys(this), u = l.length - 1; u > -1; --u)
          if (a[l[u]] === 1 && this[l[u]] !== void 0 && this[l[u]] !== null)
            return l[u];
      };
    }, e.oneOfSetter = function(o) {
      return function(a) {
        for (var c = 0; c < o.length; ++c)
          o[c] !== a && delete this[o[c]];
      };
    }, e.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, e._configure = function() {
      var i = e.Buffer;
      if (!i) {
        e._Buffer_from = e._Buffer_allocUnsafe = null;
        return;
      }
      e._Buffer_from = i.from !== Uint8Array.from && i.from || /* istanbul ignore next */
      function(a, c) {
        return new i(a, c);
      }, e._Buffer_allocUnsafe = i.allocUnsafe || /* istanbul ignore next */
      function(a) {
        return new i(a);
      };
    };
  }(minimal)), minimal;
}
var reader$2 = Reader$1, util$4 = requireMinimal(), BufferReader$1, LongBits$1 = util$4.LongBits, utf8$1 = util$4.utf8;
function indexOutOfRange(t, e) {
  return RangeError("index out of range: " + t.pos + " + " + (e || 1) + " > " + t.len);
}
function Reader$1(t) {
  this.buf = t, this.pos = 0, this.len = t.length;
}
var create_array = typeof Uint8Array < "u" ? function t(e) {
  if (e instanceof Uint8Array || Array.isArray(e))
    return new Reader$1(e);
  throw Error("illegal buffer");
} : function t(e) {
  if (Array.isArray(e))
    return new Reader$1(e);
  throw Error("illegal buffer");
}, create$1 = function t() {
  return util$4.Buffer ? function(r) {
    return (Reader$1.create = function(i) {
      return util$4.Buffer.isBuffer(i) ? new BufferReader$1(i) : create_array(i);
    })(r);
  } : create_array;
};
Reader$1.create = create$1();
Reader$1.prototype._slice = util$4.Array.prototype.subarray || /* istanbul ignore next */
util$4.Array.prototype.slice;
Reader$1.prototype.uint32 = function t() {
  var e = 4294967295;
  return function() {
    if (e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (e = (e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return e;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return e;
  };
}();
Reader$1.prototype.int32 = function t() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function t() {
  var e = this.uint32();
  return e >>> 1 ^ -(e & 1) | 0;
};
function readLongVarint() {
  var t = new LongBits$1(0, 0), e = 0;
  if (this.len - this.pos > 4) {
    for (; e < 4; ++e)
      if (t.lo = (t.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128)
        return t;
    if (t.lo = (t.lo | (this.buf[this.pos] & 127) << 28) >>> 0, t.hi = (t.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return t;
    e = 0;
  } else {
    for (; e < 3; ++e) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (t.lo = (t.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128)
        return t;
    }
    return t.lo = (t.lo | (this.buf[this.pos++] & 127) << e * 7) >>> 0, t;
  }
  if (this.len - this.pos > 4) {
    for (; e < 5; ++e)
      if (t.hi = (t.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return t;
  } else
    for (; e < 5; ++e) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (t.hi = (t.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return t;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function t() {
  return this.uint32() !== 0;
};
function readFixed32_end(t, e) {
  return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function t() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function t() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits$1(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function t() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var e = util$4.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, e;
};
Reader$1.prototype.double = function t() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var e = util$4.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, e;
};
Reader$1.prototype.bytes = function t() {
  var e = this.uint32(), r = this.pos, n = this.pos + e;
  if (n > this.len)
    throw indexOutOfRange(this, e);
  return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(r, n) : r === n ? new this.buf.constructor(0) : this._slice.call(this.buf, r, n);
};
Reader$1.prototype.string = function t() {
  var e = this.bytes();
  return utf8$1.read(e, 0, e.length);
};
Reader$1.prototype.skip = function t(e) {
  if (typeof e == "number") {
    if (this.pos + e > this.len)
      throw indexOutOfRange(this, e);
    this.pos += e;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(t) {
  switch (t) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (t = this.uint32() & 7) !== 4; )
        this.skipType(t);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + t + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(t) {
  BufferReader$1 = t, Reader$1.create = create$1(), BufferReader$1._configure();
  var e = util$4.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$4.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[e](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[e](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[e](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[e](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[e](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader$2;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$3 = requireMinimal();
function BufferReader(t) {
  Reader.call(this, t);
}
BufferReader._configure = function() {
  util$3.Buffer && (BufferReader.prototype._slice = util$3.Buffer.prototype.slice);
};
BufferReader.prototype.string = function t() {
  var e = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e, this.len));
};
BufferReader._configure();
var minimalExports = requireMinimal();
const util$2 = /* @__PURE__ */ getDefaultExportFromCjs(minimalExports);
var writer$1 = Writer$1, util$1 = requireMinimal(), BufferWriter$1, LongBits = util$1.LongBits, base64 = util$1.base64, utf8 = util$1.utf8;
function Op(t, e, r) {
  this.fn = t, this.len = e, this.next = void 0, this.val = r;
}
function noop$2() {
}
function State(t) {
  this.head = t.head, this.tail = t.tail, this.len = t.len, this.next = t.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$2, 0, 0), this.tail = this.head, this.states = null;
}
var create = function t() {
  return util$1.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create();
Writer$1.alloc = function t(e) {
  return new util$1.Array(e);
};
util$1.Array !== Array && (Writer$1.alloc = util$1.pool(Writer$1.alloc, util$1.Array.prototype.subarray));
Writer$1.prototype._push = function t(e, r, n) {
  return this.tail = this.tail.next = new Op(e, r, n), this.len += r, this;
};
function writeByte(t, e, r) {
  e[r] = t & 255;
}
function writeVarint32(t, e, r) {
  for (; t > 127; )
    e[r++] = t & 127 | 128, t >>>= 7;
  e[r] = t;
}
function VarintOp(t, e) {
  this.len = t, this.next = void 0, this.val = e;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function t(e) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5,
    e
  )).len, this;
};
Writer$1.prototype.int32 = function t(e) {
  return e < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(e)) : this.uint32(e);
};
Writer$1.prototype.sint32 = function t(e) {
  return this.uint32((e << 1 ^ e >> 31) >>> 0);
};
function writeVarint64(t, e, r) {
  for (; t.hi; )
    e[r++] = t.lo & 127 | 128, t.lo = (t.lo >>> 7 | t.hi << 25) >>> 0, t.hi >>>= 7;
  for (; t.lo > 127; )
    e[r++] = t.lo & 127 | 128, t.lo = t.lo >>> 7;
  e[r++] = t.lo;
}
Writer$1.prototype.uint64 = function t(e) {
  var r = LongBits.from(e);
  return this._push(writeVarint64, r.length(), r);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function t(e) {
  var r = LongBits.from(e).zzEncode();
  return this._push(writeVarint64, r.length(), r);
};
Writer$1.prototype.bool = function t(e) {
  return this._push(writeByte, 1, e ? 1 : 0);
};
function writeFixed32(t, e, r) {
  e[r] = t & 255, e[r + 1] = t >>> 8 & 255, e[r + 2] = t >>> 16 & 255, e[r + 3] = t >>> 24;
}
Writer$1.prototype.fixed32 = function t(e) {
  return this._push(writeFixed32, 4, e >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function t(e) {
  var r = LongBits.from(e);
  return this._push(writeFixed32, 4, r.lo)._push(writeFixed32, 4, r.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function t(e) {
  return this._push(util$1.float.writeFloatLE, 4, e);
};
Writer$1.prototype.double = function t(e) {
  return this._push(util$1.float.writeDoubleLE, 8, e);
};
var writeBytes = util$1.Array.prototype.set ? function t(e, r, n) {
  r.set(e, n);
} : function t(e, r, n) {
  for (var i = 0; i < e.length; ++i)
    r[n + i] = e[i];
};
Writer$1.prototype.bytes = function t(e) {
  var r = e.length >>> 0;
  if (!r)
    return this._push(writeByte, 1, 0);
  if (util$1.isString(e)) {
    var n = Writer$1.alloc(r = base64.length(e));
    base64.decode(e, n, 0), e = n;
  }
  return this.uint32(r)._push(writeBytes, r, e);
};
Writer$1.prototype.string = function t(e) {
  var r = utf8.length(e);
  return r ? this.uint32(r)._push(utf8.write, r, e) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function t() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$2, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function t() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$2, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function t() {
  var e = this.head, r = this.tail, n = this.len;
  return this.reset().uint32(n), n && (this.tail.next = e.next, this.tail = r, this.len += n), this;
};
Writer$1.prototype.finish = function t() {
  for (var e = this.head.next, r = this.constructor.alloc(this.len), n = 0; e; )
    e.fn(e.val, r, n), n += e.len, e = e.next;
  return r;
};
Writer$1._configure = function(t) {
  BufferWriter$1 = t, Writer$1.create = create(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer$1;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function(e, r, n) {
    r.set(e, n);
  } : function(e, r, n) {
    if (e.copy)
      e.copy(r, n, 0, e.length);
    else
      for (var i = 0; i < e.length; )
        r[n++] = e[i++];
  };
};
BufferWriter.prototype.bytes = function t(e) {
  util.isString(e) && (e = util._Buffer_from(e, "base64"));
  var r = e.length >>> 0;
  return this.uint32(r), r && this._push(BufferWriter.writeBytesBuffer, r, e), this;
};
function writeStringBuffer(t, e, r) {
  t.length < 40 ? util.utf8.write(t, e, r) : e.utf8Write ? e.utf8Write(t, r) : e.write(t, r);
}
BufferWriter.prototype.string = function t(e) {
  var r = util.Buffer.byteLength(e);
  return this.uint32(r), r && this._push(writeStringBuffer, r, e), this;
};
BufferWriter._configure();
function configure() {
  util$2._configure(), reader$2._configure(reader_buffer), writer$1._configure(writer_buffer);
}
configure();
const methods = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader(t) {
  for (const e of methods) {
    if (t[e] == null)
      continue;
    const r = t[e];
    t[e] = function() {
      return BigInt(r.call(this).toString());
    };
  }
  return t;
}
function reader$1(t) {
  return patchReader(new reader$2(t));
}
function patchWriter(t) {
  for (const e of methods) {
    if (t[e] == null)
      continue;
    const r = t[e];
    t[e] = function(n) {
      return r.call(this, n.toString());
    };
  }
  return t;
}
function writer() {
  return patchWriter(writer$1.create());
}
function decodeMessage(t, e) {
  const r = reader$1(t instanceof Uint8Array ? t : t.subarray());
  return e.decode(r);
}
function encodeMessage(t, e) {
  const r = writer();
  return e.encode(t, r, {
    lengthDelimited: !1
  }), r.finish();
}
var CODEC_TYPES;
(function(t) {
  t[t.VARINT = 0] = "VARINT", t[t.BIT64 = 1] = "BIT64", t[t.LENGTH_DELIMITED = 2] = "LENGTH_DELIMITED", t[t.START_GROUP = 3] = "START_GROUP", t[t.END_GROUP = 4] = "END_GROUP", t[t.BIT32 = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec(t, e, r, n) {
  return {
    name: t,
    type: e,
    encode: r,
    decode: n
  };
}
function message(t, e) {
  return createCodec("message", CODEC_TYPES.LENGTH_DELIMITED, t, e);
}
var Envelope;
(function(t) {
  let e;
  t.codec = () => (e == null && (e = message((r, n, i = {}) => {
    i.lengthDelimited !== !1 && n.fork(), r.publicKey != null && r.publicKey.byteLength > 0 && (n.uint32(10), n.bytes(r.publicKey)), r.payloadType != null && r.payloadType.byteLength > 0 && (n.uint32(18), n.bytes(r.payloadType)), r.payload != null && r.payload.byteLength > 0 && (n.uint32(26), n.bytes(r.payload)), r.signature != null && r.signature.byteLength > 0 && (n.uint32(42), n.bytes(r.signature)), i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {
      publicKey: new Uint8Array(0),
      payloadType: new Uint8Array(0),
      payload: new Uint8Array(0),
      signature: new Uint8Array(0)
    }, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.publicKey = r.bytes();
          break;
        case 2:
          i.payloadType = r.bytes();
          break;
        case 3:
          i.payload = r.bytes();
          break;
        case 5:
          i.signature = r.bytes();
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage(r, t.codec()), t.decode = (r) => decodeMessage(r, t.codec());
})(Envelope || (Envelope = {}));
const Ae = class {
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(e) {
    $(this, "peerId");
    $(this, "payloadType");
    $(this, "payload");
    $(this, "signature");
    $(this, "marshaled");
    const { peerId: r, payloadType: n, payload: i, signature: o } = e;
    this.peerId = r, this.payloadType = n, this.payload = i, this.signature = o;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.peerId.publicKey == null)
      throw new Error("Missing public key");
    return this.marshaled == null && (this.marshaled = Envelope.encode({
      publicKey: this.peerId.publicKey,
      payloadType: this.payloadType,
      payload: this.payload.subarray(),
      signature: this.signature
    })), this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(e) {
    return equals$2(this.marshal(), e.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(e) {
    const r = formatSignaturePayload(e, this.payloadType, this.payload);
    if (this.peerId.publicKey == null)
      throw new Error("Missing public key");
    return unmarshalPublicKey(this.peerId.publicKey).verify(r.subarray(), this.signature);
  }
};
let RecordEnvelope = Ae;
/**
 * Unmarshal a serialized Envelope protobuf message
 */
$(RecordEnvelope, "createFromProtobuf", async (e) => {
  const r = Envelope.decode(e), n = await peerIdFromKeys(r.publicKey);
  return new Ae({
    peerId: n,
    payloadType: r.payloadType,
    payload: r.payload,
    signature: r.signature
  });
}), /**
 * Seal marshals the given Record, places the marshaled bytes inside an Envelope
 * and signs it with the given peerId's private key
 */
$(RecordEnvelope, "seal", async (e, r) => {
  if (r.privateKey == null)
    throw new Error("Missing private key");
  const n = e.domain, i = e.codec, o = e.marshal(), a = formatSignaturePayload(n, i, o), l = await (await unmarshalPrivateKey(r.privateKey)).sign(a.subarray());
  return new Ae({
    peerId: r,
    payloadType: i,
    payload: o,
    signature: l
  });
}), /**
 * Open and certify a given marshalled envelope.
 * Data is unmarshalled and the signature validated for the given domain.
 */
$(RecordEnvelope, "openAndCertify", async (e, r) => {
  const n = await Ae.createFromProtobuf(e);
  if (!await n.validate(r))
    throw new CodeError$2("envelope signature is not valid for the given domain", codes$4.ERR_SIGNATURE_NOT_VALID);
  return n;
});
const formatSignaturePayload = (t, e, r) => {
  const n = fromString$3(t), i = unsigned.encode(n.byteLength), o = unsigned.encode(e.length), a = unsigned.encode(r.length);
  return new Uint8ArrayList(i, n, o, e, a, r);
};
function arrayEquals(t, e) {
  const r = (n, i) => n.toString().localeCompare(i.toString());
  return t.length !== e.length ? !1 : (e.sort(r), t.sort(r).every((n, i) => e[i].equals(n)));
}
const N1$1 = Math.pow(2, 7), N2$1 = Math.pow(2, 14), N3$1 = Math.pow(2, 21), N4$1 = Math.pow(2, 28), N5$1 = Math.pow(2, 35), N6$1 = Math.pow(2, 42), N7$1 = Math.pow(2, 49), MSB$2 = 128, REST$2 = 127;
function encodingLength(t) {
  if (t < N1$1)
    return 1;
  if (t < N2$1)
    return 2;
  if (t < N3$1)
    return 3;
  if (t < N4$1)
    return 4;
  if (t < N5$1)
    return 5;
  if (t < N6$1)
    return 6;
  if (t < N7$1)
    return 7;
  if (Number.MAX_SAFE_INTEGER != null && t > Number.MAX_SAFE_INTEGER)
    throw new RangeError("Could not encode varint");
  return 8;
}
function encodeUint8Array(t, e, r = 0) {
  switch (encodingLength(t)) {
    case 8:
      e[r++] = t & 255 | MSB$2, t /= 128;
    case 7:
      e[r++] = t & 255 | MSB$2, t /= 128;
    case 6:
      e[r++] = t & 255 | MSB$2, t /= 128;
    case 5:
      e[r++] = t & 255 | MSB$2, t /= 128;
    case 4:
      e[r++] = t & 255 | MSB$2, t >>>= 7;
    case 3:
      e[r++] = t & 255 | MSB$2, t >>>= 7;
    case 2:
      e[r++] = t & 255 | MSB$2, t >>>= 7;
    case 1: {
      e[r++] = t & 255, t >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return e;
}
function encodeUint8ArrayList(t, e, r = 0) {
  switch (encodingLength(t)) {
    case 8:
      e.set(r++, t & 255 | MSB$2), t /= 128;
    case 7:
      e.set(r++, t & 255 | MSB$2), t /= 128;
    case 6:
      e.set(r++, t & 255 | MSB$2), t /= 128;
    case 5:
      e.set(r++, t & 255 | MSB$2), t /= 128;
    case 4:
      e.set(r++, t & 255 | MSB$2), t >>>= 7;
    case 3:
      e.set(r++, t & 255 | MSB$2), t >>>= 7;
    case 2:
      e.set(r++, t & 255 | MSB$2), t >>>= 7;
    case 1: {
      e.set(r++, t & 255), t >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return e;
}
function decodeUint8Array(t, e) {
  let r = t[e], n = 0;
  if (n += r & REST$2, r < MSB$2 || (r = t[e + 1], n += (r & REST$2) << 7, r < MSB$2) || (r = t[e + 2], n += (r & REST$2) << 14, r < MSB$2) || (r = t[e + 3], n += (r & REST$2) << 21, r < MSB$2) || (r = t[e + 4], n += (r & REST$2) * N4$1, r < MSB$2) || (r = t[e + 5], n += (r & REST$2) * N5$1, r < MSB$2) || (r = t[e + 6], n += (r & REST$2) * N6$1, r < MSB$2) || (r = t[e + 7], n += (r & REST$2) * N7$1, r < MSB$2))
    return n;
  throw new RangeError("Could not decode varint");
}
function decodeUint8ArrayList(t, e) {
  let r = t.get(e), n = 0;
  if (n += r & REST$2, r < MSB$2 || (r = t.get(e + 1), n += (r & REST$2) << 7, r < MSB$2) || (r = t.get(e + 2), n += (r & REST$2) << 14, r < MSB$2) || (r = t.get(e + 3), n += (r & REST$2) << 21, r < MSB$2) || (r = t.get(e + 4), n += (r & REST$2) * N4$1, r < MSB$2) || (r = t.get(e + 5), n += (r & REST$2) * N5$1, r < MSB$2) || (r = t.get(e + 6), n += (r & REST$2) * N6$1, r < MSB$2) || (r = t.get(e + 7), n += (r & REST$2) * N7$1, r < MSB$2))
    return n;
  throw new RangeError("Could not decode varint");
}
function encode$4(t, e, r = 0) {
  return e == null && (e = allocUnsafe$3(encodingLength(t))), e instanceof Uint8Array ? encodeUint8Array(t, e, r) : encodeUint8ArrayList(t, e, r);
}
function decode$4(t, e = 0) {
  return t instanceof Uint8Array ? decodeUint8Array(t, e) : decodeUint8ArrayList(t, e);
}
function isIP(t) {
  return Boolean(isIP$1(t));
}
const isV4$1 = isIPv4, isV6$1 = isIPv6, toBytes$2 = function(t) {
  let e = 0;
  if (t = t.toString().trim(), isV4$1(t)) {
    const r = new Uint8Array(e + 4);
    return t.split(/\./g).forEach((n) => {
      r[e++] = parseInt(n, 10) & 255;
    }), r;
  }
  if (isV6$1(t)) {
    const r = t.split(":", 8);
    let n;
    for (n = 0; n < r.length; n++) {
      const o = isV4$1(r[n]);
      let a;
      o && (a = toBytes$2(r[n]), r[n] = toString$2(a.slice(0, 2), "base16")), a != null && ++n < 8 && r.splice(n, 0, toString$2(a.slice(2, 4), "base16"));
    }
    if (r[0] === "")
      for (; r.length < 8; )
        r.unshift("0");
    else if (r[r.length - 1] === "")
      for (; r.length < 8; )
        r.push("0");
    else if (r.length < 8) {
      for (n = 0; n < r.length && r[n] !== ""; n++)
        ;
      const o = [n, 1];
      for (n = 9 - r.length; n > 0; n--)
        o.push("0");
      r.splice.apply(r, o);
    }
    const i = new Uint8Array(e + 16);
    for (n = 0; n < r.length; n++) {
      const o = parseInt(r[n], 16);
      i[e++] = o >> 8 & 255, i[e++] = o & 255;
    }
    return i;
  }
  throw new Error("invalid ip address");
}, toString$1 = function(t, e = 0, r) {
  e = ~~e, r = r ?? t.length - e;
  const n = new DataView(t.buffer);
  if (r === 4) {
    const i = [];
    for (let o = 0; o < r; o++)
      i.push(t[e + o]);
    return i.join(".");
  }
  if (r === 16) {
    const i = [];
    for (let o = 0; o < r; o += 2)
      i.push(n.getUint16(e + o).toString(16));
    return i.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
}, V$1 = -1, names$1 = {}, codes$3 = {}, table$1 = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V$1, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V$1, "dns", !0],
  [54, V$1, "dns4", !0],
  [55, V$1, "dns6", !0],
  [56, V$1, "dnsaddr", !0],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc-direct"],
  [281, 0, "webrtc"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V$1, "unix", !1, !0],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V$1, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V$1, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V$1, "garlic64"],
  [448, 0, "tls"],
  [449, V$1, "sni"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V$1, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V$1, "memory"]
];
table$1.forEach((t) => {
  const e = createProtocol$1(...t);
  codes$3[e.code] = e, names$1[e.name] = e;
});
function createProtocol$1(t, e, r, n, i) {
  return {
    code: t,
    size: e,
    name: r,
    resolvable: Boolean(n),
    path: Boolean(i)
  };
}
function getProtocol$1(t) {
  if (typeof t == "number") {
    if (codes$3[t] != null)
      return codes$3[t];
    throw new Error(`no protocol with code: ${t}`);
  } else if (typeof t == "string") {
    if (names$1[t] != null)
      return names$1[t];
    throw new Error(`no protocol with name: ${t}`);
  }
  throw new Error(`invalid protocol id type: ${typeof t}`);
}
getProtocol$1("ip4");
getProtocol$1("ip6");
getProtocol$1("ipcidr");
function convertToString$1(t, e) {
  switch (getProtocol$1(t).code) {
    case 4:
    case 41:
      return bytes2ip$1(e);
    case 42:
      return bytes2str$1(e);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port$1(e).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 449:
    case 777:
      return bytes2str$1(e);
    case 421:
      return bytes2mh$1(e);
    case 444:
      return bytes2onion$1(e);
    case 445:
      return bytes2onion$1(e);
    case 466:
      return bytes2mb$1(e);
    default:
      return toString$2(e, "base16");
  }
}
function convertToBytes$1(t, e) {
  switch (getProtocol$1(t).code) {
    case 4:
      return ip2bytes$1(e);
    case 41:
      return ip2bytes$1(e);
    case 42:
      return str2bytes$1(e);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes$1(parseInt(e, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 449:
    case 777:
      return str2bytes$1(e);
    case 421:
      return mh2bytes$1(e);
    case 444:
      return onion2bytes$1(e);
    case 445:
      return onion32bytes$1(e);
    case 466:
      return mb2bytes$1(e);
    default:
      return fromString$1(e, "base16");
  }
}
const decoders$1 = Object.values(bases$1).map((t) => t.decoder), anybaseDecoder$1 = function() {
  let t = decoders$1[0].or(decoders$1[1]);
  return decoders$1.slice(2).forEach((e) => t = t.or(e)), t;
}();
function ip2bytes$1(t) {
  if (!isIP(t))
    throw new Error("invalid ip address");
  return toBytes$2(t);
}
function bytes2ip$1(t) {
  const e = toString$1(t, 0, t.length);
  if (e == null)
    throw new Error("ipBuff is required");
  if (!isIP(e))
    throw new Error("invalid ip address");
  return e;
}
function port2bytes$1(t) {
  const e = new ArrayBuffer(2);
  return new DataView(e).setUint16(0, t), new Uint8Array(e);
}
function bytes2port$1(t) {
  return new DataView(t.buffer).getUint16(t.byteOffset);
}
function str2bytes$1(t) {
  const e = fromString$1(t), r = Uint8Array.from(encode$4(e.length));
  return concat$7([r, e], r.length + e.length);
}
function bytes2str$1(t) {
  const e = decode$4(t);
  if (t = t.slice(encodingLength(e)), t.length !== e)
    throw new Error("inconsistent lengths");
  return toString$2(t);
}
function mh2bytes$1(t) {
  let e;
  t[0] === "Q" || t[0] === "1" ? e = decode$a(base58btc$1.decode(`z${t}`)).bytes : e = CID$1.parse(t).multihash.bytes;
  const r = Uint8Array.from(encode$4(e.length));
  return concat$7([r, e], r.length + e.length);
}
function mb2bytes$1(t) {
  const e = anybaseDecoder$1.decode(t), r = Uint8Array.from(encode$4(e.length));
  return concat$7([r, e], r.length + e.length);
}
function bytes2mb$1(t) {
  const e = decode$4(t), r = t.slice(encodingLength(e));
  if (r.length !== e)
    throw new Error("inconsistent lengths");
  return "u" + toString$2(r, "base64url");
}
function bytes2mh$1(t) {
  const e = decode$4(t), r = t.slice(encodingLength(e));
  if (r.length !== e)
    throw new Error("inconsistent lengths");
  return toString$2(r, "base58btc");
}
function onion2bytes$1(t) {
  const e = t.split(":");
  if (e.length !== 2)
    throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
  if (e[0].length !== 16)
    throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
  const r = base32$2.decode("b" + e[0]), n = parseInt(e[1], 10);
  if (n < 1 || n > 65536)
    throw new Error("Port number is not in range(1, 65536)");
  const i = port2bytes$1(n);
  return concat$7([r, i], r.length + i.length);
}
function onion32bytes$1(t) {
  const e = t.split(":");
  if (e.length !== 2)
    throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
  if (e[0].length !== 56)
    throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
  const r = base32$2.decode(`b${e[0]}`), n = parseInt(e[1], 10);
  if (n < 1 || n > 65536)
    throw new Error("Port number is not in range(1, 65536)");
  const i = port2bytes$1(n);
  return concat$7([r, i], r.length + i.length);
}
function bytes2onion$1(t) {
  const e = t.slice(0, t.length - 2), r = t.slice(t.length - 2), n = toString$2(e, "base32"), i = bytes2port$1(r);
  return `${n}:${i}`;
}
function stringToMultiaddrParts(t) {
  t = cleanPath$1(t);
  const e = [], r = [];
  let n = null;
  const i = t.split("/").slice(1);
  if (i.length === 1 && i[0] === "")
    return {
      bytes: new Uint8Array(),
      string: "/",
      tuples: [],
      stringTuples: [],
      path: null
    };
  for (let o = 0; o < i.length; o++) {
    const a = i[o], c = getProtocol$1(a);
    if (c.size === 0) {
      e.push([c.code]), r.push([c.code]);
      continue;
    }
    if (o++, o >= i.length)
      throw ParseError$1("invalid address: " + t);
    if (c.path === !0) {
      n = cleanPath$1(i.slice(o).join("/")), e.push([c.code, convertToBytes$1(c.code, n)]), r.push([c.code, n]);
      break;
    }
    const l = convertToBytes$1(c.code, i[o]);
    e.push([c.code, l]), r.push([c.code, convertToString$1(c.code, l)]);
  }
  return {
    string: stringTuplesToString$1(r),
    bytes: tuplesToBytes$1(e),
    tuples: e,
    stringTuples: r,
    path: n
  };
}
function bytesToMultiaddrParts(t) {
  const e = [], r = [];
  let n = null, i = 0;
  for (; i < t.length; ) {
    const o = decode$4(t, i), a = encodingLength(o), c = getProtocol$1(o), l = sizeForAddr$1(c, t.slice(i + a));
    if (l === 0) {
      e.push([o]), r.push([o]), i += a;
      continue;
    }
    const u = t.slice(i + a, i + a + l);
    if (i += l + a, i > t.length)
      throw ParseError$1("Invalid address Uint8Array: " + toString$2(t, "base16"));
    e.push([o, u]);
    const f = convertToString$1(o, u);
    if (r.push([o, f]), c.path === !0) {
      n = f;
      break;
    }
  }
  return {
    bytes: Uint8Array.from(t),
    string: stringTuplesToString$1(r),
    tuples: e,
    stringTuples: r,
    path: n
  };
}
function stringTuplesToString$1(t) {
  const e = [];
  return t.map((r) => {
    const n = getProtocol$1(r[0]);
    return e.push(n.name), r.length > 1 && r[1] != null && e.push(r[1]), null;
  }), cleanPath$1(e.join("/"));
}
function tuplesToBytes$1(t) {
  return concat$7(t.map((e) => {
    const r = getProtocol$1(e[0]);
    let n = Uint8Array.from(encode$4(r.code));
    return e.length > 1 && e[1] != null && (n = concat$7([n, e[1]])), n;
  }));
}
function sizeForAddr$1(t, e) {
  if (t.size > 0)
    return t.size / 8;
  if (t.size === 0)
    return 0;
  {
    const r = decode$4(e instanceof Uint8Array ? e : Uint8Array.from(e));
    return r + encodingLength(r);
  }
}
function cleanPath$1(t) {
  return "/" + t.trim().split("/").filter((e) => e).join("/");
}
function ParseError$1(t) {
  return new Error("Error parsing address: " + t);
}
const inspect$1 = Symbol.for("nodejs.util.inspect.custom"), DNS_CODES$1 = [
  getProtocol$1("dns").code,
  getProtocol$1("dns4").code,
  getProtocol$1("dns6").code,
  getProtocol$1("dnsaddr").code
], resolvers$1 = /* @__PURE__ */ new Map(), symbol$3 = Symbol.for("@multiformats/js-multiaddr/multiaddr");
function isMultiaddr$1(t) {
  return Boolean(t == null ? void 0 : t[symbol$3]);
}
var $e, he, Ie, Re, an, le;
let DefaultMultiaddr$1 = (le = class {
  constructor(e) {
    $(this, "bytes");
    ie(this, $e, void 0);
    ie(this, he, void 0);
    ie(this, Ie, void 0);
    ie(this, Re, void 0);
    $(this, an, !0);
    e == null && (e = "");
    let r;
    if (e instanceof Uint8Array)
      r = bytesToMultiaddrParts(e);
    else if (typeof e == "string") {
      if (e.length > 0 && e.charAt(0) !== "/")
        throw new Error(`multiaddr "${e}" must start with a "/"`);
      r = stringToMultiaddrParts(e);
    } else if (isMultiaddr$1(e))
      r = bytesToMultiaddrParts(e.bytes);
    else
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    this.bytes = r.bytes, fe(this, $e, r.string), fe(this, he, r.tuples), fe(this, Ie, r.stringTuples), fe(this, Re, r.path);
  }
  toString() {
    return Y(this, $e);
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let e, r, n, i, o = "";
    const a = getProtocol$1("tcp"), c = getProtocol$1("udp"), l = getProtocol$1("ip4"), u = getProtocol$1("ip6"), f = getProtocol$1("dns6"), d = getProtocol$1("ip6zone");
    for (const [g, h] of this.stringTuples())
      g === d.code && (o = `%${h ?? ""}`), DNS_CODES$1.includes(g) && (r = a.name, i = 443, n = `${h ?? ""}${o}`, e = g === f.code ? 6 : 4), (g === a.code || g === c.code) && (r = getProtocol$1(g).name, i = parseInt(h ?? "")), (g === l.code || g === u.code) && (r = getProtocol$1(g).name, n = `${h ?? ""}${o}`, e = g === u.code ? 6 : 4);
    if (e == null || r == null || n == null || i == null)
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    return {
      family: e,
      host: n,
      transport: r,
      port: i
    };
  }
  protos() {
    return Y(this, he).map(([e]) => Object.assign({}, getProtocol$1(e)));
  }
  protoCodes() {
    return Y(this, he).map(([e]) => e);
  }
  protoNames() {
    return Y(this, he).map(([e]) => getProtocol$1(e).name);
  }
  tuples() {
    return Y(this, he);
  }
  stringTuples() {
    return Y(this, Ie);
  }
  encapsulate(e) {
    return e = new le(e), new le(this.toString() + e.toString());
  }
  decapsulate(e) {
    const r = e.toString(), n = this.toString(), i = n.lastIndexOf(r);
    if (i < 0)
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);
    return new le(n.slice(0, i));
  }
  decapsulateCode(e) {
    const r = this.tuples();
    for (let n = r.length - 1; n >= 0; n--)
      if (r[n][0] === e)
        return new le(tuplesToBytes$1(r.slice(0, n)));
    return this;
  }
  getPeerId() {
    try {
      let e = [];
      this.stringTuples().forEach(([n, i]) => {
        n === names$1.p2p.code && e.push([n, i]), n === names$1["p2p-circuit"].code && (e = []);
      });
      const r = e.pop();
      if ((r == null ? void 0 : r[1]) != null) {
        const n = r[1];
        return n[0] === "Q" || n[0] === "1" ? toString$2(base58btc$1.decode(`z${n}`), "base58btc") : toString$2(CID$1.parse(n).multihash.bytes, "base58btc");
      }
      return null;
    } catch {
      return null;
    }
  }
  getPath() {
    return Y(this, Re);
  }
  equals(e) {
    return equals$5(this.bytes, e.bytes);
  }
  async resolve(e) {
    const r = this.protos().find((o) => o.resolvable);
    if (r == null)
      return [this];
    const n = resolvers$1.get(r.name);
    if (n == null)
      throw new CodeError$2(`no available resolver for ${r.name}`, "ERR_NO_AVAILABLE_RESOLVER");
    return (await n(this, e)).map((o) => new le(o));
  }
  nodeAddress() {
    const e = this.toOptions();
    if (e.transport !== "tcp" && e.transport !== "udp")
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    return {
      family: e.family,
      address: e.host,
      port: e.port
    };
  }
  isThinWaistAddress(e) {
    const r = (e ?? this).protos();
    return !(r.length !== 2 || r[0].code !== 4 && r[0].code !== 41 || r[1].code !== 6 && r[1].code !== 273);
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(an = symbol$3, inspect$1)]() {
    return `Multiaddr(${Y(this, $e)})`;
  }
}, $e = new WeakMap(), he = new WeakMap(), Ie = new WeakMap(), Re = new WeakMap(), le);
function multiaddr$1(t) {
  return new DefaultMultiaddr$1(t);
}
const ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record", ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);
var PeerRecord$1;
(function(t) {
  (function(r) {
    let n;
    r.codec = () => (n == null && (n = message((i, o, a = {}) => {
      a.lengthDelimited !== !1 && o.fork(), i.multiaddr != null && i.multiaddr.byteLength > 0 && (o.uint32(10), o.bytes(i.multiaddr)), a.lengthDelimited !== !1 && o.ldelim();
    }, (i, o) => {
      const a = {
        multiaddr: new Uint8Array(0)
      }, c = o == null ? i.len : i.pos + o;
      for (; i.pos < c; ) {
        const l = i.uint32();
        switch (l >>> 3) {
          case 1:
            a.multiaddr = i.bytes();
            break;
          default:
            i.skipType(l & 7);
            break;
        }
      }
      return a;
    })), n), r.encode = (i) => encodeMessage(i, r.codec()), r.decode = (i) => decodeMessage(i, r.codec());
  })(t.AddressInfo || (t.AddressInfo = {}));
  let e;
  t.codec = () => (e == null && (e = message((r, n, i = {}) => {
    if (i.lengthDelimited !== !1 && n.fork(), r.peerId != null && r.peerId.byteLength > 0 && (n.uint32(10), n.bytes(r.peerId)), r.seq != null && r.seq !== 0n && (n.uint32(16), n.uint64(r.seq)), r.addresses != null)
      for (const o of r.addresses)
        n.uint32(26), t.AddressInfo.codec().encode(o, n);
    i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {
      peerId: new Uint8Array(0),
      seq: 0n,
      addresses: []
    }, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.peerId = r.bytes();
          break;
        case 2:
          i.seq = r.uint64();
          break;
        case 3:
          i.addresses.push(t.AddressInfo.codec().decode(r, r.uint32()));
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage(r, t.codec()), t.decode = (r) => decodeMessage(r, t.codec());
})(PeerRecord$1 || (PeerRecord$1 = {}));
const ve = class {
  constructor(e) {
    $(this, "peerId");
    $(this, "multiaddrs");
    $(this, "seqNumber");
    $(this, "domain", ve.DOMAIN);
    $(this, "codec", ve.CODEC);
    $(this, "marshaled");
    const { peerId: r, multiaddrs: n, seqNumber: i } = e;
    this.peerId = r, this.multiaddrs = n ?? [], this.seqNumber = i ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    return this.marshaled == null && (this.marshaled = PeerRecord$1.encode({
      peerId: this.peerId.toBytes(),
      seq: BigInt(this.seqNumber),
      addresses: this.multiaddrs.map((e) => ({
        multiaddr: e.bytes
      }))
    })), this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(e) {
    return !(!(e instanceof ve) || !this.peerId.equals(e.peerId) || this.seqNumber !== e.seqNumber || !arrayEquals(this.multiaddrs, e.multiaddrs));
  }
};
let PeerRecord = ve;
/**
 * Unmarshal Peer Record Protobuf
 */
$(PeerRecord, "createFromProtobuf", (e) => {
  const r = PeerRecord$1.decode(e), n = peerIdFromBytes(r.peerId), i = (r.addresses ?? []).map((a) => multiaddr$1(a.multiaddr)), o = r.seq;
  return new ve({ peerId: n, multiaddrs: i, seqNumber: o });
}), $(PeerRecord, "DOMAIN", ENVELOPE_DOMAIN_PEER_RECORD), $(PeerRecord, "CODEC", ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);
function isAsyncIterable$e(t) {
  return t[Symbol.asyncIterator] != null;
}
function all$1(t) {
  if (isAsyncIterable$e(t))
    return (async () => {
      const r = [];
      for await (const n of t)
        r.push(n);
      return r;
    })();
  const e = [];
  for (const r of t)
    e.push(r);
  return e;
}
var eventemitter3Exports = {}, eventemitter3 = {
  get exports() {
    return eventemitter3Exports;
  },
  set exports(t) {
    eventemitter3Exports = t;
  }
};
(function(t) {
  var e = Object.prototype.hasOwnProperty, r = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
  function i(l, u, f) {
    this.fn = l, this.context = u, this.once = f || !1;
  }
  function o(l, u, f, d, p) {
    if (typeof f != "function")
      throw new TypeError("The listener must be a function");
    var g = new i(f, d || l, p), h = r ? r + u : u;
    return l._events[h] ? l._events[h].fn ? l._events[h] = [l._events[h], g] : l._events[h].push(g) : (l._events[h] = g, l._eventsCount++), l;
  }
  function a(l, u) {
    --l._eventsCount === 0 ? l._events = new n() : delete l._events[u];
  }
  function c() {
    this._events = new n(), this._eventsCount = 0;
  }
  c.prototype.eventNames = function() {
    var u = [], f, d;
    if (this._eventsCount === 0)
      return u;
    for (d in f = this._events)
      e.call(f, d) && u.push(r ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(f)) : u;
  }, c.prototype.listeners = function(u) {
    var f = r ? r + u : u, d = this._events[f];
    if (!d)
      return [];
    if (d.fn)
      return [d.fn];
    for (var p = 0, g = d.length, h = new Array(g); p < g; p++)
      h[p] = d[p].fn;
    return h;
  }, c.prototype.listenerCount = function(u) {
    var f = r ? r + u : u, d = this._events[f];
    return d ? d.fn ? 1 : d.length : 0;
  }, c.prototype.emit = function(u, f, d, p, g, h) {
    var m = r ? r + u : u;
    if (!this._events[m])
      return !1;
    var y = this._events[m], b = arguments.length, v, _;
    if (y.fn) {
      switch (y.once && this.removeListener(u, y.fn, void 0, !0), b) {
        case 1:
          return y.fn.call(y.context), !0;
        case 2:
          return y.fn.call(y.context, f), !0;
        case 3:
          return y.fn.call(y.context, f, d), !0;
        case 4:
          return y.fn.call(y.context, f, d, p), !0;
        case 5:
          return y.fn.call(y.context, f, d, p, g), !0;
        case 6:
          return y.fn.call(y.context, f, d, p, g, h), !0;
      }
      for (_ = 1, v = new Array(b - 1); _ < b; _++)
        v[_ - 1] = arguments[_];
      y.fn.apply(y.context, v);
    } else {
      var E = y.length, w;
      for (_ = 0; _ < E; _++)
        switch (y[_].once && this.removeListener(u, y[_].fn, void 0, !0), b) {
          case 1:
            y[_].fn.call(y[_].context);
            break;
          case 2:
            y[_].fn.call(y[_].context, f);
            break;
          case 3:
            y[_].fn.call(y[_].context, f, d);
            break;
          case 4:
            y[_].fn.call(y[_].context, f, d, p);
            break;
          default:
            if (!v)
              for (w = 1, v = new Array(b - 1); w < b; w++)
                v[w - 1] = arguments[w];
            y[_].fn.apply(y[_].context, v);
        }
    }
    return !0;
  }, c.prototype.on = function(u, f, d) {
    return o(this, u, f, d, !1);
  }, c.prototype.once = function(u, f, d) {
    return o(this, u, f, d, !0);
  }, c.prototype.removeListener = function(u, f, d, p) {
    var g = r ? r + u : u;
    if (!this._events[g])
      return this;
    if (!f)
      return a(this, g), this;
    var h = this._events[g];
    if (h.fn)
      h.fn === f && (!p || h.once) && (!d || h.context === d) && a(this, g);
    else {
      for (var m = 0, y = [], b = h.length; m < b; m++)
        (h[m].fn !== f || p && !h[m].once || d && h[m].context !== d) && y.push(h[m]);
      y.length ? this._events[g] = y.length === 1 ? y[0] : y : a(this, g);
    }
    return this;
  }, c.prototype.removeAllListeners = function(u) {
    var f;
    return u ? (f = r ? r + u : u, this._events[f] && a(this, f)) : (this._events = new n(), this._eventsCount = 0), this;
  }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = r, c.EventEmitter = c, t.exports = c;
})(eventemitter3);
let TimeoutError$1 = class extends Error {
  constructor(e) {
    super(e), this.name = "TimeoutError";
  }
}, AbortError$5 = class extends Error {
  constructor(e) {
    super(), this.name = "AbortError", this.message = e;
  }
};
const getDOMException$1 = (t) => globalThis.DOMException === void 0 ? new AbortError$5(t) : new DOMException(t), getAbortedReason$1 = (t) => {
  const e = t.reason === void 0 ? getDOMException$1("This operation was aborted.") : t.reason;
  return e instanceof Error ? e : getDOMException$1(e);
};
function pTimeout$1(t, e, r, n) {
  let i;
  const o = new Promise((a, c) => {
    if (typeof e != "number" || Math.sign(e) !== 1)
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);
    if (e === Number.POSITIVE_INFINITY) {
      a(t);
      return;
    }
    if (n = {
      customTimers: { setTimeout, clearTimeout },
      ...n
    }, n.signal) {
      const { signal: l } = n;
      l.aborted && c(getAbortedReason$1(l)), l.addEventListener("abort", () => {
        c(getAbortedReason$1(l));
      });
    }
    i = n.customTimers.setTimeout.call(void 0, () => {
      if (typeof r == "function") {
        try {
          a(r());
        } catch (f) {
          c(f);
        }
        return;
      }
      const l = typeof r == "string" ? r : `Promise timed out after ${e} milliseconds`, u = r instanceof Error ? r : new TimeoutError$1(l);
      typeof t.cancel == "function" && t.cancel(), c(u);
    }, e), (async () => {
      try {
        a(await t);
      } catch (l) {
        c(l);
      } finally {
        n.customTimers.clearTimeout.call(void 0, i);
      }
    })();
  });
  return o.clear = () => {
    clearTimeout(i), i = void 0;
  }, o;
}
function lowerBound$1(t, e, r) {
  let n = 0, i = t.length;
  for (; i > 0; ) {
    const o = Math.trunc(i / 2);
    let a = n + o;
    r(t[a], e) <= 0 ? (n = ++a, i -= o + 1) : i = o;
  }
  return n;
}
var __classPrivateFieldGet$2 = globalThis && globalThis.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, _PriorityQueue_queue;
class PriorityQueue {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(e, r) {
    r = {
      priority: 0,
      ...r
    };
    const n = {
      priority: r.priority,
      run: e
    };
    if (this.size && __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= r.priority) {
      __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").push(n);
      return;
    }
    const i = lowerBound$1(__classPrivateFieldGet$2(this, _PriorityQueue_queue, "f"), n, (o, a) => a.priority - o.priority);
    __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").splice(i, 0, n);
  }
  dequeue() {
    const e = __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").shift();
    return e == null ? void 0 : e.run;
  }
  filter(e) {
    return __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").filter((r) => r.priority === e.priority).map((r) => r.run);
  }
  get size() {
    return __classPrivateFieldGet$2(this, _PriorityQueue_queue, "f").length;
  }
}
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet$1 = globalThis && globalThis.__classPrivateFieldSet || function(t, e, r, n, i) {
  if (n === "m")
    throw new TypeError("Private method is not writable");
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? i.call(t, r) : i ? i.value = r : e.set(t, r), r;
}, __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;
let AbortError$4 = class extends Error {
};
class PQueue extends eventemitter3Exports {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(e) {
    var r, n, i, o;
    if (super(), _PQueue_instances.add(this), _PQueue_carryoverConcurrencyCount.set(this, void 0), _PQueue_isIntervalIgnored.set(this, void 0), _PQueue_intervalCount.set(this, 0), _PQueue_intervalCap.set(this, void 0), _PQueue_interval.set(this, void 0), _PQueue_intervalEnd.set(this, 0), _PQueue_intervalId.set(this, void 0), _PQueue_timeoutId.set(this, void 0), _PQueue_queue.set(this, void 0), _PQueue_queueClass.set(this, void 0), _PQueue_pending.set(this, 0), _PQueue_concurrency.set(this, void 0), _PQueue_isPaused.set(this, void 0), _PQueue_throwOnTimeout.set(this, void 0), Object.defineProperty(this, "timeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), e = {
      carryoverConcurrencyCount: !1,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: !0,
      queueClass: PriorityQueue,
      ...e
    }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (r = e.intervalCap) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
    if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (i = e.interval) === null || i === void 0 ? void 0 : i.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`);
    __classPrivateFieldSet$1(this, _PQueue_carryoverConcurrencyCount, e.carryoverConcurrencyCount, "f"), __classPrivateFieldSet$1(this, _PQueue_isIntervalIgnored, e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, "f"), __classPrivateFieldSet$1(this, _PQueue_intervalCap, e.intervalCap, "f"), __classPrivateFieldSet$1(this, _PQueue_interval, e.interval, "f"), __classPrivateFieldSet$1(this, _PQueue_queue, new e.queueClass(), "f"), __classPrivateFieldSet$1(this, _PQueue_queueClass, e.queueClass, "f"), this.concurrency = e.concurrency, this.timeout = e.timeout, __classPrivateFieldSet$1(this, _PQueue_throwOnTimeout, e.throwOnTimeout === !0, "f"), __classPrivateFieldSet$1(this, _PQueue_isPaused, e.autoStart === !1, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet$1(this, _PQueue_concurrency, "f");
  }
  set concurrency(e) {
    if (!(typeof e == "number" && e >= 1))
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
    __classPrivateFieldSet$1(this, _PQueue_concurrency, e, "f"), __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(e, r = {}) {
    return r = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet$1(this, _PQueue_throwOnTimeout, "f"),
      ...r
    }, new Promise((n, i) => {
      __classPrivateFieldGet$1(this, _PQueue_queue, "f").enqueue(async () => {
        var o, a, c;
        __classPrivateFieldSet$1(this, _PQueue_pending, (a = __classPrivateFieldGet$1(this, _PQueue_pending, "f"), a++, a), "f"), __classPrivateFieldSet$1(this, _PQueue_intervalCount, (c = __classPrivateFieldGet$1(this, _PQueue_intervalCount, "f"), c++, c), "f");
        try {
          if (!((o = r.signal) === null || o === void 0) && o.aborted)
            throw new AbortError$4("The task was aborted.");
          let l = e({ signal: r.signal });
          r.timeout && (l = pTimeout$1(Promise.resolve(l), r.timeout)), r.signal && (l = Promise.race([l, __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, r.signal)]));
          const u = await l;
          n(u), this.emit("completed", u);
        } catch (l) {
          if (l instanceof TimeoutError$1 && !r.throwOnTimeout) {
            n();
            return;
          }
          i(l), this.emit("error", l);
        } finally {
          __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_next).call(this);
        }
      }, r), this.emit("add"), __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    });
  }
  async addAll(e, r) {
    return Promise.all(e.map(async (n) => this.add(n, r)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    return __classPrivateFieldGet$1(this, _PQueue_isPaused, "f") ? (__classPrivateFieldSet$1(this, _PQueue_isPaused, !1, "f"), __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_processQueue).call(this), this) : this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet$1(this, _PQueue_isPaused, !0, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet$1(this, _PQueue_queue, new (__classPrivateFieldGet$1(this, _PQueue_queueClass, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    __classPrivateFieldGet$1(this, _PQueue_queue, "f").size !== 0 && await __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(e) {
    __classPrivateFieldGet$1(this, _PQueue_queue, "f").size < e || await __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet$1(this, _PQueue_queue, "f").size < e);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    __classPrivateFieldGet$1(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet$1(this, _PQueue_queue, "f").size === 0 || await __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet$1(this, _PQueue_queue, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(e) {
    return __classPrivateFieldGet$1(this, _PQueue_queue, "f").filter(e).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet$1(this, _PQueue_pending, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet$1(this, _PQueue_isPaused, "f");
  }
}
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pending = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function t() {
  return __classPrivateFieldGet$1(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet$1(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet$1(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function t() {
  return __classPrivateFieldGet$1(this, _PQueue_pending, "f") < __classPrivateFieldGet$1(this, _PQueue_concurrency, "f");
}, _PQueue_next = function t() {
  var e;
  __classPrivateFieldSet$1(this, _PQueue_pending, (e = __classPrivateFieldGet$1(this, _PQueue_pending, "f"), e--, e), "f"), __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this), this.emit("next");
}, _PQueue_onResumeInterval = function t() {
  __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onInterval).call(this), __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), __classPrivateFieldSet$1(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function t() {
  const e = Date.now();
  if (__classPrivateFieldGet$1(this, _PQueue_intervalId, "f") === void 0) {
    const r = __classPrivateFieldGet$1(this, _PQueue_intervalEnd, "f") - e;
    if (r < 0)
      __classPrivateFieldSet$1(this, _PQueue_intervalCount, __classPrivateFieldGet$1(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet$1(this, _PQueue_pending, "f") : 0, "f");
    else
      return __classPrivateFieldGet$1(this, _PQueue_timeoutId, "f") === void 0 && __classPrivateFieldSet$1(this, _PQueue_timeoutId, setTimeout(() => {
        __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
      }, r), "f"), !0;
  }
  return !1;
}, _PQueue_tryToStartAnother = function t() {
  if (__classPrivateFieldGet$1(this, _PQueue_queue, "f").size === 0)
    return __classPrivateFieldGet$1(this, _PQueue_intervalId, "f") && clearInterval(__classPrivateFieldGet$1(this, _PQueue_intervalId, "f")), __classPrivateFieldSet$1(this, _PQueue_intervalId, void 0, "f"), this.emit("empty"), __classPrivateFieldGet$1(this, _PQueue_pending, "f") === 0 && this.emit("idle"), !1;
  if (!__classPrivateFieldGet$1(this, _PQueue_isPaused, "f")) {
    const e = !__classPrivateFieldGet$1(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet$1(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet$1(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const r = __classPrivateFieldGet$1(this, _PQueue_queue, "f").dequeue();
      return r ? (this.emit("active"), r(), e && __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), !0) : !1;
    }
  }
  return !1;
}, _PQueue_initializeIntervalIfNeeded = function t() {
  __classPrivateFieldGet$1(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet$1(this, _PQueue_intervalId, "f") !== void 0 || (__classPrivateFieldSet$1(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet$1(this, _PQueue_interval, "f")), "f"), __classPrivateFieldSet$1(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet$1(this, _PQueue_interval, "f"), "f"));
}, _PQueue_onInterval = function t() {
  __classPrivateFieldGet$1(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet$1(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet$1(this, _PQueue_intervalId, "f") && (clearInterval(__classPrivateFieldGet$1(this, _PQueue_intervalId, "f")), __classPrivateFieldSet$1(this, _PQueue_intervalId, void 0, "f")), __classPrivateFieldSet$1(this, _PQueue_intervalCount, __classPrivateFieldGet$1(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet$1(this, _PQueue_pending, "f") : 0, "f"), __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function t() {
  for (; __classPrivateFieldGet$1(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this); )
    ;
}, _PQueue_throwOnAbort = async function t(e) {
  return new Promise((r, n) => {
    e.addEventListener("abort", () => {
      n(new AbortError$4("The task was aborted."));
    }, { once: !0 });
  });
}, _PQueue_onEvent = async function t(e, r) {
  return new Promise((n) => {
    const i = () => {
      r && !r() || (this.off(e, i), n());
    };
    this.on(e, i);
  });
};
class TimeoutError extends Error {
  constructor(e) {
    super(e), this.name = "TimeoutError";
  }
}
let AbortError$3 = class extends Error {
  constructor(e) {
    super(), this.name = "AbortError", this.message = e;
  }
};
const getDOMException = (t) => globalThis.DOMException === void 0 ? new AbortError$3(t) : new DOMException(t), getAbortedReason = (t) => {
  const e = t.reason === void 0 ? getDOMException("This operation was aborted.") : t.reason;
  return e instanceof Error ? e : getDOMException(e);
};
function pTimeout(t, e) {
  const {
    milliseconds: r,
    fallback: n,
    message: i,
    customTimers: o = { setTimeout, clearTimeout }
  } = e;
  let a;
  const l = new Promise((u, f) => {
    if (typeof r != "number" || Math.sign(r) !== 1)
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${r}\``);
    if (e.signal) {
      const { signal: p } = e;
      p.aborted && f(getAbortedReason(p)), p.addEventListener("abort", () => {
        f(getAbortedReason(p));
      });
    }
    if (r === Number.POSITIVE_INFINITY) {
      t.then(u, f);
      return;
    }
    const d = new TimeoutError();
    a = o.setTimeout.call(void 0, () => {
      if (n) {
        try {
          u(n());
        } catch (p) {
          f(p);
        }
        return;
      }
      typeof t.cancel == "function" && t.cancel(), i === !1 ? u() : i instanceof Error ? f(i) : (d.message = i ?? `Promise timed out after ${r} milliseconds`, f(d));
    }, r), (async () => {
      try {
        u(await t);
      } catch (p) {
        f(p);
      }
    })();
  }).finally(() => {
    l.clear();
  });
  return l.clear = () => {
    o.clearTimeout.call(void 0, a), a = void 0;
  }, l;
}
const WORKER_REQUEST_READ_LOCK = "lock:worker:request-read", WORKER_RELEASE_READ_LOCK = "lock:worker:release-read", MASTER_GRANT_READ_LOCK = "lock:master:grant-read", WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write", WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write", MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write", handleWorkerLockRequest = (t, e, r, n, i) => (o, a) => {
  a != null && a.type === r && t.dispatchEvent(new MessageEvent(e, {
    data: {
      name: a.name,
      handler: async () => (o.send({
        type: i,
        name: a.name,
        identifier: a.identifier
      }), await new Promise((c) => {
        const l = (u) => {
          u.type === n && u.identifier === a.identifier && (o.removeListener("message", l), c());
        };
        o.on("message", l);
      }))
    }
  }));
}, makeWorkerLockRequest = (t, e, r, n) => async () => {
  const i = nanoid();
  if (process.send == null)
    throw new Error("No send method on process - are we a cluster worker?");
  return process.send({
    type: e,
    identifier: i,
    name: t
  }), await new Promise((o) => {
    const a = (c) => {
      c.type === r && c.identifier === i && (process.removeListener("message", a), o(() => {
        if (process.send == null)
          throw new Error("No send method on process - are we a cluster worker?");
        process.send({
          type: n,
          identifier: i,
          name: t
        });
      }));
    };
    process.on("message", a);
  });
}, impl = (t) => {
  if (cluster$1.isPrimary || t.singleProcess) {
    const e = new EventTarget();
    return cluster$1.on("message", handleWorkerLockRequest(e, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK)), cluster$1.on("message", handleWorkerLockRequest(e, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK)), e;
  }
  return {
    isWorker: !0,
    readLock: (e) => makeWorkerLockRequest(e, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (e) => makeWorkerLockRequest(e, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
}, mutexes = {};
let implementation$3;
async function createReleaseable(t, e) {
  let r;
  const n = new Promise((i) => {
    r = i;
  });
  return t.add(async () => await pTimeout((async () => await new Promise((i) => {
    r(() => {
      i();
    });
  }))(), {
    milliseconds: e.timeout
  })), await n;
}
const createMutex = (t, e) => {
  if (implementation$3.isWorker === !0)
    return {
      readLock: implementation$3.readLock(t, e),
      writeLock: implementation$3.writeLock(t, e)
    };
  const r = new PQueue({ concurrency: 1 });
  let n;
  return {
    async readLock() {
      if (n != null)
        return await createReleaseable(n, e);
      n = new PQueue({
        concurrency: e.concurrency,
        autoStart: !1
      });
      const i = n, o = createReleaseable(n, e);
      return r.add(async () => (i.start(), await i.onIdle().then(() => {
        n === i && (n = null);
      }))), await o;
    },
    async writeLock() {
      return n = null, await createReleaseable(r, e);
    }
  };
}, defaultOptions$4 = {
  name: "lock",
  concurrency: 1 / 0,
  timeout: 846e5,
  singleProcess: !1
};
function createMortice(t) {
  const e = Object.assign({}, defaultOptions$4, t);
  return implementation$3 == null && (implementation$3 = impl(e), implementation$3.isWorker !== !0 && (implementation$3.addEventListener("requestReadLock", (r) => {
    mutexes[r.data.name] != null && mutexes[r.data.name].readLock().then(async (n) => await r.data.handler().finally(() => n()));
  }), implementation$3.addEventListener("requestWriteLock", async (r) => {
    mutexes[r.data.name] != null && mutexes[r.data.name].writeLock().then(async (n) => await r.data.handler().finally(() => n()));
  }))), mutexes[e.name] == null && (mutexes[e.name] = createMutex(e.name, e)), mutexes[e.name];
}
const codes$2 = {
  ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS"
};
var Peer;
(function(t) {
  (function(r) {
    let n;
    r.codec = () => (n == null && (n = message((i, o, a = {}) => {
      a.lengthDelimited !== !1 && o.fork(), i.key != null && i.key !== "" && (o.uint32(10), o.string(i.key)), i.value != null && i.value.byteLength > 0 && (o.uint32(18), o.bytes(i.value)), a.lengthDelimited !== !1 && o.ldelim();
    }, (i, o) => {
      const a = {
        key: "",
        value: new Uint8Array(0)
      }, c = o == null ? i.len : i.pos + o;
      for (; i.pos < c; ) {
        const l = i.uint32();
        switch (l >>> 3) {
          case 1:
            a.key = i.string();
            break;
          case 2:
            a.value = i.bytes();
            break;
          default:
            i.skipType(l & 7);
            break;
        }
      }
      return a;
    })), n), r.encode = (i) => encodeMessage(i, r.codec()), r.decode = (i) => decodeMessage(i, r.codec());
  })(t.Peer$metadataEntry || (t.Peer$metadataEntry = {})), function(r) {
    let n;
    r.codec = () => (n == null && (n = message((i, o, a = {}) => {
      a.lengthDelimited !== !1 && o.fork(), i.key != null && i.key !== "" && (o.uint32(10), o.string(i.key)), i.value != null && (o.uint32(18), Tag.codec().encode(i.value, o)), a.lengthDelimited !== !1 && o.ldelim();
    }, (i, o) => {
      const a = {
        key: ""
      }, c = o == null ? i.len : i.pos + o;
      for (; i.pos < c; ) {
        const l = i.uint32();
        switch (l >>> 3) {
          case 1:
            a.key = i.string();
            break;
          case 2:
            a.value = Tag.codec().decode(i, i.uint32());
            break;
          default:
            i.skipType(l & 7);
            break;
        }
      }
      return a;
    })), n), r.encode = (i) => encodeMessage(i, r.codec()), r.decode = (i) => decodeMessage(i, r.codec());
  }(t.Peer$tagsEntry || (t.Peer$tagsEntry = {}));
  let e;
  t.codec = () => (e == null && (e = message((r, n, i = {}) => {
    if (i.lengthDelimited !== !1 && n.fork(), r.addresses != null)
      for (const o of r.addresses)
        n.uint32(10), Address.codec().encode(o, n);
    if (r.protocols != null)
      for (const o of r.protocols)
        n.uint32(18), n.string(o);
    if (r.publicKey != null && (n.uint32(34), n.bytes(r.publicKey)), r.peerRecordEnvelope != null && (n.uint32(42), n.bytes(r.peerRecordEnvelope)), r.metadata != null && r.metadata.size !== 0)
      for (const [o, a] of r.metadata.entries())
        n.uint32(50), t.Peer$metadataEntry.codec().encode({ key: o, value: a }, n);
    if (r.tags != null && r.tags.size !== 0)
      for (const [o, a] of r.tags.entries())
        n.uint32(58), t.Peer$tagsEntry.codec().encode({ key: o, value: a }, n);
    i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {
      addresses: [],
      protocols: [],
      metadata: /* @__PURE__ */ new Map(),
      tags: /* @__PURE__ */ new Map()
    }, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.addresses.push(Address.codec().decode(r, r.uint32()));
          break;
        case 2:
          i.protocols.push(r.string());
          break;
        case 4:
          i.publicKey = r.bytes();
          break;
        case 5:
          i.peerRecordEnvelope = r.bytes();
          break;
        case 6: {
          const c = t.Peer$metadataEntry.codec().decode(r, r.uint32());
          i.metadata.set(c.key, c.value);
          break;
        }
        case 7: {
          const c = t.Peer$tagsEntry.codec().decode(r, r.uint32());
          i.tags.set(c.key, c.value);
          break;
        }
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage(r, t.codec()), t.decode = (r) => decodeMessage(r, t.codec());
})(Peer || (Peer = {}));
var Address;
(function(t) {
  let e;
  t.codec = () => (e == null && (e = message((r, n, i = {}) => {
    i.lengthDelimited !== !1 && n.fork(), r.multiaddr != null && r.multiaddr.byteLength > 0 && (n.uint32(10), n.bytes(r.multiaddr)), r.isCertified != null && (n.uint32(16), n.bool(r.isCertified)), i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {
      multiaddr: new Uint8Array(0)
    }, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.multiaddr = r.bytes();
          break;
        case 2:
          i.isCertified = r.bool();
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage(r, t.codec()), t.decode = (r) => decodeMessage(r, t.codec());
})(Address || (Address = {}));
var Tag;
(function(t) {
  let e;
  t.codec = () => (e == null && (e = message((r, n, i = {}) => {
    i.lengthDelimited !== !1 && n.fork(), r.value != null && r.value !== 0 && (n.uint32(8), n.uint32(r.value)), r.expiry != null && (n.uint32(16), n.uint64(r.expiry)), i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {
      value: 0
    }, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.value = r.uint32();
          break;
        case 2:
          i.expiry = r.uint64();
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage(r, t.codec()), t.decode = (r) => decodeMessage(r, t.codec());
})(Tag || (Tag = {}));
function bytesToPeer(t, e) {
  const r = Peer.decode(e);
  r.publicKey != null && t.publicKey == null && (t = peerIdFromPeerId({
    ...t,
    publicKey: t.publicKey
  }));
  const n = /* @__PURE__ */ new Map(), i = BigInt(Date.now());
  for (const [o, a] of r.tags.entries())
    a.expiry != null && a.expiry < i || n.set(o, a);
  return {
    ...r,
    id: t,
    addresses: r.addresses.map(({ multiaddr: o, isCertified: a }) => ({
      multiaddr: multiaddr$1(o),
      isCertified: a ?? !1
    })),
    metadata: r.metadata,
    peerRecordEnvelope: r.peerRecordEnvelope ?? void 0,
    tags: n
  };
}
const NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(t) {
  if (!isPeerId(t) || t.type == null)
    throw new CodeError$2("Invalid PeerId", codes$2.ERR_INVALID_PARAMETERS);
  const e = t.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${e}`);
}
async function dedupeFilterAndSortAddresses(t, e, r) {
  const n = /* @__PURE__ */ new Map();
  for (const i of r) {
    if (i == null)
      continue;
    if (i.multiaddr instanceof Uint8Array && (i.multiaddr = multiaddr$1(i.multiaddr)), !isMultiaddr$1(i.multiaddr))
      throw new CodeError$2("Multiaddr was invalid", codes$2.ERR_INVALID_PARAMETERS);
    if (!await e(t, i.multiaddr))
      continue;
    const o = i.isCertified ?? !1, a = i.multiaddr.toString(), c = n.get(a);
    c != null ? i.isCertified = c.isCertified || o : n.set(a, {
      multiaddr: i.multiaddr,
      isCertified: o
    });
  }
  return [...n.values()].sort((i, o) => i.multiaddr.toString().localeCompare(o.multiaddr.toString())).map(({ isCertified: i, multiaddr: o }) => ({
    isCertified: i,
    multiaddr: o.bytes
  }));
}
async function toPeerPB(t, e, r, n) {
  if (e == null)
    throw new CodeError$2("Invalid PeerData", codes$2.ERR_INVALID_PARAMETERS);
  if (e.publicKey != null && t.publicKey != null && !equals$2(e.publicKey, t.publicKey))
    throw new CodeError$2("publicKey bytes do not match peer id publicKey bytes", codes$2.ERR_INVALID_PARAMETERS);
  const i = n.existingPeer;
  if (i != null && !t.equals(i.id))
    throw new CodeError$2("peer id did not match existing peer id", codes$2.ERR_INVALID_PARAMETERS);
  let o = (i == null ? void 0 : i.addresses) ?? [], a = new Set((i == null ? void 0 : i.protocols) ?? []), c = (i == null ? void 0 : i.metadata) ?? /* @__PURE__ */ new Map(), l = (i == null ? void 0 : i.tags) ?? /* @__PURE__ */ new Map(), u = i == null ? void 0 : i.peerRecordEnvelope;
  if (r === "patch") {
    if ((e.multiaddrs != null || e.addresses != null) && (o = [], e.multiaddrs != null && o.push(...e.multiaddrs.map((d) => ({
      isCertified: !1,
      multiaddr: d
    }))), e.addresses != null && o.push(...e.addresses)), e.protocols != null && (a = new Set(e.protocols)), e.metadata != null) {
      const d = e.metadata instanceof Map ? [...e.metadata.entries()] : Object.entries(e.metadata);
      c = createSortedMap(d, {
        validate: validateMetadata
      });
    }
    if (e.tags != null) {
      const d = e.tags instanceof Map ? [...e.tags.entries()] : Object.entries(e.tags);
      l = createSortedMap(d, {
        validate: validateTag,
        map: mapTag
      });
    }
    e.peerRecordEnvelope != null && (u = e.peerRecordEnvelope);
  }
  if (r === "merge") {
    if (e.multiaddrs != null && o.push(...e.multiaddrs.map((d) => ({
      isCertified: !1,
      multiaddr: d
    }))), e.addresses != null && o.push(...e.addresses), e.protocols != null && (a = /* @__PURE__ */ new Set([...a, ...e.protocols])), e.metadata != null) {
      const d = e.metadata instanceof Map ? [...e.metadata.entries()] : Object.entries(e.metadata);
      for (const [p, g] of d)
        g == null ? c.delete(p) : c.set(p, g);
      c = createSortedMap([...c.entries()], {
        validate: validateMetadata
      });
    }
    if (e.tags != null) {
      const d = e.tags instanceof Map ? [...e.tags.entries()] : Object.entries(e.tags), p = new Map(l);
      for (const [g, h] of d)
        h == null ? p.delete(g) : p.set(g, h);
      l = createSortedMap([...p.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    e.peerRecordEnvelope != null && (u = e.peerRecordEnvelope);
  }
  const f = {
    addresses: await dedupeFilterAndSortAddresses(t, n.addressFilter ?? (async () => !0), o),
    protocols: [...a.values()].sort((d, p) => d.localeCompare(p)),
    metadata: c,
    tags: l,
    publicKey: (i == null ? void 0 : i.id.publicKey) ?? e.publicKey ?? t.publicKey,
    peerRecordEnvelope: u
  };
  return t.type !== "RSA" && delete f.publicKey, f;
}
function createSortedMap(t, e) {
  var n;
  const r = /* @__PURE__ */ new Map();
  for (const [i, o] of t)
    o != null && e.validate(i, o);
  for (const [i, o] of t.sort(([a], [c]) => a.localeCompare(c)))
    o != null && r.set(i, ((n = e.map) == null ? void 0 : n.call(e, i, o)) ?? o);
  return r;
}
function validateMetadata(t, e) {
  if (typeof t != "string")
    throw new CodeError$2("Metadata key must be a string", codes$2.ERR_INVALID_PARAMETERS);
  if (!(e instanceof Uint8Array))
    throw new CodeError$2("Metadata value must be a Uint8Array", codes$2.ERR_INVALID_PARAMETERS);
}
function validateTag(t, e) {
  if (typeof t != "string")
    throw new CodeError$2("Tag name must be a string", codes$2.ERR_INVALID_PARAMETERS);
  if (e.value != null) {
    if (parseInt(`${e.value}`, 10) !== e.value)
      throw new CodeError$2("Tag value must be an integer", codes$2.ERR_INVALID_PARAMETERS);
    if (e.value < 0 || e.value > 100)
      throw new CodeError$2("Tag value must be between 0-100", codes$2.ERR_INVALID_PARAMETERS);
  }
  if (e.ttl != null) {
    if (parseInt(`${e.ttl}`, 10) !== e.ttl)
      throw new CodeError$2("Tag ttl must be an integer", codes$2.ERR_INVALID_PARAMETERS);
    if (e.ttl < 0)
      throw new CodeError$2("Tag ttl must be between greater than 0", codes$2.ERR_INVALID_PARAMETERS);
  }
}
function mapTag(t, e) {
  let r;
  return e.expiry != null && (r = e.expiry), e.ttl != null && (r = BigInt(Date.now() + Number(e.ttl))), {
    value: e.value ?? 0,
    expiry: r
  };
}
function decodePeer(t, e, r) {
  const n = t.toString().split("/")[2], i = base32$2.decode(n), o = peerIdFromBytes(i), a = r.get(o);
  if (a != null)
    return a;
  const c = bytesToPeer(o, e);
  return r.set(o, c), c;
}
function mapQuery(t, e) {
  return t == null ? {} : {
    prefix: NAMESPACE_COMMON,
    filters: (t.filters ?? []).map((r) => ({ key: n, value: i }) => r(decodePeer(n, i, e))),
    orders: (t.orders ?? []).map((r) => (n, i) => r(decodePeer(n.key, n.value, e), decodePeer(i.key, i.value, e)))
  };
}
var Ee, Fe, we, Ue;
class PersistentStore {
  constructor(e, r = {}) {
    ie(this, Ee);
    ie(this, we);
    $(this, "peerId");
    $(this, "datastore");
    $(this, "lock");
    $(this, "addressFilter");
    this.peerId = e.peerId, this.datastore = e.datastore, this.addressFilter = r.addressFilter, this.lock = createMortice({
      name: "peer-store",
      singleProcess: !0
    });
  }
  async has(e) {
    return this.datastore.has(peerIdToDatastoreKey(e));
  }
  async delete(e) {
    if (this.peerId.equals(e))
      throw new CodeError$2("Cannot delete self peer", codes$2.ERR_INVALID_PARAMETERS);
    await this.datastore.delete(peerIdToDatastoreKey(e));
  }
  async load(e) {
    const r = await this.datastore.get(peerIdToDatastoreKey(e));
    return bytesToPeer(e, r);
  }
  async save(e, r) {
    const { existingBuf: n, existingPeer: i } = await re(this, Ee, Fe).call(this, e), o = await toPeerPB(e, r, "patch", {
      addressFilter: this.addressFilter
    });
    return re(this, we, Ue).call(this, e, o, n, i);
  }
  async patch(e, r) {
    const { existingBuf: n, existingPeer: i } = await re(this, Ee, Fe).call(this, e), o = await toPeerPB(e, r, "patch", {
      addressFilter: this.addressFilter,
      existingPeer: i
    });
    return re(this, we, Ue).call(this, e, o, n, i);
  }
  async merge(e, r) {
    const { existingBuf: n, existingPeer: i } = await re(this, Ee, Fe).call(this, e), o = await toPeerPB(e, r, "merge", {
      addressFilter: this.addressFilter,
      existingPeer: i
    });
    return re(this, we, Ue).call(this, e, o, n, i);
  }
  async *all(e) {
    const r = new PeerMap();
    for await (const { key: n, value: i } of this.datastore.query(mapQuery(e ?? {}, r))) {
      const o = decodePeer(n, i, r);
      o.id.equals(this.peerId) || (yield o);
    }
  }
}
Ee = new WeakSet(), Fe = async function(e) {
  try {
    const r = await this.datastore.get(peerIdToDatastoreKey(e)), n = bytesToPeer(e, r);
    return {
      existingBuf: r,
      existingPeer: n
    };
  } catch (r) {
    if (r.code !== "ERR_NOT_FOUND")
      throw r;
  }
  return {};
}, we = new WeakSet(), Ue = async function(e, r, n, i) {
  const o = Peer.encode(r);
  return n != null && equals$2(o, n) ? {
    peer: bytesToPeer(e, o),
    previous: i,
    updated: !1
  } : (await this.datastore.put(peerIdToDatastoreKey(e), o), {
    peer: bytesToPeer(e, o),
    previous: i,
    updated: !0
  });
};
const log$r = logger$1("libp2p:peer-store");
var Se, je;
class PersistentPeerStore {
  constructor(e, r = {}) {
    ie(this, Se);
    $(this, "store");
    $(this, "events");
    $(this, "peerId");
    this.events = e.events, this.peerId = e.peerId, this.store = new PersistentStore(e, r);
  }
  async forEach(e, r) {
    log$r.trace("forEach await read lock");
    const n = await this.store.lock.readLock();
    log$r.trace("forEach got read lock");
    try {
      for await (const i of this.store.all(r))
        e(i);
    } finally {
      log$r.trace("forEach release read lock"), n();
    }
  }
  async all(e) {
    log$r.trace("all await read lock");
    const r = await this.store.lock.readLock();
    log$r.trace("all got read lock");
    try {
      return await all$1(this.store.all(e));
    } finally {
      log$r.trace("all release read lock"), r();
    }
  }
  async delete(e) {
    log$r.trace("delete await write lock");
    const r = await this.store.lock.writeLock();
    log$r.trace("delete got write lock");
    try {
      await this.store.delete(e);
    } finally {
      log$r.trace("delete release write lock"), r();
    }
  }
  async has(e) {
    log$r.trace("has await read lock");
    const r = await this.store.lock.readLock();
    log$r.trace("has got read lock");
    try {
      return await this.store.has(e);
    } finally {
      log$r.trace("has release read lock"), r();
    }
  }
  async get(e) {
    log$r.trace("get await read lock");
    const r = await this.store.lock.readLock();
    log$r.trace("get got read lock");
    try {
      return await this.store.load(e);
    } finally {
      log$r.trace("get release read lock"), r();
    }
  }
  async save(e, r) {
    log$r.trace("save await write lock");
    const n = await this.store.lock.writeLock();
    log$r.trace("save got write lock");
    try {
      const i = await this.store.save(e, r);
      return re(this, Se, je).call(this, e, i), i.peer;
    } finally {
      log$r.trace("save release write lock"), n();
    }
  }
  async patch(e, r) {
    log$r.trace("patch await write lock");
    const n = await this.store.lock.writeLock();
    log$r.trace("patch got write lock");
    try {
      const i = await this.store.patch(e, r);
      return re(this, Se, je).call(this, e, i), i.peer;
    } finally {
      log$r.trace("patch release write lock"), n();
    }
  }
  async merge(e, r) {
    log$r.trace("merge await write lock");
    const n = await this.store.lock.writeLock();
    log$r.trace("merge got write lock");
    try {
      const i = await this.store.merge(e, r);
      return re(this, Se, je).call(this, e, i), i.peer;
    } finally {
      log$r.trace("merge release write lock"), n();
    }
  }
  async consumePeerRecord(e, r) {
    const n = await RecordEnvelope.openAndCertify(e, PeerRecord.DOMAIN);
    if ((r == null ? void 0 : r.equals(n.peerId)) === !1)
      return log$r("envelope peer id was not the expected peer id - expected: %p received: %p", r, n.peerId), !1;
    const i = PeerRecord.createFromProtobuf(n.payload);
    let o;
    try {
      o = await this.get(n.peerId);
    } catch (a) {
      if (a.code !== "ERR_NOT_FOUND")
        throw a;
    }
    if ((o == null ? void 0 : o.peerRecordEnvelope) != null) {
      const a = await RecordEnvelope.createFromProtobuf(o.peerRecordEnvelope), c = PeerRecord.createFromProtobuf(a.payload);
      if (c.seqNumber >= i.seqNumber)
        return log$r("sequence number was lower or equal to existing sequence number - stored: %d received: %d", c.seqNumber, i.seqNumber), !1;
    }
    return await this.patch(i.peerId, {
      peerRecordEnvelope: e,
      addresses: i.multiaddrs.map((a) => ({
        isCertified: !0,
        multiaddr: a
      }))
    }), !0;
  }
}
Se = new WeakSet(), je = function(e, r) {
  r.updated && (this.peerId.equals(e) ? this.events.safeDispatchEvent("self:peer:update", { detail: r }) : this.events.safeDispatchEvent("peer:update", { detail: r }));
};
function isAsyncIterable$d(t) {
  return t[Symbol.asyncIterator] != null;
}
function drain(t) {
  if (isAsyncIterable$d(t))
    return (async () => {
      for await (const e of t)
        ;
    })();
  for (const e of t)
    ;
}
function peekable(t) {
  const [e, r] = t[Symbol.asyncIterator] != null ? [t[Symbol.asyncIterator](), Symbol.asyncIterator] : [t[Symbol.iterator](), Symbol.iterator], n = [];
  return {
    peek: () => e.next(),
    push: (i) => {
      n.push(i);
    },
    next: () => n.length > 0 ? {
      done: !1,
      value: n.shift()
    } : e.next(),
    [r]() {
      return this;
    }
  };
}
function isAsyncIterable$c(t) {
  return t[Symbol.asyncIterator] != null;
}
function filter$2(t, e) {
  if (isAsyncIterable$c(t))
    return async function* () {
      for await (const c of t)
        await e(c) && (yield c);
    }();
  const r = peekable(t), { value: n, done: i } = r.next();
  if (i === !0)
    return function* () {
    }();
  const o = e(n);
  if (typeof o.then == "function")
    return async function* () {
      await o && (yield n);
      for await (const c of r)
        await e(c) && (yield c);
    }();
  const a = e;
  return function* () {
    o === !0 && (yield n);
    for (const c of r)
      a(c) && (yield c);
  }();
}
function isAsyncIterable$b(t) {
  return t[Symbol.asyncIterator] != null;
}
function sort(t, e) {
  return isAsyncIterable$b(t) ? async function* () {
    yield* (await all$1(t)).sort(e);
  }() : function* () {
    yield* all$1(t).sort(e);
  }();
}
function isAsyncIterable$a(t) {
  return t[Symbol.asyncIterator] != null;
}
function take$2(t, e) {
  return isAsyncIterable$a(t) ? async function* () {
    let r = 0;
    if (!(e < 1)) {
      for await (const n of t)
        if (yield n, r++, r === e)
          return;
    }
  }() : function* () {
    let r = 0;
    if (!(e < 1)) {
      for (const n of t)
        if (yield n, r++, r === e)
          return;
    }
  }();
}
class BaseDatastore {
  put(e, r, n) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(e, r) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(e, r) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(e, r) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(e, r = {}) {
    for await (const { key: n, value: i } of e)
      await this.put(n, i, r), yield n;
  }
  async *getMany(e, r = {}) {
    for await (const n of e)
      yield {
        key: n,
        value: await this.get(n, r)
      };
  }
  async *deleteMany(e, r = {}) {
    for await (const n of e)
      await this.delete(n, r), yield n;
  }
  batch() {
    let e = [], r = [];
    return {
      put(n, i) {
        e.push({ key: n, value: i });
      },
      delete(n) {
        r.push(n);
      },
      commit: async (n) => {
        await drain(this.putMany(e, n)), e = [], await drain(this.deleteMany(r, n)), r = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(e, r) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(e, r) {
    throw new Error("._allKeys is not implemented");
  }
  query(e, r) {
    let n = this._all(e, r);
    if (e.prefix != null) {
      const i = e.prefix;
      n = filter$2(n, (o) => o.key.toString().startsWith(i));
    }
    if (Array.isArray(e.filters) && (n = e.filters.reduce((i, o) => filter$2(i, o), n)), Array.isArray(e.orders) && (n = e.orders.reduce((i, o) => sort(i, o), n)), e.offset != null) {
      let i = 0;
      const o = e.offset;
      n = filter$2(n, () => i++ >= o);
    }
    return e.limit != null && (n = take$2(n, e.limit)), n;
  }
  queryKeys(e, r) {
    let n = this._allKeys(e, r);
    if (e.prefix != null) {
      const i = e.prefix;
      n = filter$2(n, (o) => o.toString().startsWith(i));
    }
    if (Array.isArray(e.filters) && (n = e.filters.reduce((i, o) => filter$2(i, o), n)), Array.isArray(e.orders) && (n = e.orders.reduce((i, o) => sort(i, o), n)), e.offset != null) {
      const i = e.offset;
      let o = 0;
      n = filter$2(n, () => o++ >= i);
    }
    return e.limit != null && (n = take$2(n, e.limit)), n;
  }
}
function notFoundError(t) {
  return t = t ?? new Error("Not Found"), errCode(t, "ERR_NOT_FOUND");
}
class MemoryDatastore extends BaseDatastore {
  constructor() {
    super();
    $(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(r, n) {
    return this.data.set(r.toString(), n), r;
  }
  get(r) {
    const n = this.data.get(r.toString());
    if (n == null)
      throw notFoundError();
    return n;
  }
  has(r) {
    return this.data.has(r.toString());
  }
  delete(r) {
    this.data.delete(r.toString());
  }
  *_all() {
    for (const [r, n] of this.data.entries())
      yield { key: new Key(r), value: n };
  }
  *_allKeys() {
    for (const r of this.data.keys())
      yield new Key(r);
  }
}
function debounce$2(t, e) {
  let r;
  return function() {
    const n = function() {
      r = void 0, t();
    };
    clearTimeout(r), r = setTimeout(n, e);
  };
}
const log$q = logger$1("libp2p:address-manager"), defaultAddressFilter = (t) => t;
function stripPeerId(t, e) {
  const r = t.getPeerId();
  return r != null && peerIdFromString(r).equals(e) && (t = t.decapsulate(multiaddr$1(`/p2p/${e.toString()}`))), t;
}
class DefaultAddressManager {
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(e, r = {}) {
    $(this, "components");
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    $(this, "listen");
    $(this, "announce");
    $(this, "observed");
    $(this, "announceFilter");
    const { listen: n = [], announce: i = [] } = r;
    this.components = e, this.listen = n.map((o) => o.toString()), this.announce = new Set(i.map((o) => o.toString())), this.observed = /* @__PURE__ */ new Map(), this.announceFilter = r.announceFilter ?? defaultAddressFilter, this._updatePeerStoreAddresses = debounce$2(this._updatePeerStoreAddresses.bind(this), 1e3), e.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    }), e.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  _updatePeerStoreAddresses() {
    const e = this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([r, n]) => n.confident).map(([r]) => multiaddr$1(r))).map((r) => r.getPeerId() === this.components.peerId.toString() ? r.decapsulate(`/p2p/${this.components.peerId.toString()}`) : r);
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: e
    }).catch((r) => {
      log$q.error("error updating addresses", r);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((e) => multiaddr$1(e));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((e) => multiaddr$1(e));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return Array.from(this.observed).map(([e]) => multiaddr$1(e));
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(e) {
    e = stripPeerId(e, this.components.peerId);
    const r = e.toString();
    this.observed.has(r) || this.observed.set(r, {
      confident: !1
    });
  }
  confirmObservedAddr(e) {
    e = stripPeerId(e, this.components.peerId);
    const r = e.toString(), i = (this.observed.get(r) ?? {
      confident: !1
    }).confident;
    this.observed.set(r, {
      confident: !0
    }), i || this._updatePeerStoreAddresses();
  }
  removeObservedAddr(e) {
    e = stripPeerId(e, this.components.peerId);
    const r = e.toString();
    this.observed.delete(r);
  }
  getAddresses() {
    let e = this.getAnnounceAddrs().map((n) => n.toString());
    e.length === 0 && (e = this.components.transportManager.getAddrs().map((n) => n.toString())), e = e.concat(Array.from(this.observed).filter(([n, i]) => i.confident).map(([n]) => n));
    const r = new Set(e);
    return this.announceFilter(Array.from(r).map((n) => multiaddr$1(n))).map((n) => {
      var i;
      return ((i = n.protos().pop()) == null ? void 0 : i.path) === !0 || n.getPeerId() === this.components.peerId.toString() ? n : n.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    });
  }
}
function isStartable(t) {
  return t != null && typeof t.start == "function" && typeof t.stop == "function";
}
class DefaultComponents {
  constructor(e = {}) {
    $(this, "components", {});
    $(this, "_started", !1);
    this.components = {};
    for (const [r, n] of Object.entries(e))
      this.components[r] = n;
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(e) {
    await Promise.all(Object.values(this.components).filter((r) => isStartable(r)).map(async (r) => {
      var n;
      await ((n = r[e]) == null ? void 0 : n.call(r));
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start"), this._started = !0;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop"), this._started = !1;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
}
const OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector"
], NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(t = {}) {
  const e = new DefaultComponents(t);
  return new Proxy(e, {
    get(n, i, o) {
      if (typeof i == "string" && !NON_SERVICE_PROPERTIES.includes(i)) {
        const a = e.components[i];
        if (a == null && !OPTIONAL_SERVICES.includes(i))
          throw new CodeError$2(`${i} not set`, "ERR_SERVICE_MISSING");
        return a;
      }
      return Reflect.get(n, i, o);
    },
    set(n, i, o) {
      return typeof i == "string" ? e.components[i] = o : Reflect.set(n, i, o), !0;
    }
  });
}
function connectionGater(t = {}) {
  return {
    denyDialPeer: async () => !1,
    denyDialMultiaddr: async () => !1,
    denyInboundConnection: async () => !1,
    denyOutboundConnection: async () => !1,
    denyInboundEncryptedConnection: async () => !1,
    denyOutboundEncryptedConnection: async () => !1,
    denyInboundUpgradedConnection: async () => !1,
    denyOutboundUpgradedConnection: async () => !1,
    filterMultiaddrForPeer: async () => !0,
    ...t
  };
}
const symbol$2 = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(t) {
  t[t.FATAL_ALL = 0] = "FATAL_ALL", t[t.NO_FATAL = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));
var Netmask_1;
(function() {
  var t, e, r, n, i, o, a, c;
  c = function(l) {
    var u, f, d, p;
    return u = (l & 255 << 24) >>> 24, f = (l & 255 << 16) >>> 16, d = (l & 255 << 8) >>> 8, p = l & 255, [u, f, d, p].join(".");
  }, a = function(l) {
    var u, f, d, p, g, h;
    for (u = [], d = p = 0; p <= 3 && l.length !== 0; d = ++p) {
      if (d > 0) {
        if (l[0] !== ".")
          throw new Error("Invalid IP");
        l = l.substring(1);
      }
      h = e(l), g = h[0], f = h[1], l = l.substring(f), u.push(g);
    }
    if (l.length !== 0)
      throw new Error("Invalid IP");
    switch (u.length) {
      case 1:
        if (u[0] > 4294967295)
          throw new Error("Invalid IP");
        return u[0] >>> 0;
      case 2:
        if (u[0] > 255 || u[1] > 16777215)
          throw new Error("Invalid IP");
        return (u[0] << 24 | u[1]) >>> 0;
      case 3:
        if (u[0] > 255 || u[1] > 255 || u[2] > 65535)
          throw new Error("Invalid IP");
        return (u[0] << 24 | u[1] << 16 | u[2]) >>> 0;
      case 4:
        if (u[0] > 255 || u[1] > 255 || u[2] > 255 || u[3] > 255)
          throw new Error("Invalid IP");
        return (u[0] << 24 | u[1] << 16 | u[2] << 8 | u[3]) >>> 0;
      default:
        throw new Error("Invalid IP");
    }
  }, r = function(l) {
    return l.charCodeAt(0);
  }, n = r("0"), o = r("a"), i = r("A"), e = function(l) {
    var u, f, d, p, g;
    for (p = 0, u = 10, f = "9", d = 0, l.length > 1 && l[d] === "0" && (l[d + 1] === "x" || l[d + 1] === "X" ? (d += 2, u = 16) : "0" <= l[d + 1] && l[d + 1] <= "9" && (d++, u = 8, f = "7")), g = d; d < l.length; ) {
      if ("0" <= l[d] && l[d] <= f)
        p = p * u + (r(l[d]) - n) >>> 0;
      else if (u === 16)
        if ("a" <= l[d] && l[d] <= "f")
          p = p * u + (10 + r(l[d]) - o) >>> 0;
        else if ("A" <= l[d] && l[d] <= "F")
          p = p * u + (10 + r(l[d]) - i) >>> 0;
        else
          break;
      else
        break;
      if (p > 4294967295)
        throw new Error("too large");
      d++;
    }
    if (d === g)
      throw new Error("empty octet");
    return [p, d];
  }, t = function() {
    function l(u, f) {
      var d, p, g;
      if (typeof u != "string")
        throw new Error("Missing `net' parameter");
      if (f || (g = u.split("/", 2), u = g[0], f = g[1]), f || (f = 32), typeof f == "string" && f.indexOf(".") > -1) {
        try {
          this.maskLong = a(f);
        } catch {
          throw new Error("Invalid mask: " + f);
        }
        for (d = p = 32; p >= 0; d = --p)
          if (this.maskLong === 4294967295 << 32 - d >>> 0) {
            this.bitmask = d;
            break;
          }
      } else if (f || f === 0)
        this.bitmask = parseInt(f, 10), this.maskLong = 0, this.bitmask > 0 && (this.maskLong = 4294967295 << 32 - this.bitmask >>> 0);
      else
        throw new Error("Invalid mask: empty");
      try {
        this.netLong = (a(u) & this.maskLong) >>> 0;
      } catch {
        throw new Error("Invalid net address: " + u);
      }
      if (!(this.bitmask <= 32))
        throw new Error("Invalid mask for ip4: " + f);
      this.size = Math.pow(2, 32 - this.bitmask), this.base = c(this.netLong), this.mask = c(this.maskLong), this.hostmask = c(~this.maskLong), this.first = this.bitmask <= 30 ? c(this.netLong + 1) : this.base, this.last = this.bitmask <= 30 ? c(this.netLong + this.size - 2) : c(this.netLong + this.size - 1), this.broadcast = this.bitmask <= 30 ? c(this.netLong + this.size - 1) : void 0;
    }
    return l.prototype.contains = function(u) {
      return typeof u == "string" && (u.indexOf("/") > 0 || u.split(".").length !== 4) && (u = new l(u)), u instanceof l ? this.contains(u.base) && this.contains(u.broadcast || u.last) : (a(u) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
    }, l.prototype.next = function(u) {
      return u == null && (u = 1), new l(c(this.netLong + this.size * u), this.mask);
    }, l.prototype.forEach = function(u) {
      var f, d, p;
      for (p = a(this.first), d = a(this.last), f = 0; p <= d; )
        u(c(p), p, f), f++, p++;
    }, l.prototype.toString = function() {
      return this.base + "/" + this.bitmask;
    }, l;
  }(), Netmask_1 = t;
}).call(commonjsGlobal);
const word = "[a-fA-F\\d:]", boundry = (t) => t && t.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "", v4$1 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", v6segment = "[a-fA-F\\d]{1,4}", v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4$1}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4$1}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4$1}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4$1}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4$1}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4$1}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4$1}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), v46Exact = new RegExp(`(?:^${v4$1}$)|(?:^${v6}$)`), v4exact = new RegExp(`^${v4$1}$`), v6exact = new RegExp(`^${v6}$`), ipRegex = (t) => t && t.exact ? v46Exact : new RegExp(`(?:${boundry(t)}${v4$1}${boundry(t)})|(?:${boundry(t)}${v6}${boundry(t)})`, "g");
ipRegex.v4 = (t) => t && t.exact ? v4exact : new RegExp(`${boundry(t)}${v4$1}${boundry(t)}`, "g");
ipRegex.v6 = (t) => t && t.exact ? v6exact : new RegExp(`${boundry(t)}${v6}${boundry(t)}`, "g");
var ipaddrExports = {}, ipaddr$1 = {
  get exports() {
    return ipaddrExports;
  },
  set exports(t) {
    ipaddrExports = t;
  }
};
(function(t) {
  (function(e) {
    const r = "(0?\\d+|0x[a-f0-9]+)", n = {
      fourOctet: new RegExp(`^${r}\\.${r}\\.${r}\\.${r}$`, "i"),
      threeOctet: new RegExp(`^${r}\\.${r}\\.${r}$`, "i"),
      twoOctet: new RegExp(`^${r}\\.${r}$`, "i"),
      longValue: new RegExp(`^${r}$`, "i")
    }, i = new RegExp("^0[0-7]+$", "i"), o = new RegExp("^0x[a-f0-9]+$", "i"), a = "%[0-9a-z]{1,}", c = "(?:[0-9a-f]+::?)+", l = {
      zoneIndex: new RegExp(a, "i"),
      native: new RegExp(`^(::)?(${c})?([0-9a-f]+)?(::)?(${a})?$`, "i"),
      deprecatedTransitional: new RegExp(`^(?:::)(${r}\\.${r}\\.${r}\\.${r}(${a})?)$`, "i"),
      transitional: new RegExp(`^((?:${c})|(?:::)(?:${c})?)${r}\\.${r}\\.${r}\\.${r}(${a})?$`, "i")
    };
    function u(h, m) {
      if (h.indexOf("::") !== h.lastIndexOf("::"))
        return null;
      let y = 0, b = -1, v = (h.match(l.zoneIndex) || [])[0], _, E;
      for (v && (v = v.substring(1), h = h.replace(/%.+$/, "")); (b = h.indexOf(":", b + 1)) >= 0; )
        y++;
      if (h.substr(0, 2) === "::" && y--, h.substr(-2, 2) === "::" && y--, y > m)
        return null;
      for (E = m - y, _ = ":"; E--; )
        _ += "0:";
      return h = h.replace("::", _), h[0] === ":" && (h = h.slice(1)), h[h.length - 1] === ":" && (h = h.slice(0, -1)), m = function() {
        const w = h.split(":"), S = [];
        for (let x = 0; x < w.length; x++)
          S.push(parseInt(w[x], 16));
        return S;
      }(), {
        parts: m,
        zoneId: v
      };
    }
    function f(h, m, y, b) {
      if (h.length !== m.length)
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      let v = 0, _;
      for (; b > 0; ) {
        if (_ = y - b, _ < 0 && (_ = 0), h[v] >> _ !== m[v] >> _)
          return !1;
        b -= y, v += 1;
      }
      return !0;
    }
    function d(h) {
      if (o.test(h))
        return parseInt(h, 16);
      if (h[0] === "0" && !isNaN(parseInt(h[1], 10))) {
        if (i.test(h))
          return parseInt(h, 8);
        throw new Error(`ipaddr: cannot parse ${h} as octal`);
      }
      return parseInt(h, 10);
    }
    function p(h, m) {
      for (; h.length < m; )
        h = `0${h}`;
      return h;
    }
    const g = {};
    g.IPv4 = function() {
      function h(m) {
        if (m.length !== 4)
          throw new Error("ipaddr: ipv4 octet count should be 4");
        let y, b;
        for (y = 0; y < m.length; y++)
          if (b = m[y], !(0 <= b && b <= 255))
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        this.octets = m;
      }
      return h.prototype.SpecialRanges = {
        unspecified: [[new h([0, 0, 0, 0]), 8]],
        broadcast: [[new h([255, 255, 255, 255]), 32]],
        // RFC3171
        multicast: [[new h([224, 0, 0, 0]), 4]],
        // RFC3927
        linkLocal: [[new h([169, 254, 0, 0]), 16]],
        // RFC5735
        loopback: [[new h([127, 0, 0, 0]), 8]],
        // RFC6598
        carrierGradeNat: [[new h([100, 64, 0, 0]), 10]],
        // RFC1918
        private: [
          [new h([10, 0, 0, 0]), 8],
          [new h([172, 16, 0, 0]), 12],
          [new h([192, 168, 0, 0]), 16]
        ],
        // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
        reserved: [
          [new h([192, 0, 0, 0]), 24],
          [new h([192, 0, 2, 0]), 24],
          [new h([192, 88, 99, 0]), 24],
          [new h([198, 18, 0, 0]), 15],
          [new h([198, 51, 100, 0]), 24],
          [new h([203, 0, 113, 0]), 24],
          [new h([240, 0, 0, 0]), 4]
        ]
      }, h.prototype.kind = function() {
        return "ipv4";
      }, h.prototype.match = function(m, y) {
        let b;
        if (y === void 0 && (b = m, m = b[0], y = b[1]), m.kind() !== "ipv4")
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        return f(this.octets, m.octets, 8, y);
      }, h.prototype.prefixLengthFromSubnetMask = function() {
        let m = 0, y = !1;
        const b = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        let v, _, E;
        for (v = 3; v >= 0; v -= 1)
          if (_ = this.octets[v], _ in b) {
            if (E = b[_], y && E !== 0)
              return null;
            E !== 8 && (y = !0), m += E;
          } else
            return null;
        return 32 - m;
      }, h.prototype.range = function() {
        return g.subnetMatch(this, this.SpecialRanges);
      }, h.prototype.toByteArray = function() {
        return this.octets.slice(0);
      }, h.prototype.toIPv4MappedAddress = function() {
        return g.IPv6.parse(`::ffff:${this.toString()}`);
      }, h.prototype.toNormalizedString = function() {
        return this.toString();
      }, h.prototype.toString = function() {
        return this.octets.join(".");
      }, h;
    }(), g.IPv4.broadcastAddressFromCIDR = function(h) {
      try {
        const m = this.parseCIDR(h), y = m[0].toByteArray(), b = this.subnetMaskFromPrefixLength(m[1]).toByteArray(), v = [];
        let _ = 0;
        for (; _ < 4; )
          v.push(parseInt(y[_], 10) | parseInt(b[_], 10) ^ 255), _++;
        return new this(v);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    }, g.IPv4.isIPv4 = function(h) {
      return this.parser(h) !== null;
    }, g.IPv4.isValid = function(h) {
      try {
        return new this(this.parser(h)), !0;
      } catch {
        return !1;
      }
    }, g.IPv4.isValidFourPartDecimal = function(h) {
      return !!(g.IPv4.isValid(h) && h.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/));
    }, g.IPv4.networkAddressFromCIDR = function(h) {
      let m, y, b, v, _;
      try {
        for (m = this.parseCIDR(h), b = m[0].toByteArray(), _ = this.subnetMaskFromPrefixLength(m[1]).toByteArray(), v = [], y = 0; y < 4; )
          v.push(parseInt(b[y], 10) & parseInt(_[y], 10)), y++;
        return new this(v);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    }, g.IPv4.parse = function(h) {
      const m = this.parser(h);
      if (m === null)
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      return new this(m);
    }, g.IPv4.parseCIDR = function(h) {
      let m;
      if (m = h.match(/^(.+)\/(\d+)$/)) {
        const y = parseInt(m[2]);
        if (y >= 0 && y <= 32) {
          const b = [this.parse(m[1]), y];
          return Object.defineProperty(b, "toString", {
            value: function() {
              return this.join("/");
            }
          }), b;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    }, g.IPv4.parser = function(h) {
      let m, y, b;
      if (m = h.match(n.fourOctet))
        return function() {
          const v = m.slice(1, 6), _ = [];
          for (let E = 0; E < v.length; E++)
            y = v[E], _.push(d(y));
          return _;
        }();
      if (m = h.match(n.longValue)) {
        if (b = d(m[1]), b > 4294967295 || b < 0)
          throw new Error("ipaddr: address outside defined range");
        return function() {
          const v = [];
          let _;
          for (_ = 0; _ <= 24; _ += 8)
            v.push(b >> _ & 255);
          return v;
        }().reverse();
      } else
        return (m = h.match(n.twoOctet)) ? function() {
          const v = m.slice(1, 4), _ = [];
          if (b = d(v[1]), b > 16777215 || b < 0)
            throw new Error("ipaddr: address outside defined range");
          return _.push(d(v[0])), _.push(b >> 16 & 255), _.push(b >> 8 & 255), _.push(b & 255), _;
        }() : (m = h.match(n.threeOctet)) ? function() {
          const v = m.slice(1, 5), _ = [];
          if (b = d(v[2]), b > 65535 || b < 0)
            throw new Error("ipaddr: address outside defined range");
          return _.push(d(v[0])), _.push(d(v[1])), _.push(b >> 8 & 255), _.push(b & 255), _;
        }() : null;
    }, g.IPv4.subnetMaskFromPrefixLength = function(h) {
      if (h = parseInt(h), h < 0 || h > 32)
        throw new Error("ipaddr: invalid IPv4 prefix length");
      const m = [0, 0, 0, 0];
      let y = 0;
      const b = Math.floor(h / 8);
      for (; y < b; )
        m[y] = 255, y++;
      return b < 4 && (m[b] = Math.pow(2, h % 8) - 1 << 8 - h % 8), new this(m);
    }, g.IPv6 = function() {
      function h(m, y) {
        let b, v;
        if (m.length === 16)
          for (this.parts = [], b = 0; b <= 14; b += 2)
            this.parts.push(m[b] << 8 | m[b + 1]);
        else if (m.length === 8)
          this.parts = m;
        else
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        for (b = 0; b < this.parts.length; b++)
          if (v = this.parts[b], !(0 <= v && v <= 65535))
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        y && (this.zoneId = y);
      }
      return h.prototype.SpecialRanges = {
        // RFC4291, here and after
        unspecified: [new h([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new h([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new h([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new h([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new h([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new h([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        // RFC6145
        rfc6145: [new h([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        // RFC6052
        rfc6052: [new h([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        // RFC3056
        "6to4": [new h([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        // RFC6052, RFC6146
        teredo: [new h([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        // RFC4291
        reserved: [[new h([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]],
        benchmarking: [new h([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
        amt: [new h([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
        as112v6: [new h([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
        deprecated: [new h([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
        orchid2: [new h([8193, 32, 0, 0, 0, 0, 0, 0]), 28]
      }, h.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      }, h.prototype.kind = function() {
        return "ipv6";
      }, h.prototype.match = function(m, y) {
        let b;
        if (y === void 0 && (b = m, m = b[0], y = b[1]), m.kind() !== "ipv6")
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        return f(this.parts, m.parts, 16, y);
      }, h.prototype.prefixLengthFromSubnetMask = function() {
        let m = 0, y = !1;
        const b = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        let v, _;
        for (let E = 7; E >= 0; E -= 1)
          if (v = this.parts[E], v in b) {
            if (_ = b[v], y && _ !== 0)
              return null;
            _ !== 16 && (y = !0), m += _;
          } else
            return null;
        return 128 - m;
      }, h.prototype.range = function() {
        return g.subnetMatch(this, this.SpecialRanges);
      }, h.prototype.toByteArray = function() {
        let m;
        const y = [], b = this.parts;
        for (let v = 0; v < b.length; v++)
          m = b[v], y.push(m >> 8), y.push(m & 255);
        return y;
      }, h.prototype.toFixedLengthString = function() {
        const m = function() {
          const b = [];
          for (let v = 0; v < this.parts.length; v++)
            b.push(p(this.parts[v].toString(16), 4));
          return b;
        }.call(this).join(":");
        let y = "";
        return this.zoneId && (y = `%${this.zoneId}`), m + y;
      }, h.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress())
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        const m = this.parts.slice(-2), y = m[0], b = m[1];
        return new g.IPv4([y >> 8, y & 255, b >> 8, b & 255]);
      }, h.prototype.toNormalizedString = function() {
        const m = function() {
          const b = [];
          for (let v = 0; v < this.parts.length; v++)
            b.push(this.parts[v].toString(16));
          return b;
        }.call(this).join(":");
        let y = "";
        return this.zoneId && (y = `%${this.zoneId}`), m + y;
      }, h.prototype.toRFC5952String = function() {
        const m = /((^|:)(0(:|$)){2,})/g, y = this.toNormalizedString();
        let b = 0, v = -1, _;
        for (; _ = m.exec(y); )
          _[0].length > v && (b = _.index, v = _[0].length);
        return v < 0 ? y : `${y.substring(0, b)}::${y.substring(b + v)}`;
      }, h.prototype.toString = function() {
        return this.toRFC5952String();
      }, h;
    }(), g.IPv6.broadcastAddressFromCIDR = function(h) {
      try {
        const m = this.parseCIDR(h), y = m[0].toByteArray(), b = this.subnetMaskFromPrefixLength(m[1]).toByteArray(), v = [];
        let _ = 0;
        for (; _ < 16; )
          v.push(parseInt(y[_], 10) | parseInt(b[_], 10) ^ 255), _++;
        return new this(v);
      } catch (m) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${m})`);
      }
    }, g.IPv6.isIPv6 = function(h) {
      return this.parser(h) !== null;
    }, g.IPv6.isValid = function(h) {
      if (typeof h == "string" && h.indexOf(":") === -1)
        return !1;
      try {
        const m = this.parser(h);
        return new this(m.parts, m.zoneId), !0;
      } catch {
        return !1;
      }
    }, g.IPv6.networkAddressFromCIDR = function(h) {
      let m, y, b, v, _;
      try {
        for (m = this.parseCIDR(h), b = m[0].toByteArray(), _ = this.subnetMaskFromPrefixLength(m[1]).toByteArray(), v = [], y = 0; y < 16; )
          v.push(parseInt(b[y], 10) & parseInt(_[y], 10)), y++;
        return new this(v);
      } catch (E) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${E})`);
      }
    }, g.IPv6.parse = function(h) {
      const m = this.parser(h);
      if (m.parts === null)
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      return new this(m.parts, m.zoneId);
    }, g.IPv6.parseCIDR = function(h) {
      let m, y, b;
      if ((y = h.match(/^(.+)\/(\d+)$/)) && (m = parseInt(y[2]), m >= 0 && m <= 128))
        return b = [this.parse(y[1]), m], Object.defineProperty(b, "toString", {
          value: function() {
            return this.join("/");
          }
        }), b;
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    }, g.IPv6.parser = function(h) {
      let m, y, b, v, _, E;
      if (b = h.match(l.deprecatedTransitional))
        return this.parser(`::ffff:${b[1]}`);
      if (l.native.test(h))
        return u(h, 8);
      if ((b = h.match(l.transitional)) && (E = b[6] || "", m = u(b[1].slice(0, -1) + E, 6), m.parts)) {
        for (_ = [
          parseInt(b[2]),
          parseInt(b[3]),
          parseInt(b[4]),
          parseInt(b[5])
        ], y = 0; y < _.length; y++)
          if (v = _[y], !(0 <= v && v <= 255))
            return null;
        return m.parts.push(_[0] << 8 | _[1]), m.parts.push(_[2] << 8 | _[3]), {
          parts: m.parts,
          zoneId: m.zoneId
        };
      }
      return null;
    }, g.IPv6.subnetMaskFromPrefixLength = function(h) {
      if (h = parseInt(h), h < 0 || h > 128)
        throw new Error("ipaddr: invalid IPv6 prefix length");
      const m = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let y = 0;
      const b = Math.floor(h / 8);
      for (; y < b; )
        m[y] = 255, y++;
      return b < 16 && (m[b] = Math.pow(2, h % 8) - 1 << 8 - h % 8), new this(m);
    }, g.fromByteArray = function(h) {
      const m = h.length;
      if (m === 4)
        return new g.IPv4(h);
      if (m === 16)
        return new g.IPv6(h);
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }, g.isValid = function(h) {
      return g.IPv6.isValid(h) || g.IPv4.isValid(h);
    }, g.parse = function(h) {
      if (g.IPv6.isValid(h))
        return g.IPv6.parse(h);
      if (g.IPv4.isValid(h))
        return g.IPv4.parse(h);
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }, g.parseCIDR = function(h) {
      try {
        return g.IPv6.parseCIDR(h);
      } catch {
        try {
          return g.IPv4.parseCIDR(h);
        } catch {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    }, g.process = function(h) {
      const m = this.parse(h);
      return m.kind() === "ipv6" && m.isIPv4MappedAddress() ? m.toIPv4Address() : m;
    }, g.subnetMatch = function(h, m, y) {
      let b, v, _, E;
      y == null && (y = "unicast");
      for (v in m)
        if (Object.prototype.hasOwnProperty.call(m, v)) {
          for (_ = m[v], _[0] && !(_[0] instanceof Array) && (_ = [_]), b = 0; b < _.length; b++)
            if (E = _[b], h.kind() === E[0].kind() && h.match.apply(h, E))
              return v;
        }
      return y;
    }, t.exports ? t.exports = g : e.ipaddr = g;
  })(commonjsGlobal);
})(ipaddr$1);
const ipaddr = ipaddrExports, { isValid: is_valid, parse: parse$3 } = ipaddr, PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
], NETMASK_RANGES = PRIVATE_IP_RANGES.map((t) => new Netmask_1(t));
function ipv4_check(t) {
  for (let e of NETMASK_RANGES)
    if (e.contains(t))
      return !0;
  return !1;
}
function ipv6_check(t) {
  return /^::$/.test(t) || /^::1$/.test(t) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(t) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(t) || /^ff([0-9a-fA-F]{2,2}):/i.test(t);
}
const is_ip_private = (t) => {
  if (is_valid(t)) {
    const e = parse$3(t);
    if (e.kind() === "ipv4")
      return ipv4_check(e.toNormalizedString());
    if (e.kind() === "ipv6")
      return ipv6_check(t);
  } else if (isIP(t) && ipRegex.v6().test(t))
    return ipv6_check(t);
};
function isPrivate(t) {
  try {
    const { address: e } = t.nodeAddress();
    return Boolean(is_ip_private(e));
  } catch {
    return !0;
  }
}
function publicAddressesFirst(t, e) {
  const r = isPrivate(t.multiaddr), n = isPrivate(e.multiaddr);
  return r && !n ? 1 : !r && n || t.isCertified && !e.isCertified ? -1 : !t.isCertified && e.isCertified ? 1 : 0;
}
const { code: dnsaddrCode } = getProtocol$1("dnsaddr");
async function dnsaddrResolver(t, e = {}) {
  const r = new Resolver();
  e.signal != null && e.signal.addEventListener("abort", () => {
    r.cancel();
  });
  const n = t.getPeerId(), [, i] = t.stringTuples().find(([c]) => c === dnsaddrCode) ?? [];
  if (i == null)
    throw new Error("No hostname found in multiaddr");
  let a = (await r.resolveTxt(`_dnsaddr.${i}`)).flat().map((c) => c.split("=")[1]).filter(Boolean);
  return n != null && (a = a.filter((c) => c.includes(n))), a;
}
var messages;
(function(t) {
  t.NOT_STARTED_YET = "The libp2p node is not started yet", t.DHT_DISABLED = "DHT is not available", t.PUBSUB_DISABLED = "PubSub is not available", t.CONN_ENCRYPTION_REQUIRED = "At least one connection encryption module is required", t.ERR_TRANSPORTS_REQUIRED = "At least one transport module is required", t.ERR_PROTECTOR_REQUIRED = "Private network is enforced, but no protector was provided", t.NOT_FOUND = "Not found";
})(messages || (messages = {}));
var codes$1;
(function(t) {
  t.DHT_DISABLED = "ERR_DHT_DISABLED", t.ERR_PUBSUB_DISABLED = "ERR_PUBSUB_DISABLED", t.PUBSUB_NOT_STARTED = "ERR_PUBSUB_NOT_STARTED", t.DHT_NOT_STARTED = "ERR_DHT_NOT_STARTED", t.CONN_ENCRYPTION_REQUIRED = "ERR_CONN_ENCRYPTION_REQUIRED", t.ERR_TRANSPORTS_REQUIRED = "ERR_TRANSPORTS_REQUIRED", t.ERR_PROTECTOR_REQUIRED = "ERR_PROTECTOR_REQUIRED", t.ERR_PEER_DIAL_INTERCEPTED = "ERR_PEER_DIAL_INTERCEPTED", t.ERR_CONNECTION_INTERCEPTED = "ERR_CONNECTION_INTERCEPTED", t.ERR_INVALID_PROTOCOLS_FOR_STREAM = "ERR_INVALID_PROTOCOLS_FOR_STREAM", t.ERR_CONNECTION_ENDED = "ERR_CONNECTION_ENDED", t.ERR_CONNECTION_FAILED = "ERR_CONNECTION_FAILED", t.ERR_NODE_NOT_STARTED = "ERR_NODE_NOT_STARTED", t.ERR_ALREADY_ABORTED = "ERR_ALREADY_ABORTED", t.ERR_TOO_MANY_ADDRESSES = "ERR_TOO_MANY_ADDRESSES", t.ERR_NO_VALID_ADDRESSES = "ERR_NO_VALID_ADDRESSES", t.ERR_RELAYED_DIAL = "ERR_RELAYED_DIAL", t.ERR_DIALED_SELF = "ERR_DIALED_SELF", t.ERR_DISCOVERED_SELF = "ERR_DISCOVERED_SELF", t.ERR_DUPLICATE_TRANSPORT = "ERR_DUPLICATE_TRANSPORT", t.ERR_ENCRYPTION_FAILED = "ERR_ENCRYPTION_FAILED", t.ERR_HOP_REQUEST_FAILED = "ERR_HOP_REQUEST_FAILED", t.ERR_INVALID_KEY = "ERR_INVALID_KEY", t.ERR_INVALID_MESSAGE = "ERR_INVALID_MESSAGE", t.ERR_INVALID_PARAMETERS = "ERR_INVALID_PARAMETERS", t.ERR_INVALID_PEER = "ERR_INVALID_PEER", t.ERR_MUXER_UNAVAILABLE = "ERR_MUXER_UNAVAILABLE", t.ERR_NOT_FOUND = "ERR_NOT_FOUND", t.ERR_TIMEOUT = "ERR_TIMEOUT", t.ERR_TRANSPORT_UNAVAILABLE = "ERR_TRANSPORT_UNAVAILABLE", t.ERR_TRANSPORT_DIAL_FAILED = "ERR_TRANSPORT_DIAL_FAILED", t.ERR_UNSUPPORTED_PROTOCOL = "ERR_UNSUPPORTED_PROTOCOL", t.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED", t.ERR_INVALID_MULTIADDR = "ERR_INVALID_MULTIADDR", t.ERR_SIGNATURE_NOT_VALID = "ERR_SIGNATURE_NOT_VALID", t.ERR_FIND_SELF = "ERR_FIND_SELF", t.ERR_NO_ROUTERS_AVAILABLE = "ERR_NO_ROUTERS_AVAILABLE", t.ERR_CONNECTION_NOT_MULTIPLEXED = "ERR_CONNECTION_NOT_MULTIPLEXED", t.ERR_NO_DIAL_TOKENS = "ERR_NO_DIAL_TOKENS", t.ERR_KEYCHAIN_REQUIRED = "ERR_KEYCHAIN_REQUIRED", t.ERR_INVALID_CMS = "ERR_INVALID_CMS", t.ERR_MISSING_KEYS = "ERR_MISSING_KEYS", t.ERR_NO_KEY = "ERR_NO_KEY", t.ERR_INVALID_KEY_NAME = "ERR_INVALID_KEY_NAME", t.ERR_INVALID_KEY_TYPE = "ERR_INVALID_KEY_TYPE", t.ERR_KEY_ALREADY_EXISTS = "ERR_KEY_ALREADY_EXISTS", t.ERR_INVALID_KEY_SIZE = "ERR_INVALID_KEY_SIZE", t.ERR_KEY_NOT_FOUND = "ERR_KEY_NOT_FOUND", t.ERR_OLD_KEY_NAME_INVALID = "ERR_OLD_KEY_NAME_INVALID", t.ERR_NEW_KEY_NAME_INVALID = "ERR_NEW_KEY_NAME_INVALID", t.ERR_PASSWORD_REQUIRED = "ERR_PASSWORD_REQUIRED", t.ERR_PEM_REQUIRED = "ERR_PEM_REQUIRED", t.ERR_CANNOT_READ_KEY = "ERR_CANNOT_READ_KEY", t.ERR_MISSING_PRIVATE_KEY = "ERR_MISSING_PRIVATE_KEY", t.ERR_MISSING_PUBLIC_KEY = "ERR_MISSING_PUBLIC_KEY", t.ERR_INVALID_OLD_PASS_TYPE = "ERR_INVALID_OLD_PASS_TYPE", t.ERR_INVALID_NEW_PASS_TYPE = "ERR_INVALID_NEW_PASS_TYPE", t.ERR_INVALID_PASS_LENGTH = "ERR_INVALID_PASS_LENGTH", t.ERR_NOT_IMPLEMENTED = "ERR_NOT_IMPLEMENTED", t.ERR_WRONG_PING_ACK = "ERR_WRONG_PING_ACK", t.ERR_INVALID_RECORD = "ERR_INVALID_RECORD", t.ERR_ALREADY_SUCCEEDED = "ERR_ALREADY_SUCCEEDED", t.ERR_NO_HANDLER_FOR_PROTOCOL = "ERR_NO_HANDLER_FOR_PROTOCOL", t.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS", t.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS", t.ERR_CONNECTION_DENIED = "ERR_CONNECTION_DENIED", t.ERR_TRANSFER_LIMIT_EXCEEDED = "ERR_TRANSFER_LIMIT_EXCEEDED";
})(codes$1 || (codes$1 = {}));
const DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (t) => t
  },
  connectionManager: {
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: publicAddressesFirst
  },
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  }
};
function validateConfig(t) {
  var r, n;
  const e = mergeOptions(DefaultConfig, t);
  if (e.transports == null || e.transports.length < 1)
    throw new CodeError$2(messages.ERR_TRANSPORTS_REQUIRED, codes$1.ERR_TRANSPORTS_REQUIRED);
  if (e.connectionProtector === null && ((n = (r = globalThis.process) == null ? void 0 : r.env) == null ? void 0 : n.LIBP2P_FORCE_PNET) != null)
    throw new CodeError$2(messages.ERR_PROTECTOR_REQUIRED, codes$1.ERR_PROTECTOR_REQUIRED);
  return e;
}
const KEEP_ALIVE = "keep-alive";
var RateLimiterAbstract_1 = class {
  /**
   *
   * @param opts Object Defaults {
   *   points: 4, // Number of points
   *   duration: 1, // Per seconds
   *   blockDuration: 0, // Block if consumed more than points in current duration for blockDuration seconds
   *   execEvenly: false, // Execute allowed actions evenly over duration
   *   execEvenlyMinDelayMs: duration * 1000 / points, // ms, works with execEvenly=true option
   *   keyPrefix: 'rlflx',
   * }
   */
  constructor(e = {}) {
    this.points = e.points, this.duration = e.duration, this.blockDuration = e.blockDuration, this.execEvenly = e.execEvenly, this.execEvenlyMinDelayMs = e.execEvenlyMinDelayMs, this.keyPrefix = e.keyPrefix;
  }
  get points() {
    return this._points;
  }
  set points(e) {
    this._points = e >= 0 ? e : 4;
  }
  get duration() {
    return this._duration;
  }
  set duration(e) {
    this._duration = typeof e > "u" ? 1 : e;
  }
  get msDuration() {
    return this.duration * 1e3;
  }
  get blockDuration() {
    return this._blockDuration;
  }
  set blockDuration(e) {
    this._blockDuration = typeof e > "u" ? 0 : e;
  }
  get msBlockDuration() {
    return this.blockDuration * 1e3;
  }
  get execEvenly() {
    return this._execEvenly;
  }
  set execEvenly(e) {
    this._execEvenly = typeof e > "u" ? !1 : Boolean(e);
  }
  get execEvenlyMinDelayMs() {
    return this._execEvenlyMinDelayMs;
  }
  set execEvenlyMinDelayMs(e) {
    this._execEvenlyMinDelayMs = typeof e > "u" ? Math.ceil(this.msDuration / this.points) : e;
  }
  get keyPrefix() {
    return this._keyPrefix;
  }
  set keyPrefix(e) {
    if (typeof e > "u" && (e = "rlflx"), typeof e != "string")
      throw new Error("keyPrefix must be string");
    this._keyPrefix = e;
  }
  _getKeySecDuration(e = {}) {
    return e && e.customDuration >= 0 ? e.customDuration : this.duration;
  }
  getKey(e) {
    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${e}` : e;
  }
  parseKey(e) {
    return e.substring(this.keyPrefix.length);
  }
  consume() {
    throw new Error("You have to implement the method 'consume'!");
  }
  penalty() {
    throw new Error("You have to implement the method 'penalty'!");
  }
  reward() {
    throw new Error("You have to implement the method 'reward'!");
  }
  get() {
    throw new Error("You have to implement the method 'get'!");
  }
  set() {
    throw new Error("You have to implement the method 'set'!");
  }
  block() {
    throw new Error("You have to implement the method 'block'!");
  }
  delete() {
    throw new Error("You have to implement the method 'delete'!");
  }
}, BlockedKeys_1$1 = class {
  constructor() {
    this._keys = {}, this._addedKeysAmount = 0;
  }
  collectExpired() {
    const e = Date.now();
    Object.keys(this._keys).forEach((r) => {
      this._keys[r] <= e && delete this._keys[r];
    }), this._addedKeysAmount = Object.keys(this._keys).length;
  }
  /**
   * Add new blocked key
   *
   * @param key String
   * @param sec Number
   */
  add(e, r) {
    this.addMs(e, r * 1e3);
  }
  /**
   * Add new blocked key for ms
   *
   * @param key String
   * @param ms Number
   */
  addMs(e, r) {
    this._keys[e] = Date.now() + r, this._addedKeysAmount++, this._addedKeysAmount > 999 && this.collectExpired();
  }
  /**
   * 0 means not blocked
   *
   * @param key
   * @returns {number}
   */
  msBeforeExpire(e) {
    const r = this._keys[e];
    if (r && r >= Date.now()) {
      this.collectExpired();
      const n = Date.now();
      return r >= n ? r - n : 0;
    }
    return 0;
  }
  /**
   * If key is not given, delete all data in memory
   * 
   * @param {string|undefined} key
   */
  delete(e) {
    e ? delete this._keys[e] : Object.keys(this._keys).forEach((r) => {
      delete this._keys[r];
    });
  }
};
const BlockedKeys$1 = BlockedKeys_1$1;
var BlockedKeys_1 = BlockedKeys$1, RateLimiterRes_1 = class {
  constructor(e, r, n, i) {
    this.remainingPoints = typeof e > "u" ? 0 : e, this.msBeforeNext = typeof r > "u" ? 0 : r, this.consumedPoints = typeof n > "u" ? 0 : n, this.isFirstInDuration = typeof i > "u" ? !1 : i;
  }
  get msBeforeNext() {
    return this._msBeforeNext;
  }
  set msBeforeNext(e) {
    return this._msBeforeNext = e, this;
  }
  get remainingPoints() {
    return this._remainingPoints;
  }
  set remainingPoints(e) {
    return this._remainingPoints = e, this;
  }
  get consumedPoints() {
    return this._consumedPoints;
  }
  set consumedPoints(e) {
    return this._consumedPoints = e, this;
  }
  get isFirstInDuration() {
    return this._isFirstInDuration;
  }
  set isFirstInDuration(e) {
    this._isFirstInDuration = Boolean(e);
  }
  _getDecoratedProperties() {
    return {
      remainingPoints: this.remainingPoints,
      msBeforeNext: this.msBeforeNext,
      consumedPoints: this.consumedPoints,
      isFirstInDuration: this.isFirstInDuration
    };
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this._getDecoratedProperties();
  }
  toString() {
    return JSON.stringify(this._getDecoratedProperties());
  }
  toJSON() {
    return this._getDecoratedProperties();
  }
};
const RateLimiterAbstract$3 = RateLimiterAbstract_1, BlockedKeys = BlockedKeys_1, RateLimiterRes$b = RateLimiterRes_1;
var RateLimiterStoreAbstract_1 = class extends RateLimiterAbstract$3 {
  /**
   *
   * @param opts Object Defaults {
   *   ... see other in RateLimiterAbstract
   *
   *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked
   *   inMemoryBlockDuration: 10, // Block duration in seconds
   *   insuranceLimiter: RateLimiterAbstract
   * }
   */
  constructor(e = {}) {
    super(e), this.inMemoryBlockOnConsumed = e.inMemoryBlockOnConsumed || e.inmemoryBlockOnConsumed, this.inMemoryBlockDuration = e.inMemoryBlockDuration || e.inmemoryBlockDuration, this.insuranceLimiter = e.insuranceLimiter, this._inMemoryBlockedKeys = new BlockedKeys();
  }
  get client() {
    return this._client;
  }
  set client(e) {
    if (typeof e > "u")
      throw new Error("storeClient is not set");
    this._client = e;
  }
  /**
   * Have to be launched after consume
   * It blocks key and execute evenly depending on result from store
   *
   * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result
   *
   * @param resolve
   * @param reject
   * @param rlKey
   * @param changedPoints
   * @param storeResult
   * @param {Object} options
   * @private
   */
  _afterConsume(e, r, n, i, o, a = {}) {
    const c = this._getRateLimiterRes(n, i, o);
    if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && c.consumedPoints >= this.inMemoryBlockOnConsumed)
      return this._inMemoryBlockedKeys.addMs(n, c.msBeforeNext), c.consumedPoints > this.points ? r(c) : e(c);
    if (c.consumedPoints > this.points) {
      let l = Promise.resolve();
      this.blockDuration > 0 && c.consumedPoints <= this.points + i && (c.msBeforeNext = this.msBlockDuration, l = this._block(n, c.consumedPoints, this.msBlockDuration, a)), this.inMemoryBlockOnConsumed > 0 && c.consumedPoints >= this.inMemoryBlockOnConsumed && (this._inMemoryBlockedKeys.add(n, this.inMemoryBlockDuration), c.msBeforeNext = this.msInMemoryBlockDuration), l.then(() => {
        r(c);
      }).catch((u) => {
        r(u);
      });
    } else if (this.execEvenly && c.msBeforeNext > 0 && !c.isFirstInDuration) {
      let l = Math.ceil(c.msBeforeNext / (c.remainingPoints + 2));
      l < this.execEvenlyMinDelayMs && (l = c.consumedPoints * this.execEvenlyMinDelayMs), setTimeout(e, l, c);
    } else
      e(c);
  }
  _handleError(e, r, n, i, o, a = !1, c = {}) {
    this.insuranceLimiter instanceof RateLimiterAbstract$3 ? this.insuranceLimiter[r](o, a, c).then((l) => {
      n(l);
    }).catch((l) => {
      i(l);
    }) : i(e);
  }
  /**
   * @deprecated Use camelCase version
   * @returns {BlockedKeys}
   * @private
   */
  get _inmemoryBlockedKeys() {
    return this._inMemoryBlockedKeys;
  }
  /**
   * @deprecated Use camelCase version
   * @param rlKey
   * @returns {number}
   */
  getInmemoryBlockMsBeforeExpire(e) {
    return this.getInMemoryBlockMsBeforeExpire(e);
  }
  /**
   * @deprecated Use camelCase version
   * @returns {number|number}
   */
  get inmemoryBlockOnConsumed() {
    return this.inMemoryBlockOnConsumed;
  }
  /**
   * @deprecated Use camelCase version
   * @param value
   */
  set inmemoryBlockOnConsumed(e) {
    this.inMemoryBlockOnConsumed = e;
  }
  /**
   * @deprecated Use camelCase version
   * @returns {number|number}
   */
  get inmemoryBlockDuration() {
    return this.inMemoryBlockDuration;
  }
  /**
   * @deprecated Use camelCase version
   * @param value
   */
  set inmemoryBlockDuration(e) {
    this.inMemoryBlockDuration = e;
  }
  /**
   * @deprecated Use camelCase version
   * @returns {number}
   */
  get msInmemoryBlockDuration() {
    return this.inMemoryBlockDuration * 1e3;
  }
  getInMemoryBlockMsBeforeExpire(e) {
    return this.inMemoryBlockOnConsumed > 0 ? this._inMemoryBlockedKeys.msBeforeExpire(e) : 0;
  }
  get inMemoryBlockOnConsumed() {
    return this._inMemoryBlockOnConsumed;
  }
  set inMemoryBlockOnConsumed(e) {
    if (this._inMemoryBlockOnConsumed = e ? parseInt(e) : 0, this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed)
      throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option');
  }
  get inMemoryBlockDuration() {
    return this._inMemoryBlockDuration;
  }
  set inMemoryBlockDuration(e) {
    if (this._inMemoryBlockDuration = e ? parseInt(e) : 0, this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0)
      throw new Error("inMemoryBlockOnConsumed option must be set up");
  }
  get msInMemoryBlockDuration() {
    return this._inMemoryBlockDuration * 1e3;
  }
  get insuranceLimiter() {
    return this._insuranceLimiter;
  }
  set insuranceLimiter(e) {
    if (typeof e < "u" && !(e instanceof RateLimiterAbstract$3))
      throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");
    this._insuranceLimiter = e, this._insuranceLimiter && (this._insuranceLimiter.blockDuration = this.blockDuration, this._insuranceLimiter.execEvenly = this.execEvenly);
  }
  /**
   * Block any key for secDuration seconds
   *
   * @param key
   * @param secDuration
   * @param {Object} options
   *
   * @return Promise<RateLimiterRes>
   */
  block(e, r, n = {}) {
    const i = r * 1e3;
    return this._block(this.getKey(e), this.points + 1, i, n);
  }
  /**
   * Set points by key for any duration
   *
   * @param key
   * @param points
   * @param secDuration
   * @param {Object} options
   *
   * @return Promise<RateLimiterRes>
   */
  set(e, r, n, i = {}) {
    const o = (n >= 0 ? n : this.duration) * 1e3;
    return this._block(this.getKey(e), r, o, i);
  }
  /**
   *
   * @param key
   * @param pointsToConsume
   * @param {Object} options
   * @returns Promise<RateLimiterRes>
   */
  consume(e, r = 1, n = {}) {
    return new Promise((i, o) => {
      const a = this.getKey(e), c = this.getInMemoryBlockMsBeforeExpire(a);
      if (c > 0)
        return o(new RateLimiterRes$b(0, c));
      this._upsert(a, r, this._getKeySecDuration(n) * 1e3, !1, n).then((l) => {
        this._afterConsume(i, o, a, r, l);
      }).catch((l) => {
        this._handleError(l, "consume", i, o, e, r, n);
      });
    });
  }
  /**
   *
   * @param key
   * @param points
   * @param {Object} options
   * @returns Promise<RateLimiterRes>
   */
  penalty(e, r = 1, n = {}) {
    const i = this.getKey(e);
    return new Promise((o, a) => {
      this._upsert(i, r, this._getKeySecDuration(n) * 1e3, !1, n).then((c) => {
        o(this._getRateLimiterRes(i, r, c));
      }).catch((c) => {
        this._handleError(c, "penalty", o, a, e, r, n);
      });
    });
  }
  /**
   *
   * @param key
   * @param points
   * @param {Object} options
   * @returns Promise<RateLimiterRes>
   */
  reward(e, r = 1, n = {}) {
    const i = this.getKey(e);
    return new Promise((o, a) => {
      this._upsert(i, -r, this._getKeySecDuration(n) * 1e3, !1, n).then((c) => {
        o(this._getRateLimiterRes(i, -r, c));
      }).catch((c) => {
        this._handleError(c, "reward", o, a, e, r, n);
      });
    });
  }
  /**
   *
   * @param key
   * @param {Object} options
   * @returns Promise<RateLimiterRes>|null
   */
  get(e, r = {}) {
    const n = this.getKey(e);
    return new Promise((i, o) => {
      this._get(n, r).then((a) => {
        i(a === null || typeof a > "u" ? null : this._getRateLimiterRes(n, 0, a));
      }).catch((a) => {
        this._handleError(a, "get", i, o, e, r);
      });
    });
  }
  /**
   *
   * @param key
   * @param {Object} options
   * @returns Promise<boolean>
   */
  delete(e, r = {}) {
    const n = this.getKey(e);
    return new Promise((i, o) => {
      this._delete(n, r).then((a) => {
        this._inMemoryBlockedKeys.delete(n), i(a);
      }).catch((a) => {
        this._handleError(a, "delete", i, o, e, r);
      });
    });
  }
  /**
   * Cleanup keys no-matter expired or not.
   */
  deleteInMemoryBlockedAll() {
    this._inMemoryBlockedKeys.delete();
  }
  /**
   * Get RateLimiterRes object filled depending on storeResult, which specific for exact store
   *
   * @param rlKey
   * @param changedPoints
   * @param storeResult
   * @private
   */
  _getRateLimiterRes(e, r, n) {
    throw new Error("You have to implement the method '_getRateLimiterRes'!");
  }
  /**
   * Block key for this.msBlockDuration milliseconds
   * Usually, it just prolongs lifetime of key
   *
   * @param rlKey
   * @param initPoints
   * @param msDuration
   * @param {Object} options
   *
   * @return Promise<any>
   */
  _block(e, r, n, i = {}) {
    return new Promise((o, a) => {
      this._upsert(e, r, n, !0, i).then(() => {
        o(new RateLimiterRes$b(0, n > 0 ? n : -1, r));
      }).catch((c) => {
        this._handleError(c, "block", o, a, this.parseKey(e), n / 1e3, i);
      });
    });
  }
  /**
   * Have to be implemented in every limiter
   * Resolve with raw result from Store OR null if rlKey is not set
   * or Reject with error
   *
   * @param rlKey
   * @param {Object} options
   * @private
   *
   * @return Promise<any>
   */
  _get(e, r = {}) {
    throw new Error("You have to implement the method '_get'!");
  }
  /**
   * Have to be implemented
   * Resolve with true OR false if rlKey doesn't exist
   * or Reject with error
   *
   * @param rlKey
   * @param {Object} options
   * @private
   *
   * @return Promise<any>
   */
  _delete(e, r = {}) {
    throw new Error("You have to implement the method '_delete'!");
  }
  /**
   * Have to be implemented
   * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}
   *
   * @param {string} rlKey
   * @param {number} points
   * @param {number} msDuration
   * @param {boolean} forceExpire
   * @param {Object} options
   * @abstract
   *
   * @return Promise<Object>
   */
  _upsert(e, r, n, i = !1, o = {}) {
    throw new Error("You have to implement the method '_upsert'!");
  }
};
const RateLimiterStoreAbstract$4 = RateLimiterStoreAbstract_1, RateLimiterRes$a = RateLimiterRes_1, incrTtlLuaScript = "redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} ";
let RateLimiterRedis$1 = class extends RateLimiterStoreAbstract$4 {
  /**
   *
   * @param {Object} opts
   * Defaults {
   *   ... see other in RateLimiterStoreAbstract
   *
   *   redis: RedisClient
   *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not "ready"
   * }
   */
  constructor(e) {
    super(e), e.redis ? this.client = e.redis : this.client = e.storeClient, this._rejectIfRedisNotReady = !!e.rejectIfRedisNotReady, typeof this.client.defineCommand == "function" && this.client.defineCommand("rlflxIncr", {
      numberOfKeys: 1,
      lua: incrTtlLuaScript
    });
  }
  /**
   * Prevent actual redis call if redis connection is not ready
   * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.
   * For any other clients all the requests would be passed directly to redis client
   * @return {boolean}
   * @private
   */
  _isRedisReady() {
    return this._rejectIfRedisNotReady ? !(this.client.status && this.client.status !== "ready" || typeof this.client.isReady == "function" && !this.client.isReady()) : !0;
  }
  _getRateLimiterRes(e, r, n) {
    let [i, o] = n;
    Array.isArray(i) && ([, i] = i, [, o] = o);
    const a = new RateLimiterRes$a();
    return a.consumedPoints = parseInt(i), a.isFirstInDuration = a.consumedPoints === r, a.remainingPoints = Math.max(this.points - a.consumedPoints, 0), a.msBeforeNext = o, a;
  }
  _upsert(e, r, n, i = !1) {
    return new Promise((o, a) => {
      if (!this._isRedisReady())
        return a(new Error("Redis connection is not ready"));
      const c = Math.floor(n / 1e3), l = this.client.multi();
      if (i)
        c > 0 ? l.set(e, r, "EX", c) : l.set(e, r), l.pttl(e).exec((u, f) => u ? a(u) : o(f));
      else if (c > 0) {
        const u = function(f, d) {
          return f ? a(f) : o(d);
        };
        typeof this.client.rlflxIncr == "function" ? this.client.rlflxIncr(e, r, c, u) : this.client.eval(incrTtlLuaScript, 1, e, r, c, u);
      } else
        l.incrby(e, r).pttl(e).exec((u, f) => u ? a(u) : o(f));
    });
  }
  _get(e) {
    return new Promise((r, n) => {
      if (!this._isRedisReady())
        return n(new Error("Redis connection is not ready"));
      this.client.multi().get(e).pttl(e).exec((i, o) => {
        if (i)
          n(i);
        else {
          const [a] = o;
          if (a === null)
            return r(null);
          r(o);
        }
      });
    });
  }
  _delete(e) {
    return new Promise((r, n) => {
      this.client.del(e, (i, o) => {
        i ? n(i) : r(o > 0);
      });
    });
  }
};
var RateLimiterRedis_1 = RateLimiterRedis$1;
const RateLimiterStoreAbstract$3 = RateLimiterStoreAbstract_1, RateLimiterRes$9 = RateLimiterRes_1;
function getDriverVersion(t) {
  try {
    const e = t.client ? t.client : t, { version: r } = e.topology.s.options.metadata.driver, n = r.split(".").map((i) => parseInt(i));
    return {
      major: n[0],
      feature: n[1],
      patch: n[2]
    };
  } catch {
    return { major: 0, feature: 0, patch: 0 };
  }
}
let RateLimiterMongo$1 = class ct extends RateLimiterStoreAbstract$3 {
  /**
   *
   * @param {Object} opts
   * Defaults {
   *   indexKeyPrefix: {attr1: 1, attr2: 1}
   *   ... see other in RateLimiterStoreAbstract
   *
   *   mongo: MongoClient
   * }
   */
  constructor(e) {
    super(e), this.dbName = e.dbName, this.tableName = e.tableName, this.indexKeyPrefix = e.indexKeyPrefix, e.mongo ? this.client = e.mongo : this.client = e.storeClient, typeof this.client.then == "function" ? this.client.then((r) => {
      this.client = r, this._initCollection(), this._driverVersion = getDriverVersion(this.client);
    }) : (this._initCollection(), this._driverVersion = getDriverVersion(this.client));
  }
  get dbName() {
    return this._dbName;
  }
  set dbName(e) {
    this._dbName = typeof e > "u" ? ct.getDbName() : e;
  }
  static getDbName() {
    return "node-rate-limiter-flexible";
  }
  get tableName() {
    return this._tableName;
  }
  set tableName(e) {
    this._tableName = typeof e > "u" ? this.keyPrefix : e;
  }
  get client() {
    return this._client;
  }
  set client(e) {
    if (typeof e > "u")
      throw new Error("mongo is not set");
    this._client = e;
  }
  get indexKeyPrefix() {
    return this._indexKeyPrefix;
  }
  set indexKeyPrefix(e) {
    this._indexKeyPrefix = e || {};
  }
  _initCollection() {
    const r = (typeof this.client.db == "function" ? this.client.db(this.dbName) : this.client).collection(this.tableName);
    r.createIndex({ expire: -1 }, { expireAfterSeconds: 0 }), r.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: !0 }), this._collection = r;
  }
  _getRateLimiterRes(e, r, n) {
    const i = new RateLimiterRes$9();
    let o;
    return typeof n.value > "u" ? o = n : o = n.value, i.isFirstInDuration = o.points === r, i.consumedPoints = o.points, i.remainingPoints = Math.max(this.points - i.consumedPoints, 0), i.msBeforeNext = o.expire !== null ? Math.max(new Date(o.expire).getTime() - Date.now(), 0) : -1, i;
  }
  _upsert(e, r, n, i = !1, o = {}) {
    if (!this._collection)
      return Promise.reject(Error("Mongo connection is not established"));
    const a = o.attrs || {};
    let c, l;
    i ? (c = { key: e }, c = Object.assign(c, a), l = {
      $set: {
        key: e,
        points: r,
        expire: n > 0 ? new Date(Date.now() + n) : null
      }
    }, l.$set = Object.assign(l.$set, a)) : (c = {
      $or: [
        { expire: { $gt: new Date() } },
        { expire: { $eq: null } }
      ],
      key: e
    }, c = Object.assign(c, a), l = {
      $setOnInsert: {
        key: e,
        expire: n > 0 ? new Date(Date.now() + n) : null
      },
      $inc: { points: r }
    }, l.$setOnInsert = Object.assign(l.$setOnInsert, a));
    const u = {
      upsert: !0
    };
    return this._driverVersion.major >= 4 || this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7 ? u.returnDocument = "after" : u.returnOriginal = !1, new Promise((f, d) => {
      this._collection.findOneAndUpdate(
        c,
        l,
        u
      ).then((p) => {
        f(p);
      }).catch((p) => {
        if (p && p.code === 11e3) {
          const g = Object.assign({
            // try to replace OLD limit doc
            $or: [
              { expire: { $lte: new Date() } },
              { expire: { $eq: null } }
            ],
            key: e
          }, a), h = {
            $set: Object.assign({
              key: e,
              points: r,
              expire: n > 0 ? new Date(Date.now() + n) : null
            }, a)
          };
          this._collection.findOneAndUpdate(
            g,
            h,
            u
          ).then((m) => {
            f(m);
          }).catch((m) => {
            m && m.code === 11e3 ? this._upsert(e, r, n, i).then((y) => f(y)).catch((y) => d(y)) : d(m);
          });
        } else
          d(p);
      });
    });
  }
  _get(e, r = {}) {
    if (!this._collection)
      return Promise.reject(Error("Mongo connection is not established"));
    const n = r.attrs || {}, i = Object.assign({
      key: e,
      $or: [
        { expire: { $gt: new Date() } },
        { expire: { $eq: null } }
      ]
    }, n);
    return this._collection.findOne(i);
  }
  _delete(e, r = {}) {
    if (!this._collection)
      return Promise.reject(Error("Mongo connection is not established"));
    const n = r.attrs || {}, i = Object.assign({ key: e }, n);
    return this._collection.deleteOne(i).then((o) => o.deletedCount > 0);
  }
};
var RateLimiterMongo_1 = RateLimiterMongo$1;
const RateLimiterStoreAbstract$2 = RateLimiterStoreAbstract_1, RateLimiterRes$8 = RateLimiterRes_1;
let RateLimiterMySQL$1 = class extends RateLimiterStoreAbstract$2 {
  /**
   * @callback callback
   * @param {Object} err
   *
   * @param {Object} opts
   * @param {callback} cb
   * Defaults {
   *   ... see other in RateLimiterStoreAbstract
   *
   *   storeClient: anySqlClient,
   *   storeType: 'knex', // required only for Knex instance
   *   dbName: 'string',
   *   tableName: 'string',
   * }
   */
  constructor(e, r = null) {
    super(e), this.client = e.storeClient, this.clientType = e.storeType, this.dbName = e.dbName, this.tableName = e.tableName, this.clearExpiredByTimeout = e.clearExpiredByTimeout, this.tableCreated = e.tableCreated, this.tableCreated ? (this.clearExpiredByTimeout && this._clearExpiredHourAgo(), typeof r == "function" && r()) : this._createDbAndTable().then(() => {
      this.tableCreated = !0, this.clearExpiredByTimeout && this._clearExpiredHourAgo(), typeof r == "function" && r();
    }).catch((n) => {
      if (typeof r == "function")
        r(n);
      else
        throw n;
    });
  }
  clearExpired(e) {
    return new Promise((r) => {
      this._getConnection().then((n) => {
        n.query("DELETE FROM ??.?? WHERE expire < ?", [this.dbName, this.tableName, e], () => {
          this._releaseConnection(n), r();
        });
      }).catch(() => {
        r();
      });
    });
  }
  _clearExpiredHourAgo() {
    this._clearExpiredTimeoutId && clearTimeout(this._clearExpiredTimeoutId), this._clearExpiredTimeoutId = setTimeout(() => {
      this.clearExpired(Date.now() - 36e5).then(() => {
        this._clearExpiredHourAgo();
      });
    }, 3e5), this._clearExpiredTimeoutId.unref();
  }
  /**
   *
   * @return Promise<any>
   * @private
   */
  _getConnection() {
    switch (this.clientType) {
      case "pool":
        return new Promise((e, r) => {
          this.client.getConnection((n, i) => {
            if (n)
              return r(n);
            e(i);
          });
        });
      case "sequelize":
        return this.client.connectionManager.getConnection();
      case "knex":
        return this.client.client.acquireConnection();
      default:
        return Promise.resolve(this.client);
    }
  }
  _releaseConnection(e) {
    switch (this.clientType) {
      case "pool":
        return e.release();
      case "sequelize":
        return this.client.connectionManager.releaseConnection(e);
      case "knex":
        return this.client.client.releaseConnection(e);
      default:
        return !0;
    }
  }
  /**
   *
   * @returns {Promise<any>}
   * @private
   */
  _createDbAndTable() {
    return new Promise((e, r) => {
      this._getConnection().then((n) => {
        n.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`, (i) => {
          if (i)
            return this._releaseConnection(n), r(i);
          n.query(this._getCreateTableStmt(), (o) => {
            if (o)
              return this._releaseConnection(n), r(o);
            this._releaseConnection(n), e();
          });
        });
      }).catch((n) => {
        r(n);
      });
    });
  }
  _getCreateTableStmt() {
    return `CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`;
  }
  get clientType() {
    return this._clientType;
  }
  set clientType(e) {
    if (typeof e > "u")
      if (this.client.constructor.name === "Connection")
        e = "connection";
      else if (this.client.constructor.name === "Pool")
        e = "pool";
      else if (this.client.constructor.name === "Sequelize")
        e = "sequelize";
      else
        throw new Error("storeType is not defined");
    this._clientType = e.toLowerCase();
  }
  get dbName() {
    return this._dbName;
  }
  set dbName(e) {
    this._dbName = typeof e > "u" ? "rtlmtrflx" : e;
  }
  get tableName() {
    return this._tableName;
  }
  set tableName(e) {
    this._tableName = typeof e > "u" ? this.keyPrefix : e;
  }
  get tableCreated() {
    return this._tableCreated;
  }
  set tableCreated(e) {
    this._tableCreated = typeof e > "u" ? !1 : !!e;
  }
  get clearExpiredByTimeout() {
    return this._clearExpiredByTimeout;
  }
  set clearExpiredByTimeout(e) {
    this._clearExpiredByTimeout = typeof e > "u" ? !0 : Boolean(e);
  }
  _getRateLimiterRes(e, r, n) {
    const i = new RateLimiterRes$8(), [o] = n;
    return i.isFirstInDuration = r === o.points, i.consumedPoints = i.isFirstInDuration ? r : o.points, i.remainingPoints = Math.max(this.points - i.consumedPoints, 0), i.msBeforeNext = o.expire ? Math.max(o.expire - Date.now(), 0) : -1, i;
  }
  _upsertTransaction(e, r, n, i, o) {
    return new Promise((a, c) => {
      e.query("BEGIN", (l) => {
        if (l)
          return e.rollback(), c(l);
        const u = Date.now(), f = i > 0 ? u + i : null;
        let d, p;
        o ? (d = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`, p = [
          this.dbName,
          this.tableName,
          r,
          n,
          f,
          n,
          f
        ]) : (d = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`, p = [
          this.dbName,
          this.tableName,
          r,
          n,
          f,
          u,
          n,
          n,
          u,
          f
        ]), e.query(d, p, (g) => {
          if (g)
            return e.rollback(), c(g);
          e.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;", [this.dbName, this.tableName, r], (h, m) => {
            if (h)
              return e.rollback(), c(h);
            e.query("COMMIT", (y) => {
              if (y)
                return e.rollback(), c(y);
              a(m);
            });
          });
        });
      });
    });
  }
  _upsert(e, r, n, i = !1) {
    return this.tableCreated ? new Promise((o, a) => {
      this._getConnection().then((c) => {
        this._upsertTransaction(c, e, r, n, i).then((l) => {
          o(l), this._releaseConnection(c);
        }).catch((l) => {
          a(l), this._releaseConnection(c);
        });
      }).catch((c) => {
        a(c);
      });
    }) : Promise.reject(Error("Table is not created yet"));
  }
  _get(e) {
    return this.tableCreated ? new Promise((r, n) => {
      this._getConnection().then((i) => {
        i.query(
          "SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",
          [this.dbName, this.tableName, e, Date.now()],
          (o, a) => {
            o ? n(o) : a.length === 0 ? r(null) : r(a), this._releaseConnection(i);
          }
          // eslint-disable-line
        );
      }).catch((i) => {
        n(i);
      });
    }) : Promise.reject(Error("Table is not created yet"));
  }
  _delete(e) {
    return this.tableCreated ? new Promise((r, n) => {
      this._getConnection().then((i) => {
        i.query(
          "DELETE FROM ??.?? WHERE `key` = ?",
          [this.dbName, this.tableName, e],
          (o, a) => {
            o ? n(o) : r(a.affectedRows > 0), this._releaseConnection(i);
          }
          // eslint-disable-line
        );
      }).catch((i) => {
        n(i);
      });
    }) : Promise.reject(Error("Table is not created yet"));
  }
};
var RateLimiterMySQL_1 = RateLimiterMySQL$1;
const RateLimiterStoreAbstract$1 = RateLimiterStoreAbstract_1, RateLimiterRes$7 = RateLimiterRes_1;
let RateLimiterPostgres$1 = class extends RateLimiterStoreAbstract$1 {
  /**
   * @callback callback
   * @param {Object} err
   *
   * @param {Object} opts
   * @param {callback} cb
   * Defaults {
   *   ... see other in RateLimiterStoreAbstract
   *
   *   storeClient: postgresClient,
   *   storeType: 'knex', // required only for Knex instance
   *   tableName: 'string',
   * }
   */
  constructor(e, r = null) {
    super(e), this.client = e.storeClient, this.clientType = e.storeType, this.tableName = e.tableName, this.clearExpiredByTimeout = e.clearExpiredByTimeout, this.tableCreated = e.tableCreated, this.tableCreated ? typeof r == "function" && r() : this._createTable().then(() => {
      this.tableCreated = !0, this.clearExpiredByTimeout && this._clearExpiredHourAgo(), typeof r == "function" && r();
    }).catch((n) => {
      if (typeof r == "function")
        r(n);
      else
        throw n;
    });
  }
  clearExpired(e) {
    return new Promise((r) => {
      const n = {
        name: "rlflx-clear-expired",
        text: `DELETE FROM ${this.tableName} WHERE expire < $1`,
        values: [e]
      };
      this._query(n).then(() => {
        r();
      }).catch(() => {
        r();
      });
    });
  }
  /**
   * Delete all rows expired 1 hour ago once per 5 minutes
   *
   * @private
   */
  _clearExpiredHourAgo() {
    this._clearExpiredTimeoutId && clearTimeout(this._clearExpiredTimeoutId), this._clearExpiredTimeoutId = setTimeout(() => {
      this.clearExpired(Date.now() - 36e5).then(() => {
        this._clearExpiredHourAgo();
      });
    }, 3e5), this._clearExpiredTimeoutId.unref();
  }
  /**
   *
   * @return Promise<any>
   * @private
   */
  _getConnection() {
    switch (this.clientType) {
      case "pool":
        return Promise.resolve(this.client);
      case "sequelize":
        return this.client.connectionManager.getConnection();
      case "knex":
        return this.client.client.acquireConnection();
      case "typeorm":
        return Promise.resolve(this.client.driver.master);
      default:
        return Promise.resolve(this.client);
    }
  }
  _releaseConnection(e) {
    switch (this.clientType) {
      case "pool":
        return !0;
      case "sequelize":
        return this.client.connectionManager.releaseConnection(e);
      case "knex":
        return this.client.client.releaseConnection(e);
      case "typeorm":
        return !0;
      default:
        return !0;
    }
  }
  /**
   *
   * @returns {Promise<any>}
   * @private
   */
  _createTable() {
    return new Promise((e, r) => {
      this._query({
        text: this._getCreateTableStmt()
      }).then(() => {
        e();
      }).catch((n) => {
        n.code === "23505" ? e() : r(n);
      });
    });
  }
  _getCreateTableStmt() {
    return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`;
  }
  get clientType() {
    return this._clientType;
  }
  set clientType(e) {
    const r = this.client.constructor.name;
    if (typeof e > "u")
      if (r === "Client")
        e = "client";
      else if (r === "Pool" || r === "BoundPool")
        e = "pool";
      else if (r === "Sequelize")
        e = "sequelize";
      else
        throw new Error("storeType is not defined");
    this._clientType = e.toLowerCase();
  }
  get tableName() {
    return this._tableName;
  }
  set tableName(e) {
    this._tableName = typeof e > "u" ? this.keyPrefix : e;
  }
  get tableCreated() {
    return this._tableCreated;
  }
  set tableCreated(e) {
    this._tableCreated = typeof e > "u" ? !1 : !!e;
  }
  get clearExpiredByTimeout() {
    return this._clearExpiredByTimeout;
  }
  set clearExpiredByTimeout(e) {
    this._clearExpiredByTimeout = typeof e > "u" ? !0 : Boolean(e);
  }
  _getRateLimiterRes(e, r, n) {
    const i = new RateLimiterRes$7(), o = n.rows[0];
    return i.isFirstInDuration = r === o.points, i.consumedPoints = i.isFirstInDuration ? r : o.points, i.remainingPoints = Math.max(this.points - i.consumedPoints, 0), i.msBeforeNext = o.expire ? Math.max(o.expire - Date.now(), 0) : -1, i;
  }
  _query(e) {
    const n = { name: `${this.tableName.toLowerCase()}:${e.name}`, text: e.text, values: e.values };
    return new Promise((i, o) => {
      this._getConnection().then((a) => {
        a.query(n).then((c) => {
          i(c), this._releaseConnection(a);
        }).catch((c) => {
          o(c), this._releaseConnection(a);
        });
      }).catch((a) => {
        o(a);
      });
    });
  }
  _upsert(e, r, n, i = !1) {
    if (!this.tableCreated)
      return Promise.reject(Error("Table is not created yet"));
    const o = n > 0 ? Date.now() + n : null, a = i ? " $3 " : ` CASE
             WHEN ${this.tableName}.expire <= $4 THEN $3
             ELSE ${this.tableName}.expire
            END `;
    return this._query({
      name: i ? "rlflx-upsert-force" : "rlflx-upsert",
      text: `
            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= $4 OR 1=${i ? 1 : 0}) THEN $2
                          ELSE ${this.tableName}.points + ($2)
                         END,
                expire = ${a}
            RETURNING points, expire;`,
      values: [e, r, o, Date.now()]
    });
  }
  _get(e) {
    return this.tableCreated ? new Promise((r, n) => {
      this._query({
        name: "rlflx-get",
        text: `
            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,
        values: [e, Date.now()]
      }).then((i) => {
        i.rowCount === 0 && (i = null), r(i);
      }).catch((i) => {
        n(i);
      });
    }) : Promise.reject(Error("Table is not created yet"));
  }
  _delete(e) {
    return this.tableCreated ? this._query({
      name: "rlflx-delete",
      text: `DELETE FROM ${this.tableName} WHERE key = $1`,
      values: [e]
    }).then((r) => r.rowCount > 0) : Promise.reject(Error("Table is not created yet"));
  }
};
var RateLimiterPostgres_1 = RateLimiterPostgres$1, Record_1 = class {
  /**
   *
   * @param value int
   * @param expiresAt Date|int
   * @param timeoutId
   */
  constructor(e, r, n = null) {
    this.value = e, this.expiresAt = r, this.timeoutId = n;
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this._value = parseInt(e);
  }
  get expiresAt() {
    return this._expiresAt;
  }
  set expiresAt(e) {
    !(e instanceof Date) && Number.isInteger(e) && (e = new Date(e)), this._expiresAt = e;
  }
  get timeoutId() {
    return this._timeoutId;
  }
  set timeoutId(e) {
    this._timeoutId = e;
  }
};
const Record = Record_1, RateLimiterRes$6 = RateLimiterRes_1;
var MemoryStorage_1 = class {
  constructor() {
    this._storage = {};
  }
  incrby(e, r, n) {
    if (this._storage[e]) {
      const i = this._storage[e].expiresAt ? this._storage[e].expiresAt.getTime() - new Date().getTime() : -1;
      return i !== 0 ? (this._storage[e].value = this._storage[e].value + r, new RateLimiterRes$6(0, i, this._storage[e].value, !1)) : this.set(e, r, n);
    }
    return this.set(e, r, n);
  }
  set(e, r, n) {
    const i = n * 1e3;
    return this._storage[e] && this._storage[e].timeoutId && clearTimeout(this._storage[e].timeoutId), this._storage[e] = new Record(
      r,
      i > 0 ? new Date(Date.now() + i) : null
    ), i > 0 && (this._storage[e].timeoutId = setTimeout(() => {
      delete this._storage[e];
    }, i), this._storage[e].timeoutId.unref && this._storage[e].timeoutId.unref()), new RateLimiterRes$6(0, i === 0 ? -1 : i, this._storage[e].value, !0);
  }
  /**
   *
   * @param key
   * @returns {*}
   */
  get(e) {
    if (this._storage[e]) {
      const r = this._storage[e].expiresAt ? this._storage[e].expiresAt.getTime() - new Date().getTime() : -1;
      return new RateLimiterRes$6(0, r, this._storage[e].value, !1);
    }
    return null;
  }
  /**
   *
   * @param key
   * @returns {boolean}
   */
  delete(e) {
    return this._storage[e] ? (this._storage[e].timeoutId && clearTimeout(this._storage[e].timeoutId), delete this._storage[e], !0) : !1;
  }
};
const RateLimiterAbstract$2 = RateLimiterAbstract_1, MemoryStorage = MemoryStorage_1, RateLimiterRes$5 = RateLimiterRes_1;
let RateLimiterMemory$2 = class extends RateLimiterAbstract$2 {
  constructor(e = {}) {
    super(e), this._memoryStorage = new MemoryStorage();
  }
  /**
   *
   * @param key
   * @param pointsToConsume
   * @param {Object} options
   * @returns {Promise<RateLimiterRes>}
   */
  consume(e, r = 1, n = {}) {
    return new Promise((i, o) => {
      const a = this.getKey(e), c = this._getKeySecDuration(n);
      let l = this._memoryStorage.incrby(a, r, c);
      if (l.remainingPoints = Math.max(this.points - l.consumedPoints, 0), l.consumedPoints > this.points)
        this.blockDuration > 0 && l.consumedPoints <= this.points + r && (l = this._memoryStorage.set(a, l.consumedPoints, this.blockDuration)), o(l);
      else if (this.execEvenly && l.msBeforeNext > 0 && !l.isFirstInDuration) {
        let u = Math.ceil(l.msBeforeNext / (l.remainingPoints + 2));
        u < this.execEvenlyMinDelayMs && (u = l.consumedPoints * this.execEvenlyMinDelayMs), setTimeout(i, u, l);
      } else
        i(l);
    });
  }
  penalty(e, r = 1, n = {}) {
    const i = this.getKey(e);
    return new Promise((o) => {
      const a = this._getKeySecDuration(n), c = this._memoryStorage.incrby(i, r, a);
      c.remainingPoints = Math.max(this.points - c.consumedPoints, 0), o(c);
    });
  }
  reward(e, r = 1, n = {}) {
    const i = this.getKey(e);
    return new Promise((o) => {
      const a = this._getKeySecDuration(n), c = this._memoryStorage.incrby(i, -r, a);
      c.remainingPoints = Math.max(this.points - c.consumedPoints, 0), o(c);
    });
  }
  /**
   * Block any key for secDuration seconds
   *
   * @param key
   * @param secDuration
   */
  block(e, r) {
    const n = r * 1e3, i = this.points + 1;
    return this._memoryStorage.set(this.getKey(e), i, r), Promise.resolve(
      new RateLimiterRes$5(0, n === 0 ? -1 : n, i)
    );
  }
  set(e, r, n) {
    const i = (n >= 0 ? n : this.duration) * 1e3;
    return this._memoryStorage.set(this.getKey(e), r, n), Promise.resolve(
      new RateLimiterRes$5(0, i === 0 ? -1 : i, r)
    );
  }
  get(e) {
    const r = this._memoryStorage.get(this.getKey(e));
    return r !== null && (r.remainingPoints = Math.max(this.points - r.consumedPoints, 0)), Promise.resolve(r);
  }
  delete(e) {
    return Promise.resolve(this._memoryStorage.delete(this.getKey(e)));
  }
};
var RateLimiterMemory_1 = RateLimiterMemory$2;
const cluster = cluster$1, crypto = crypto$3, RateLimiterAbstract$1 = RateLimiterAbstract_1, RateLimiterMemory$1 = RateLimiterMemory_1, RateLimiterRes$4 = RateLimiterRes_1, channel = "rate_limiter_flexible";
let masterInstance = null;
const masterSendToWorker = function(t, e, r, n) {
  let i;
  n === null || n === !0 || n === !1 ? i = n : i = {
    remainingPoints: n.remainingPoints,
    msBeforeNext: n.msBeforeNext,
    consumedPoints: n.consumedPoints,
    isFirstInDuration: n.isFirstInDuration
  }, t.send({
    channel,
    keyPrefix: e.keyPrefix,
    // which rate limiter exactly
    promiseId: e.promiseId,
    type: r,
    data: i
  });
}, workerWaitInit = function(t) {
  setTimeout(() => {
    this._initiated ? process.send(t) : typeof this._promises[t.promiseId] < "u" && workerWaitInit.call(this, t);
  }, 30);
}, workerSendToMaster = function(t, e, r, n, i) {
  const o = {
    channel,
    keyPrefix: this.keyPrefix,
    func: t,
    promiseId: e,
    data: {
      key: r,
      arg: n,
      opts: i
    }
  };
  this._initiated ? process.send(o) : workerWaitInit.call(this, o);
}, masterProcessMsg = function(t, e) {
  if (!e || e.channel !== channel || typeof this._rateLimiters[e.keyPrefix] > "u")
    return !1;
  let r;
  switch (e.func) {
    case "consume":
      r = this._rateLimiters[e.keyPrefix].consume(e.data.key, e.data.arg, e.data.opts);
      break;
    case "penalty":
      r = this._rateLimiters[e.keyPrefix].penalty(e.data.key, e.data.arg, e.data.opts);
      break;
    case "reward":
      r = this._rateLimiters[e.keyPrefix].reward(e.data.key, e.data.arg, e.data.opts);
      break;
    case "block":
      r = this._rateLimiters[e.keyPrefix].block(e.data.key, e.data.arg, e.data.opts);
      break;
    case "get":
      r = this._rateLimiters[e.keyPrefix].get(e.data.key, e.data.opts);
      break;
    case "delete":
      r = this._rateLimiters[e.keyPrefix].delete(e.data.key, e.data.opts);
      break;
    default:
      return !1;
  }
  r && r.then((n) => {
    masterSendToWorker(t, e, "resolve", n);
  }).catch((n) => {
    masterSendToWorker(t, e, "reject", n);
  });
}, workerProcessMsg = function(t) {
  if (!t || t.channel !== channel || t.keyPrefix !== this.keyPrefix)
    return !1;
  if (this._promises[t.promiseId]) {
    clearTimeout(this._promises[t.promiseId].timeoutId);
    let e;
    switch (t.data === null || t.data === !0 || t.data === !1 ? e = t.data : e = new RateLimiterRes$4(
      t.data.remainingPoints,
      t.data.msBeforeNext,
      t.data.consumedPoints,
      t.data.isFirstInDuration
      // eslint-disable-line comma-dangle
    ), t.type) {
      case "resolve":
        this._promises[t.promiseId].resolve(e);
        break;
      case "reject":
        this._promises[t.promiseId].reject(e);
        break;
      default:
        throw new Error(`RateLimiterCluster: no such message type '${t.type}'`);
    }
    delete this._promises[t.promiseId];
  }
}, getOpts = function() {
  return {
    points: this.points,
    duration: this.duration,
    blockDuration: this.blockDuration,
    execEvenly: this.execEvenly,
    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,
    keyPrefix: this.keyPrefix
  };
}, savePromise = function(t, e) {
  const r = process.hrtime();
  let n = r[0].toString() + r[1].toString();
  return typeof this._promises[n] < "u" && (n += crypto.randomBytes(12).toString("base64")), this._promises[n] = {
    resolve: t,
    reject: e,
    timeoutId: setTimeout(() => {
      delete this._promises[n], e(new Error("RateLimiterCluster timeout: no answer from master in time"));
    }, this.timeoutMs)
  }, n;
};
let RateLimiterClusterMaster$1 = class {
  constructor() {
    if (masterInstance)
      return masterInstance;
    this._rateLimiters = {}, cluster.setMaxListeners(0), cluster.on("message", (e, r) => {
      r && r.channel === channel && r.type === "init" ? (typeof this._rateLimiters[r.opts.keyPrefix] > "u" && (this._rateLimiters[r.opts.keyPrefix] = new RateLimiterMemory$1(r.opts)), e.send({
        channel,
        type: "init",
        keyPrefix: r.opts.keyPrefix
      })) : masterProcessMsg.call(this, e, r);
    }), masterInstance = this;
  }
}, RateLimiterClusterMasterPM2$1 = class {
  constructor(e) {
    if (masterInstance)
      return masterInstance;
    this._rateLimiters = {}, e.launchBus((r, n) => {
      n.on("process:msg", (i) => {
        const o = i.raw;
        if (o && o.channel === channel && o.type === "init")
          typeof this._rateLimiters[o.opts.keyPrefix] > "u" && (this._rateLimiters[o.opts.keyPrefix] = new RateLimiterMemory$1(o.opts)), e.sendDataToProcessId(i.process.pm_id, {
            data: {},
            topic: channel,
            channel,
            type: "init",
            keyPrefix: o.opts.keyPrefix
          }, (a, c) => {
            a && console.log(a, c);
          });
        else {
          const a = {
            send: (c) => {
              const l = c;
              l.topic = channel, typeof l.data > "u" && (l.data = {}), e.sendDataToProcessId(i.process.pm_id, l, (u, f) => {
                u && console.log(u, f);
              });
            }
          };
          masterProcessMsg.call(this, a, o);
        }
      });
    }), masterInstance = this;
  }
};
class RateLimiterClusterWorker extends RateLimiterAbstract$1 {
  get timeoutMs() {
    return this._timeoutMs;
  }
  set timeoutMs(e) {
    this._timeoutMs = typeof e > "u" ? 5e3 : Math.abs(parseInt(e));
  }
  constructor(e = {}) {
    super(e), process.setMaxListeners(0), this.timeoutMs = e.timeoutMs, this._initiated = !1, process.on("message", (r) => {
      r && r.channel === channel && r.type === "init" && r.keyPrefix === this.keyPrefix ? this._initiated = !0 : workerProcessMsg.call(this, r);
    }), process.send({
      channel,
      type: "init",
      opts: getOpts.call(this)
    }), this._promises = {};
  }
  consume(e, r = 1, n = {}) {
    return new Promise((i, o) => {
      const a = savePromise.call(this, i, o);
      workerSendToMaster.call(this, "consume", a, e, r, n);
    });
  }
  penalty(e, r = 1, n = {}) {
    return new Promise((i, o) => {
      const a = savePromise.call(this, i, o);
      workerSendToMaster.call(this, "penalty", a, e, r, n);
    });
  }
  reward(e, r = 1, n = {}) {
    return new Promise((i, o) => {
      const a = savePromise.call(this, i, o);
      workerSendToMaster.call(this, "reward", a, e, r, n);
    });
  }
  block(e, r, n = {}) {
    return new Promise((i, o) => {
      const a = savePromise.call(this, i, o);
      workerSendToMaster.call(this, "block", a, e, r, n);
    });
  }
  get(e, r = {}) {
    return new Promise((n, i) => {
      const o = savePromise.call(this, n, i);
      workerSendToMaster.call(this, "get", o, e, r);
    });
  }
  delete(e, r = {}) {
    return new Promise((n, i) => {
      const o = savePromise.call(this, n, i);
      workerSendToMaster.call(this, "delete", o, e, r);
    });
  }
}
var RateLimiterCluster$1 = {
  RateLimiterClusterMaster: RateLimiterClusterMaster$1,
  RateLimiterClusterMasterPM2: RateLimiterClusterMasterPM2$1,
  RateLimiterCluster: RateLimiterClusterWorker
};
const RateLimiterStoreAbstract = RateLimiterStoreAbstract_1, RateLimiterRes$3 = RateLimiterRes_1;
let RateLimiterMemcache$1 = class extends RateLimiterStoreAbstract {
  /**
   *
   * @param {Object} opts
   * Defaults {
   *   ... see other in RateLimiterStoreAbstract
   *
   *   storeClient: memcacheClient
   * }
   */
  constructor(e) {
    super(e), this.client = e.storeClient;
  }
  _getRateLimiterRes(e, r, n) {
    const i = new RateLimiterRes$3();
    return i.consumedPoints = parseInt(n.consumedPoints), i.isFirstInDuration = n.consumedPoints === r, i.remainingPoints = Math.max(this.points - i.consumedPoints, 0), i.msBeforeNext = n.msBeforeNext, i;
  }
  _upsert(e, r, n, i = !1, o = {}) {
    return new Promise((a, c) => {
      const l = Date.now(), u = Math.floor(n / 1e3);
      i ? this.client.set(e, r, u, (f) => {
        f ? c(f) : this.client.set(
          `${e}_expire`,
          u > 0 ? l + u * 1e3 : -1,
          u,
          () => {
            const d = {
              consumedPoints: r,
              msBeforeNext: u > 0 ? u * 1e3 : -1
            };
            a(d);
          }
        );
      }) : this.client.incr(e, r, (f, d) => {
        f || d === !1 ? this.client.add(e, r, u, (p, g) => {
          if (p || !g)
            if (typeof o.attemptNumber > "u" || o.attemptNumber < 3) {
              const h = Object.assign({}, o);
              h.attemptNumber = h.attemptNumber ? h.attemptNumber + 1 : 1, this._upsert(e, r, n, i, h).then((m) => a(m)).catch((m) => c(m));
            } else
              c(new Error("Can not add key"));
          else
            this.client.add(
              `${e}_expire`,
              u > 0 ? l + u * 1e3 : -1,
              u,
              () => {
                const h = {
                  consumedPoints: r,
                  msBeforeNext: u > 0 ? u * 1e3 : -1
                };
                a(h);
              }
            );
        }) : this.client.get(`${e}_expire`, (p, g) => {
          if (p)
            c(p);
          else {
            const h = g === !1 ? 0 : g, m = {
              consumedPoints: d,
              msBeforeNext: h >= 0 ? Math.max(h - l, 0) : -1
            };
            a(m);
          }
        });
      });
    });
  }
  _get(e) {
    return new Promise((r, n) => {
      const i = Date.now();
      this.client.get(e, (o, a) => {
        a ? this.client.get(`${e}_expire`, (c, l) => {
          if (c)
            n(c);
          else {
            const u = l === !1 ? 0 : l, f = {
              consumedPoints: a,
              msBeforeNext: u >= 0 ? Math.max(u - i, 0) : -1
            };
            r(f);
          }
        }) : r(null);
      });
    });
  }
  _delete(e) {
    return new Promise((r, n) => {
      this.client.del(e, (i, o) => {
        i ? n(i) : o === !1 ? r(o) : this.client.del(`${e}_expire`, (a) => {
          a ? n(a) : r(o);
        });
      });
    });
  }
};
var RateLimiterMemcache_1 = RateLimiterMemcache$1;
const RateLimiterRes$2 = RateLimiterRes_1;
var RLWrapperBlackAndWhite_1 = class {
  constructor(e = {}) {
    this.limiter = e.limiter, this.blackList = e.blackList, this.whiteList = e.whiteList, this.isBlackListed = e.isBlackListed, this.isWhiteListed = e.isWhiteListed, this.runActionAnyway = e.runActionAnyway;
  }
  get limiter() {
    return this._limiter;
  }
  set limiter(e) {
    if (typeof e > "u")
      throw new Error("limiter is not set");
    this._limiter = e;
  }
  get runActionAnyway() {
    return this._runActionAnyway;
  }
  set runActionAnyway(e) {
    this._runActionAnyway = typeof e > "u" ? !1 : e;
  }
  get blackList() {
    return this._blackList;
  }
  set blackList(e) {
    this._blackList = Array.isArray(e) ? e : [];
  }
  get isBlackListed() {
    return this._isBlackListed;
  }
  set isBlackListed(e) {
    if (typeof e > "u" && (e = () => !1), typeof e != "function")
      throw new Error("isBlackListed must be function");
    this._isBlackListed = e;
  }
  get whiteList() {
    return this._whiteList;
  }
  set whiteList(e) {
    this._whiteList = Array.isArray(e) ? e : [];
  }
  get isWhiteListed() {
    return this._isWhiteListed;
  }
  set isWhiteListed(e) {
    if (typeof e > "u" && (e = () => !1), typeof e != "function")
      throw new Error("isWhiteListed must be function");
    this._isWhiteListed = e;
  }
  isBlackListedSomewhere(e) {
    return this.blackList.indexOf(e) >= 0 || this.isBlackListed(e);
  }
  isWhiteListedSomewhere(e) {
    return this.whiteList.indexOf(e) >= 0 || this.isWhiteListed(e);
  }
  getBlackRes() {
    return new RateLimiterRes$2(0, Number.MAX_SAFE_INTEGER, 0, !1);
  }
  getWhiteRes() {
    return new RateLimiterRes$2(Number.MAX_SAFE_INTEGER, 0, 0, !1);
  }
  rejectBlack() {
    return Promise.reject(this.getBlackRes());
  }
  resolveBlack() {
    return Promise.resolve(this.getBlackRes());
  }
  resolveWhite() {
    return Promise.resolve(this.getWhiteRes());
  }
  consume(e, r = 1) {
    let n;
    return this.isWhiteListedSomewhere(e) ? n = this.resolveWhite() : this.isBlackListedSomewhere(e) && (n = this.rejectBlack()), typeof n > "u" ? this.limiter.consume(e, r) : (this.runActionAnyway && this.limiter.consume(e, r).catch(() => {
    }), n);
  }
  block(e, r) {
    let n;
    return this.isWhiteListedSomewhere(e) ? n = this.resolveWhite() : this.isBlackListedSomewhere(e) && (n = this.resolveBlack()), typeof n > "u" ? this.limiter.block(e, r) : (this.runActionAnyway && this.limiter.block(e, r).catch(() => {
    }), n);
  }
  penalty(e, r) {
    let n;
    return this.isWhiteListedSomewhere(e) ? n = this.resolveWhite() : this.isBlackListedSomewhere(e) && (n = this.resolveBlack()), typeof n > "u" ? this.limiter.penalty(e, r) : (this.runActionAnyway && this.limiter.penalty(e, r).catch(() => {
    }), n);
  }
  reward(e, r) {
    let n;
    return this.isWhiteListedSomewhere(e) ? n = this.resolveWhite() : this.isBlackListedSomewhere(e) && (n = this.resolveBlack()), typeof n > "u" ? this.limiter.reward(e, r) : (this.runActionAnyway && this.limiter.reward(e, r).catch(() => {
    }), n);
  }
  get(e) {
    let r;
    return this.isWhiteListedSomewhere(e) ? r = this.resolveWhite() : this.isBlackListedSomewhere(e) && (r = this.resolveBlack()), typeof r > "u" || this.runActionAnyway ? this.limiter.get(e) : r;
  }
  delete(e) {
    return this.limiter.delete(e);
  }
};
const RateLimiterAbstract = RateLimiterAbstract_1;
var RateLimiterUnion_1 = class {
  constructor(...e) {
    if (e.length < 1)
      throw new Error("RateLimiterUnion: at least one limiter have to be passed");
    e.forEach((r) => {
      if (!(r instanceof RateLimiterAbstract))
        throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract");
    }), this._limiters = e;
  }
  consume(e, r = 1) {
    return new Promise((n, i) => {
      const o = [];
      this._limiters.forEach((a) => {
        o.push(a.consume(e, r).catch((c) => ({ rejected: !0, rej: c })));
      }), Promise.all(o).then((a) => {
        const c = {};
        let l = !1;
        a.forEach((u) => {
          u.rejected === !0 && (l = !0);
        });
        for (let u = 0; u < a.length; u++)
          l && a[u].rejected === !0 ? c[this._limiters[u].keyPrefix] = a[u].rej : l || (c[this._limiters[u].keyPrefix] = a[u]);
        l ? i(c) : n(c);
      });
    });
  }
}, RateLimiterQueueError_1 = class extends Error {
  constructor(e, r) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = "CustomError", this.message = e, r && (this.extra = r);
  }
};
const RateLimiterQueueError = RateLimiterQueueError_1, MAX_QUEUE_SIZE = 4294967295, KEY_DEFAULT = "limiter";
var RateLimiterQueue_1 = class {
  constructor(e, r = {
    maxQueueSize: MAX_QUEUE_SIZE
  }) {
    this._queueLimiters = {
      KEY_DEFAULT: new RateLimiterQueueInternal(e, r)
    }, this._limiterFlexible = e, this._maxQueueSize = r.maxQueueSize;
  }
  getTokensRemaining(e = KEY_DEFAULT) {
    return this._queueLimiters[e] ? this._queueLimiters[e].getTokensRemaining() : Promise.resolve(this._limiterFlexible.points);
  }
  removeTokens(e, r = KEY_DEFAULT) {
    return this._queueLimiters[r] || (this._queueLimiters[r] = new RateLimiterQueueInternal(
      this._limiterFlexible,
      {
        key: r,
        maxQueueSize: this._maxQueueSize
      }
    )), this._queueLimiters[r].removeTokens(e);
  }
};
class RateLimiterQueueInternal {
  constructor(e, r = {
    maxQueueSize: MAX_QUEUE_SIZE,
    key: KEY_DEFAULT
  }) {
    this._key = r.key, this._waitTimeout = null, this._queue = [], this._limiterFlexible = e, this._maxQueueSize = r.maxQueueSize;
  }
  getTokensRemaining() {
    return this._limiterFlexible.get(this._key).then((e) => e !== null ? e.remainingPoints : this._limiterFlexible.points);
  }
  removeTokens(e) {
    const r = this;
    return new Promise((n, i) => {
      if (e > r._limiterFlexible.points) {
        i(new RateLimiterQueueError(`Requested tokens ${e} exceeds maximum ${r._limiterFlexible.points} tokens per interval`));
        return;
      }
      r._queue.length > 0 ? r._queueRequest.call(r, n, i, e) : r._limiterFlexible.consume(r._key, e).then((o) => {
        n(o.remainingPoints);
      }).catch((o) => {
        o instanceof Error ? i(o) : (r._queueRequest.call(r, n, i, e), r._waitTimeout === null && (r._waitTimeout = setTimeout(r._processFIFO.bind(r), o.msBeforeNext)));
      });
    });
  }
  _queueRequest(e, r, n) {
    const i = this;
    i._queue.length < i._maxQueueSize ? i._queue.push({ resolve: e, reject: r, tokens: n }) : r(new RateLimiterQueueError(`Number of requests reached it's maximum ${i._maxQueueSize}`));
  }
  _processFIFO() {
    const e = this;
    if (e._waitTimeout !== null && (clearTimeout(e._waitTimeout), e._waitTimeout = null), e._queue.length === 0)
      return;
    const r = e._queue.shift();
    e._limiterFlexible.consume(e._key, r.tokens).then((n) => {
      r.resolve(n.remainingPoints), e._processFIFO.call(e);
    }).catch((n) => {
      n instanceof Error ? (r.reject(n), e._processFIFO.call(e)) : (e._queue.unshift(r), e._waitTimeout === null && (e._waitTimeout = setTimeout(e._processFIFO.bind(e), n.msBeforeNext)));
    });
  }
}
const RateLimiterRes$1 = RateLimiterRes_1;
var BurstyRateLimiter_1 = class {
  constructor(e, r) {
    this._rateLimiter = e, this._burstLimiter = r;
  }
  /**
   * Merge rate limiter response objects. Responses can be null
   *
   * @param {RateLimiterRes} [rlRes] Rate limiter response
   * @param {RateLimiterRes} [blRes] Bursty limiter response
   */
  _combineRes(e, r) {
    return new RateLimiterRes$1(
      e.remainingPoints,
      Math.min(e.msBeforeNext, r.msBeforeNext),
      e.consumedPoints,
      e.isFirstInDuration
    );
  }
  /**
   * @param key
   * @param pointsToConsume
   * @param options
   * @returns {Promise<any>}
   */
  consume(e, r = 1, n = {}) {
    return this._rateLimiter.consume(e, r, n).catch((i) => i instanceof RateLimiterRes$1 ? this._burstLimiter.consume(e, r, n).then((o) => Promise.resolve(this._combineRes(i, o))).catch(
      (o) => o instanceof RateLimiterRes$1 ? Promise.reject(this._combineRes(i, o)) : Promise.reject(o)
    ) : Promise.reject(i));
  }
  /**
   * It doesn't expose available points from burstLimiter
   *
   * @param key
   * @returns {Promise<RateLimiterRes>}
   */
  get(e) {
    return Promise.all([
      this._rateLimiter.get(e),
      this._burstLimiter.get(e)
    ]).then(([r, n]) => this._combineRes(r, n));
  }
  get points() {
    return this._rateLimiter.points;
  }
};
const RateLimiterRedis = RateLimiterRedis_1, RateLimiterMongo = RateLimiterMongo_1, RateLimiterMySQL = RateLimiterMySQL_1, RateLimiterPostgres = RateLimiterPostgres_1, { RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster } = RateLimiterCluster$1, RateLimiterMemory = RateLimiterMemory_1, RateLimiterMemcache = RateLimiterMemcache_1, RLWrapperBlackAndWhite = RLWrapperBlackAndWhite_1, RateLimiterUnion = RateLimiterUnion_1, RateLimiterQueue = RateLimiterQueue_1, BurstyRateLimiter = BurstyRateLimiter_1, RateLimiterRes = RateLimiterRes_1;
var rateLimiterFlexible = {
  RateLimiterRedis,
  RateLimiterMongo,
  RateLimiterMySQL,
  RateLimiterPostgres,
  RateLimiterMemory,
  RateLimiterMemcache,
  RateLimiterClusterMaster,
  RateLimiterClusterMasterPM2,
  RateLimiterCluster,
  RLWrapperBlackAndWhite,
  RateLimiterUnion,
  RateLimiterQueue,
  BurstyRateLimiter,
  RateLimiterRes
};
const log$p = logger$1("libp2p:get-peer");
function getPeerAddress(t) {
  if (isPeerId(t))
    return { peerId: t, multiaddrs: [] };
  Array.isArray(t) || (t = [t]);
  let e;
  if (t.length > 0) {
    const r = t[0].getPeerId();
    e = r == null ? void 0 : peerIdFromString(r), t.forEach((n) => {
      if (!isMultiaddr$1(n))
        throw log$p.error("multiaddr %s was invalid", n), new CodeError$2("Invalid Multiaddr", codes$1.ERR_INVALID_MULTIADDR);
      const i = n.getPeerId();
      if (i == null) {
        if (e != null)
          throw new CodeError$2("Multiaddrs must all have the same peer id or have no peer id", codes$1.ERR_INVALID_PARAMETERS);
      } else {
        const o = peerIdFromString(i);
        if (e == null || !e.equals(o))
          throw new CodeError$2("Multiaddrs must all have the same peer id or have no peer id", codes$1.ERR_INVALID_PARAMETERS);
      }
    });
  }
  return {
    peerId: e,
    multiaddrs: t
  };
}
function lowerBound(t, e, r) {
  let n = 0, i = t.length;
  for (; i > 0; ) {
    const o = Math.trunc(i / 2);
    let a = n + o;
    r(t[a], e) <= 0 ? (n = ++a, i -= o + 1) : i = o;
  }
  return n;
}
var oe;
class PeerPriorityQueue {
  constructor() {
    ie(this, oe, []);
  }
  enqueue(e, r) {
    const n = r == null ? void 0 : r.peerId, i = (r == null ? void 0 : r.priority) ?? 0;
    if (n == null)
      throw new CodeError$2("missing peer id", codes$1.ERR_INVALID_PARAMETERS);
    const o = {
      priority: i,
      peerId: n,
      run: e
    };
    if (this.size > 0 && Y(this, oe)[this.size - 1].priority >= i) {
      Y(this, oe).push(o);
      return;
    }
    const a = lowerBound(Y(this, oe), o, (c, l) => l.priority - c.priority);
    Y(this, oe).splice(a, 0, o);
  }
  dequeue() {
    const e = Y(this, oe).shift();
    return e == null ? void 0 : e.run;
  }
  filter(e) {
    if (e.peerId != null) {
      const r = e.peerId;
      return Y(this, oe).filter((n) => r.equals(n.peerId)).map((n) => n.run);
    }
    return Y(this, oe).filter((r) => r.priority === e.priority).map((r) => r.run);
  }
  get size() {
    return Y(this, oe).length;
  }
}
oe = new WeakMap();
class PeerJobQueue extends PQueue {
  constructor(e = {}) {
    super({
      ...e,
      queueClass: PeerPriorityQueue
    });
  }
  /**
   * Returns true if this queue has a job for the passed peer id that has not yet
   * started to run
   */
  hasJob(e) {
    return this.sizeBy({
      peerId: e
    }) > 0;
  }
}
const DIAL_TIMEOUT = 3e4, INBOUND_UPGRADE_TIMEOUT = 3e4, MAX_PEER_ADDRS_TO_DIAL = 25, MAX_PARALLEL_DIALS_PER_PEER = 10, AUTO_DIAL_INTERVAL = 5e3, AUTO_DIAL_PRIORITY = 0, AUTO_DIAL_MAX_QUEUE_LENGTH = 100, AUTO_DIAL_PEER_RETRY_THRESHOLD = 1e3 * 60, INBOUND_CONNECTION_THRESHOLD = 5, MAX_INCOMING_PENDING_CONNECTIONS = 10, LAST_DIAL_FAILURE_KEY = "last-dial-failure", MAX_PARALLEL_DIALS = 100, MIN_CONNECTIONS = 50, MAX_CONNECTIONS = 300, AUTO_DIAL_CONCURRENCY = 25, log$o = logger$1("libp2p:connection-manager:auto-dial"), defaultOptions$3 = {
  minConnections: MIN_CONNECTIONS,
  maxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,
  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
  autoDialPriority: AUTO_DIAL_PRIORITY,
  autoDialInterval: AUTO_DIAL_INTERVAL,
  autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD
};
class AutoDial {
  /**
   * Proactively tries to connect to known peers stored in the PeerStore.
   * It will keep the number of connections below the upper limit and sort
   * the peers to connect based on whether we know their keys and protocols.
   */
  constructor(e, r) {
    $(this, "connectionManager");
    $(this, "peerStore");
    $(this, "queue");
    $(this, "minConnections");
    $(this, "autoDialPriority");
    $(this, "autoDialIntervalMs");
    $(this, "autoDialMaxQueueLength");
    $(this, "autoDialPeerRetryThresholdMs");
    $(this, "autoDialInterval");
    $(this, "started");
    $(this, "running");
    this.connectionManager = e.connectionManager, this.peerStore = e.peerStore, this.minConnections = r.minConnections ?? defaultOptions$3.minConnections, this.autoDialPriority = r.autoDialPriority ?? defaultOptions$3.autoDialPriority, this.autoDialIntervalMs = r.autoDialInterval ?? defaultOptions$3.autoDialInterval, this.autoDialMaxQueueLength = r.maxQueueLength ?? defaultOptions$3.maxQueueLength, this.autoDialPeerRetryThresholdMs = r.autoDialPeerRetryThreshold ?? defaultOptions$3.autoDialPeerRetryThreshold, this.started = !1, this.running = !1, this.queue = new PeerJobQueue({
      concurrency: r.autoDialConcurrency ?? defaultOptions$3.autoDialConcurrency
    }), this.queue.addListener("error", (n) => {
      log$o.error("error during auto-dial", n);
    }), e.events.addEventListener("connection:close", () => {
      this.autoDial().catch((n) => {
        log$o.error(n);
      });
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.autoDialInterval = setTimeout(() => {
      this.autoDial().catch((e) => {
        log$o.error("error while autodialing", e);
      });
    }, this.autoDialIntervalMs), this.started = !0;
  }
  afterStart() {
    this.autoDial().catch((e) => {
      log$o.error("error while autodialing", e);
    });
  }
  stop() {
    this.queue.clear(), clearTimeout(this.autoDialInterval), this.started = !1, this.running = !1;
  }
  async autoDial() {
    if (!this.started)
      return;
    const e = this.connectionManager.getConnectionsMap(), r = e.size;
    if (r >= this.minConnections) {
      this.minConnections > 0 && log$o.trace("have enough connections %d/%d", r, this.minConnections);
      return;
    }
    if (this.queue.size > this.autoDialMaxQueueLength) {
      log$o("not enough connections %d/%d but auto dial queue is full", r, this.minConnections);
      return;
    }
    if (this.running) {
      log$o("not enough connections %d/%d - but skipping autodial as it is already running", r, this.minConnections);
      return;
    }
    this.running = !0, log$o("not enough connections %d/%d - will dial peers to increase the number of connections", r, this.minConnections);
    const n = new PeerSet(
      // @ts-expect-error boolean filter removes falsy peer IDs
      this.connectionManager.getDialQueue().map((u) => u.peerId).filter(Boolean)
    ), i = await this.peerStore.all({
      filters: [
        // Remove some peers
        (u) => u.addresses.length === 0 ? (log$o.trace("not autodialing %p because they have no addresses"), !1) : e.has(u.id) ? (log$o.trace("not autodialing %p because they are already connected"), !1) : n.has(u.id) ? (log$o.trace("not autodialing %p because they are already being dialed"), !1) : this.queue.hasJob(u.id) ? (log$o.trace("not autodialing %p because they are already being autodialed"), !1) : !0
      ]
    }), o = i.sort(() => Math.random() > 0.5 ? 1 : -1), a = new PeerMap();
    for (const u of o)
      a.has(u.id) || a.set(u.id, [...u.tags.values()].reduce((f, d) => f + d.value, 0));
    const l = o.sort((u, f) => {
      const d = a.get(u.id) ?? 0, p = a.get(f.id) ?? 0;
      return d > p ? -1 : d < p ? 1 : 0;
    }).filter((u) => {
      const f = u.metadata.get(LAST_DIAL_FAILURE_KEY);
      if (f == null)
        return !0;
      const d = parseInt(toString$4(f));
      return isNaN(d) ? !0 : Date.now() - d > this.autoDialPeerRetryThresholdMs;
    });
    log$o("selected %d/%d peers to dial", l.length, i.length);
    for (const u of l)
      this.queue.add(async () => {
        const f = this.connectionManager.getConnectionsMap().size;
        if (f >= this.minConnections) {
          log$o("got enough connections now %d/%d", f, this.minConnections), this.queue.clear();
          return;
        }
        log$o("connecting to a peerStore stored peer %p", u.id), await this.connectionManager.openConnection(u.id, {
          priority: this.autoDialPriority
        });
      }, {
        peerId: u.id
      }).catch((f) => {
        log$o.error("could not connect to peerStore stored peer", f);
      });
    this.running = !1, this.started && (this.autoDialInterval = setTimeout(() => {
      this.autoDial().catch((u) => {
        log$o.error("error while autodialing", u);
      });
    }, this.autoDialIntervalMs));
  }
}
const log$n = logger$1("libp2p:connection-manager:connection-pruner"), defaultOptions$2 = {
  maxConnections: MAX_CONNECTIONS,
  allow: []
};
class ConnectionPruner {
  constructor(e, r = {}) {
    $(this, "maxConnections");
    $(this, "connectionManager");
    $(this, "peerStore");
    $(this, "allow");
    $(this, "events");
    this.maxConnections = r.maxConnections ?? defaultOptions$2.maxConnections, this.allow = r.allow ?? defaultOptions$2.allow, this.connectionManager = e.connectionManager, this.peerStore = e.peerStore, this.events = e.events, e.events.addEventListener("connection:open", () => {
      this.maybePruneConnections().catch((n) => {
        log$n.error(n);
      });
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async maybePruneConnections() {
    const e = this.connectionManager.getConnections(), r = e.length, n = Math.max(r - this.maxConnections, 0);
    if (log$n("checking max connections limit %d/%d", r, this.maxConnections), r <= this.maxConnections)
      return;
    log$n("max connections limit exceeded %d/%d, pruning %d connection(s)", r, this.maxConnections, n);
    const i = new PeerMap();
    for (const c of e) {
      const l = c.remotePeer;
      if (!i.has(l)) {
        i.set(l, 0);
        try {
          const u = await this.peerStore.get(l);
          i.set(l, [...u.tags.values()].reduce((f, d) => f + d.value, 0));
        } catch (u) {
          u.code !== "ERR_NOT_FOUND" && log$n.error("error loading peer tags", u);
        }
      }
    }
    const o = e.sort((c, l) => {
      const u = i.get(c.remotePeer) ?? 0, f = i.get(l.remotePeer) ?? 0;
      if (u > f)
        return 1;
      if (u < f)
        return -1;
      const d = c.timeline.open, p = l.timeline.open;
      return d < p ? 1 : d > p ? -1 : 0;
    }), a = [];
    for (const c of o)
      if (log$n("too many connections open - closing a connection to %p", c.remotePeer), this.allow.some((u) => c.remoteAddr.toString().startsWith(u.toString())) || a.push(c), a.length === n)
        break;
    await Promise.all(a.map(async (c) => {
      try {
        await c.close();
      } catch (l) {
        log$n.error(l);
      }
    })), this.events.safeDispatchEvent("connection:prune", { detail: a });
  }
}
function anySignal(t) {
  const e = new globalThis.AbortController();
  function r() {
    e.abort();
    for (const o of t)
      (o == null ? void 0 : o.removeEventListener) != null && o.removeEventListener("abort", r);
  }
  for (const o of t) {
    if ((o == null ? void 0 : o.aborted) === !0) {
      r();
      break;
    }
    (o == null ? void 0 : o.addEventListener) != null && o.addEventListener("abort", r);
  }
  function n() {
    for (const o of t)
      (o == null ? void 0 : o.removeEventListener) != null && o.removeEventListener("abort", r);
  }
  const i = e.signal;
  return i.clear = n, i;
}
function pDefer() {
  const t = {};
  return t.promise = new Promise((e, r) => {
    t.resolve = e, t.reject = r;
  }), t;
}
const log$m = logger$1("libp2p:connection-manager:utils");
async function resolveMultiaddrs(t, e) {
  if (!t.protoNames().includes("dnsaddr"))
    return [t];
  const n = await resolveRecord(t, e), a = (await Promise.all(n.map(async (c) => resolveMultiaddrs(c, e)))).flat().reduce((c, l) => (c.find((u) => u.equals(l)) == null && c.push(l), c), []);
  return log$m("resolved %s to", t, a.map((c) => c.toString())), a;
}
async function resolveRecord(t, e) {
  try {
    return t = multiaddr$1(t.toString()), await t.resolve(e);
  } catch (r) {
    return log$m.error(`multiaddr ${t.toString()} could not be resolved`, r), [];
  }
}
function combineSignals(...t) {
  var n, i;
  const e = [];
  for (const o of t)
    if (o != null) {
      try {
        (n = setMaxListeners) == null || n(1 / 0, o);
      } catch {
      }
      e.push(o);
    }
  const r = anySignal(e);
  try {
    (i = setMaxListeners) == null || i(1 / 0, r);
  } catch {
  }
  return r;
}
const log$l = logger$1("libp2p:connection-manager:dial-queue"), defaultOptions$1 = {
  addressSorter: publicAddressesFirst,
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  maxParallelDialsPerPeer: MAX_PARALLEL_DIALS_PER_PEER,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
class DialQueue {
  constructor(e, r = {}) {
    $(this, "pendingDials");
    $(this, "queue");
    $(this, "peerId");
    $(this, "peerStore");
    $(this, "connectionGater");
    $(this, "transportManager");
    $(this, "addressSorter");
    $(this, "maxPeerAddrsToDial");
    $(this, "maxParallelDialsPerPeer");
    $(this, "dialTimeout");
    $(this, "inProgressDialCount");
    $(this, "pendingDialCount");
    $(this, "shutDownController");
    var n, i, o;
    this.addressSorter = r.addressSorter ?? defaultOptions$1.addressSorter, this.maxPeerAddrsToDial = r.maxPeerAddrsToDial ?? defaultOptions$1.maxPeerAddrsToDial, this.maxParallelDialsPerPeer = r.maxParallelDialsPerPeer ?? defaultOptions$1.maxParallelDialsPerPeer, this.dialTimeout = r.dialTimeout ?? defaultOptions$1.dialTimeout, this.peerId = e.peerId, this.peerStore = e.peerStore, this.connectionGater = e.connectionGater, this.transportManager = e.transportManager, this.shutDownController = new AbortController();
    try {
      (n = setMaxListeners) == null || n(1 / 0, this.shutDownController.signal);
    } catch {
    }
    this.pendingDialCount = (i = e.metrics) == null ? void 0 : i.registerMetric("libp2p_dialler_pending_dials"), this.inProgressDialCount = (o = e.metrics) == null ? void 0 : o.registerMetric("libp2p_dialler_in_progress_dials"), this.pendingDials = [];
    for (const [a, c] of Object.entries(r.resolvers ?? {}))
      resolvers$1.set(a, c);
    this.queue = new PQueue({
      concurrency: r.maxParallelDials ?? defaultOptions$1.maxParallelDials
    }), this.queue.on("add", () => {
      var a, c;
      (a = this.pendingDialCount) == null || a.update(this.queue.size), (c = this.inProgressDialCount) == null || c.update(this.queue.pending);
    }), this.queue.on("active", () => {
      var a, c;
      (a = this.pendingDialCount) == null || a.update(this.queue.size), (c = this.inProgressDialCount) == null || c.update(this.queue.pending);
    }), this.queue.on("completed", () => {
      var a, c;
      (a = this.pendingDialCount) == null || a.update(this.queue.size), (c = this.inProgressDialCount) == null || c.update(this.queue.pending);
    }), this.queue.on("error", (a) => {
      var c, l;
      log$l.error("error in dial queue", a), (c = this.pendingDialCount) == null || c.update(this.queue.size), (l = this.inProgressDialCount) == null || l.update(this.queue.pending);
    }), this.queue.on("empty", () => {
      var a, c;
      (a = this.pendingDialCount) == null || a.update(this.queue.size), (c = this.inProgressDialCount) == null || c.update(this.queue.pending);
    }), this.queue.on("idle", () => {
      var a, c;
      (a = this.pendingDialCount) == null || a.update(this.queue.size), (c = this.inProgressDialCount) == null || c.update(this.queue.pending);
    });
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a connection
   * will be used, all other dials will be aborted when that happens.
   */
  async dial(e, r = {}) {
    const { peerId: n, multiaddrs: i } = getPeerAddress(e), o = i.map((f) => ({
      multiaddr: f,
      isCertified: !1
    })), a = this.createDialAbortControllers(r.signal);
    let c;
    try {
      c = await this.calculateMultiaddrs(n, o, {
        ...r,
        signal: a
      });
    } catch (f) {
      throw a.clear(), f;
    }
    const l = this.pendingDials.find((f) => !!(f.peerId != null && n != null && f.peerId.equals(n) || c.map(({ multiaddr: d }) => d.toString()).join() === f.multiaddrs.map((d) => d.toString()).join()));
    if (l != null)
      return log$l("joining existing dial target for %p", n), a.clear(), l.promise;
    log$l("creating dial target for", c.map(({ multiaddr: f }) => f.toString()));
    const u = {
      id: randomId(),
      status: "queued",
      peerId: n,
      multiaddrs: c.map(({ multiaddr: f }) => f)
    };
    return u.promise = this.performDial(u, {
      ...r,
      signal: a
    }).finally(() => {
      this.pendingDials = this.pendingDials.filter((f) => f.id !== u.id), a.clear();
    }).catch(async (f) => {
      if (log$l.error("dial failed to %s", u.multiaddrs.map((d) => d.toString()).join(", "), f), n != null)
        try {
          await this.peerStore.patch(n, {
            metadata: {
              [LAST_DIAL_FAILURE_KEY]: fromString$3(Date.now().toString())
            }
          });
        } catch (d) {
          log$l.error("could not update last dial failure key for %p", n, d);
        }
      throw a.aborted ? new CodeError$2(f.message, codes$1.ERR_TIMEOUT) : f;
    }), this.pendingDials.push(u), u.promise;
  }
  createDialAbortControllers(e) {
    var n;
    const r = anySignal([
      AbortSignal.timeout(this.dialTimeout),
      this.shutDownController.signal,
      e
    ]);
    try {
      (n = setMaxListeners) == null || n(1 / 0, r);
    } catch {
    }
    return r;
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(e, r = [], n = {}) {
    var f, d;
    if (e != null) {
      if (this.peerId.equals(e))
        throw new CodeError$2("Tried to dial self", codes$1.ERR_DIALED_SELF);
      if (await ((d = (f = this.connectionGater).denyDialPeer) == null ? void 0 : d.call(f, e)) === !0)
        throw new CodeError$2("The dial request is blocked by gater.allowDialPeer", codes$1.ERR_PEER_DIAL_INTERCEPTED);
      if (r.length === 0) {
        log$l("loading multiaddrs for %p", e);
        try {
          const p = await this.peerStore.get(e);
          r.push(...p.addresses), log$l("loaded multiaddrs for %p", e, r.map(({ multiaddr: g }) => g.toString()));
        } catch (p) {
          if (p.code !== codes$1.ERR_NOT_FOUND)
            throw p;
        }
      }
    }
    const i = (await Promise.all(r.map(async (p) => {
      const g = await resolveMultiaddrs(p.multiaddr, n);
      return g.length === 1 && g[0].equals(p.multiaddr) ? p : g.map((h) => ({
        multiaddr: h,
        isCertified: !1
      }));
    }))).flat(), o = i.filter((p) => {
      if (this.transportManager.transportForMultiaddr(p.multiaddr) == null)
        return !1;
      const g = p.multiaddr.getPeerId();
      return e != null && g != null ? e.equals(g) : !0;
    }), a = /* @__PURE__ */ new Map();
    for (const p of o) {
      const g = p.multiaddr.toString(), h = a.get(g);
      if (h != null) {
        h.isCertified = h.isCertified || p.isCertified || !1;
        continue;
      }
      a.set(g, p);
    }
    let c = [...a.values()];
    if ((c.length === 0 || c.length > this.maxPeerAddrsToDial) && (log$l("addresses for %p before filtering", e ?? "unknown peer", i.map(({ multiaddr: p }) => p.toString())), log$l("addresses for %p after filtering", e ?? "unknown peer", c.map(({ multiaddr: p }) => p.toString()))), c.length === 0)
      throw new CodeError$2("The dial request has no valid addresses", codes$1.ERR_NO_VALID_ADDRESSES);
    if (c.length > this.maxPeerAddrsToDial)
      throw new CodeError$2("dial with more addresses than allowed", codes$1.ERR_TOO_MANY_ADDRESSES);
    if (e != null) {
      const p = `/p2p/${e.toString()}`;
      c = c.map((g) => {
        const h = g.multiaddr.getPeerId(), m = g.multiaddr.protos().pop();
        return (m == null ? void 0 : m.path) === !0 ? g : h !== e.toString() ? {
          multiaddr: g.multiaddr.encapsulate(p),
          isCertified: g.isCertified
        } : g;
      });
    }
    const l = [];
    for (const p of c)
      this.connectionGater.denyDialMultiaddr != null && await this.connectionGater.denyDialMultiaddr(p.multiaddr) || l.push(p);
    const u = l.sort(this.addressSorter);
    if (u.length === 0)
      throw new CodeError$2("The connection gater denied all addresses in the dial request", codes$1.ERR_NO_VALID_ADDRESSES);
    return u;
  }
  async performDial(e, r = {}) {
    const n = e.multiaddrs.map(() => new AbortController());
    try {
      const i = new PQueue({
        concurrency: this.maxParallelDialsPerPeer
      });
      i.on("error", (a) => {
        log$l.error("error dialling", a);
      });
      const o = await Promise.any(e.multiaddrs.map(async (a, c) => {
        const l = n[c];
        if (l == null)
          throw new CodeError$2("dialAction did not come with an AbortController", codes$1.ERR_INVALID_PARAMETERS);
        const u = combineSignals(l.signal, r.signal);
        u.addEventListener("abort", () => {
          log$l("dial to %a aborted", a);
        });
        const f = pDefer();
        return await i.add(async () => {
          if (u.aborted) {
            log$l("dial to %a was aborted before reaching the head of the peer dial queue", a), f.reject(new AbortError$6());
            return;
          }
          await this.queue.add(async () => {
            try {
              if (u.aborted) {
                log$l("dial to %a was aborted before reaching the head of the dial queue", a), f.reject(new AbortError$6());
                return;
              }
              e.status = "active";
              const d = await this.transportManager.dial(a, {
                ...r,
                signal: u
              });
              if (l.signal.aborted) {
                log$l("multiple dials succeeded, closing superfluous connection"), d.close().catch((p) => {
                  log$l.error("error closing superfluous connection", p);
                }), f.reject(new AbortError$6());
                return;
              }
              n[c] = void 0, n.forEach((p) => {
                p !== void 0 && p.abort();
              }), log$l("dial to %a succeeded", a), f.resolve(d);
            } catch (d) {
              log$l.error("error during dial of %a", a, d), f.reject(d);
            }
          }, {
            ...r,
            signal: u
          }).catch((d) => {
            f.reject(d);
          });
        }, {
          signal: u
        }).catch((d) => {
          f.reject(d);
        }).finally(() => {
          u.clear();
        }), f.promise;
      }));
      if (o == null)
        throw new CodeError$2("successful dial led to empty object returned from peer dial queue", codes$1.ERR_TRANSPORT_DIAL_FAILED);
      return e.status = "success", o;
    } catch (i) {
      throw e.status = "error", e.multiaddrs.length === 1 && i.name === "AggregateError" ? i.errors[0] : i;
    }
  }
}
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
const log$k = logger$1("libp2p:connection-manager"), DEFAULT_DIAL_PRIORITY = 50, defaultOptions = {
  minConnections: MIN_CONNECTIONS,
  maxConnections: MAX_CONNECTIONS,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS,
  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
  autoDialPriority: AUTO_DIAL_PRIORITY,
  autoDialMaxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH
};
class DefaultConnectionManager {
  constructor(e, r = {}) {
    $(this, "started");
    $(this, "connections");
    $(this, "allow");
    $(this, "deny");
    $(this, "maxIncomingPendingConnections");
    $(this, "incomingPendingConnections");
    $(this, "maxConnections");
    $(this, "dialQueue");
    $(this, "autoDial");
    $(this, "connectionPruner");
    $(this, "inboundConnectionRateLimiter");
    $(this, "peerStore");
    $(this, "metrics");
    $(this, "events");
    this.maxConnections = r.maxConnections ?? defaultOptions.maxConnections;
    const n = r.minConnections ?? defaultOptions.minConnections;
    if (this.maxConnections < n)
      throw new CodeError$2("Connection Manager maxConnections must be greater than minConnections", codes$1.ERR_INVALID_PARAMETERS);
    this.connections = new PeerMap(), this.started = !1, this.peerStore = e.peerStore, this.metrics = e.metrics, this.events = e.events, this.onConnect = this.onConnect.bind(this), this.onDisconnect = this.onDisconnect.bind(this), this.events.addEventListener("connection:open", this.onConnect), this.events.addEventListener("connection:close", this.onDisconnect), this.allow = (r.allow ?? []).map((i) => multiaddr$1(i)), this.deny = (r.deny ?? []).map((i) => multiaddr$1(i)), this.incomingPendingConnections = 0, this.maxIncomingPendingConnections = r.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections, this.inboundConnectionRateLimiter = new rateLimiterFlexible.RateLimiterMemory({
      points: r.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,
      duration: 1
    }), this.autoDial = new AutoDial({
      connectionManager: this,
      peerStore: e.peerStore,
      events: e.events
    }, {
      minConnections: n,
      autoDialConcurrency: r.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,
      autoDialPriority: r.autoDialPriority ?? defaultOptions.autoDialPriority,
      maxQueueLength: r.autoDialMaxQueueLength ?? defaultOptions.autoDialMaxQueueLength
    }), this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: e.peerStore,
      events: e.events
    }, {
      maxConnections: this.maxConnections,
      allow: this.allow
    }), this.dialQueue = new DialQueue({
      peerId: e.peerId,
      metrics: e.metrics,
      peerStore: e.peerStore,
      transportManager: e.transportManager,
      connectionGater: e.connectionGater
    }, {
      addressSorter: r.addressSorter ?? publicAddressesFirst,
      maxParallelDials: r.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxPeerAddrsToDial: r.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: r.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: r.resolvers ?? {
        dnsaddr: dnsaddrResolver
      }
    });
  }
  isStarted() {
    return this.started;
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    var e, r, n;
    (e = this.metrics) == null || e.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const i = {
          inbound: 0,
          outbound: 0
        };
        for (const o of this.connections.values())
          for (const a of o)
            a.direction === "inbound" ? i.inbound++ : i.outbound++;
        return i;
      }
    }), (r = this.metrics) == null || r.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const i = {};
        for (const o of this.connections.values())
          for (const a of o)
            for (const c of a.streams) {
              const l = `${c.direction} ${c.protocol ?? "unnegotiated"}`;
              i[l] = (i[l] ?? 0) + 1;
            }
        return i;
      }
    }), (n = this.metrics) == null || n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const i = {};
        for (const a of this.connections.values())
          for (const c of a) {
            const l = {};
            for (const u of c.streams) {
              const f = `${u.direction} ${u.protocol ?? "unnegotiated"}`;
              l[f] = (l[f] ?? 0) + 1;
            }
            for (const [u, f] of Object.entries(l))
              i[u] = i[u] ?? [], i[u].push(f);
          }
        const o = {};
        for (let [a, c] of Object.entries(i)) {
          c = c.sort((u, f) => u - f);
          const l = Math.floor(c.length * 0.9);
          o[a] = c[l];
        }
        return o;
      }
    }), this.autoDial.start(), this.started = !0, log$k("started");
  }
  async afterStart() {
    Promise.resolve().then(async () => {
      const e = await this.peerStore.all({
        filters: [(r) => r.tags.has(KEEP_ALIVE)]
      });
      await Promise.all(e.map(async (r) => {
        await this.openConnection(r.id).catch((n) => {
          log$k.error(n);
        });
      }));
    }).catch((e) => {
      log$k.error(e);
    }), this.autoDial.afterStart();
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.dialQueue.stop(), this.autoDial.stop();
    const e = [];
    for (const r of this.connections.values())
      for (const n of r)
        e.push((async () => {
          try {
            await n.close();
          } catch (i) {
            log$k.error(i);
          }
        })());
    log$k("closing %d connections", e.length), await Promise.all(e), this.connections.clear(), log$k("stopped");
  }
  onConnect(e) {
    this._onConnect(e).catch((r) => {
      log$k.error(r);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(e) {
    const { detail: r } = e;
    if (!this.started) {
      await r.close();
      return;
    }
    const n = r.remotePeer, i = this.connections.get(n);
    let o = !1;
    i != null ? i.push(r) : (o = !0, this.connections.set(n, [r])), n.publicKey != null && n.type === "RSA" && await this.peerStore.patch(n, {
      publicKey: n.publicKey
    }), o && this.events.safeDispatchEvent("peer:connect", { detail: r.remotePeer });
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(e) {
    const { detail: r } = e;
    if (!this.started)
      return;
    const n = r.remotePeer;
    let i = this.connections.get(n);
    i != null && i.length > 1 ? (i = i.filter((o) => o.id !== r.id), this.connections.set(n, i)) : i != null && (this.connections.delete(n), this.events.safeDispatchEvent("peer:disconnect", { detail: r.remotePeer }));
  }
  getConnections(e) {
    if (e != null)
      return this.connections.get(e) ?? [];
    let r = [];
    for (const n of this.connections.values())
      r = r.concat(n);
    return r;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(e, r = {}) {
    var c;
    if (!this.isStarted())
      throw new CodeError$2("Not started", codes$1.ERR_NODE_NOT_STARTED);
    (c = r.signal) == null || c.throwIfAborted();
    const { peerId: n } = getPeerAddress(e);
    if (n != null && r.force !== !0) {
      log$k("dial %p", n);
      const l = this.getConnections(n);
      if (l.length > 0)
        return log$k("had an existing connection to %p", n), l[0];
    }
    const i = await this.dialQueue.dial(e, {
      ...r,
      priority: r.priority ?? DEFAULT_DIAL_PRIORITY
    });
    let o = this.connections.get(i.remotePeer);
    o == null && (o = [], this.connections.set(i.remotePeer, o));
    let a = !1;
    for (const l of o)
      l.id === i.id && (a = !0);
    return a || o.push(i), i;
  }
  async closeConnections(e, r = {}) {
    const n = this.connections.get(e) ?? [];
    await Promise.all(n.map(async (i) => {
      try {
        await i.close(r);
      } catch (o) {
        i.abort(o);
      }
    }));
  }
  async acceptIncomingConnection(e) {
    if (this.deny.some((i) => e.remoteAddr.toString().startsWith(i.toString())))
      return log$k("connection from %a refused - connection remote address was in deny list", e.remoteAddr), !1;
    if (this.allow.some((i) => e.remoteAddr.toString().startsWith(i.toString())))
      return this.incomingPendingConnections++, !0;
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections)
      return log$k("connection from %a refused - incomingPendingConnections exceeded by host", e.remoteAddr), !1;
    if (e.remoteAddr.isThinWaistAddress()) {
      const i = e.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(i, 1);
      } catch {
        return log$k("connection from %a refused - inboundConnectionThreshold exceeded by host %s", e.remoteAddr, i), !1;
      }
    }
    return this.getConnections().length < this.maxConnections ? (this.incomingPendingConnections++, !0) : (log$k("connection from %a refused - maxConnections exceeded", e.remoteAddr), !1);
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    return this.dialQueue.pendingDials;
  }
}
function isAsyncIterable$9(t) {
  return t[Symbol.asyncIterator] != null;
}
function merge$5(...t) {
  const e = [];
  for (const r of t)
    isAsyncIterable$9(r) || e.push(r);
  return e.length === t.length ? function* () {
    for (const r of e)
      yield* r;
  }() : async function* () {
    const r = pushable$1({
      objectMode: !0
    });
    Promise.resolve().then(async () => {
      try {
        await Promise.all(t.map(async (n) => {
          for await (const i of n)
            r.push(i);
        })), r.end();
      } catch (n) {
        r.end(n);
      }
    }), yield* r;
  }();
}
class FixedFIFO {
  constructor(e) {
    $(this, "buffer");
    $(this, "mask");
    $(this, "top");
    $(this, "btm");
    $(this, "next");
    if (!(e > 0) || e - 1 & e)
      throw new Error("Max size for a FixedFIFO should be a power of two");
    this.buffer = new Array(e), this.mask = e - 1, this.top = 0, this.btm = 0, this.next = null;
  }
  push(e) {
    return this.buffer[this.top] !== void 0 ? !1 : (this.buffer[this.top] = e, this.top = this.top + 1 & this.mask, !0);
  }
  shift() {
    const e = this.buffer[this.btm];
    if (e !== void 0)
      return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, e;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
}
class FIFO {
  constructor(e = {}) {
    $(this, "size");
    $(this, "hwm");
    $(this, "head");
    $(this, "tail");
    this.hwm = e.splitLimit ?? 16, this.head = new FixedFIFO(this.hwm), this.tail = this.head, this.size = 0;
  }
  calculateSize(e) {
    return (e == null ? void 0 : e.byteLength) != null ? e.byteLength : 1;
  }
  push(e) {
    if ((e == null ? void 0 : e.value) != null && (this.size += this.calculateSize(e.value)), !this.head.push(e)) {
      const r = this.head;
      this.head = r.next = new FixedFIFO(2 * this.head.buffer.length), this.head.push(e);
    }
  }
  shift() {
    let e = this.tail.shift();
    if (e === void 0 && this.tail.next != null) {
      const r = this.tail.next;
      this.tail.next = null, this.tail = r, e = this.tail.shift();
    }
    return (e == null ? void 0 : e.value) != null && (this.size -= this.calculateSize(e.value)), e;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
}
let AbortError$2 = class extends Error {
  constructor(r, n) {
    super(r ?? "The operation was aborted");
    $(this, "type");
    $(this, "code");
    this.type = "aborted", this.code = n ?? "ABORT_ERR";
  }
};
function pushable(t = {}) {
  return _pushable((r) => {
    const n = r.shift();
    if (n == null)
      return { done: !0 };
    if (n.error != null)
      throw n.error;
    return {
      done: n.done === !0,
      // @ts-expect-error if done is false, value will be present
      value: n.value
    };
  }, t);
}
function _pushable(t, e) {
  e = e ?? {};
  let r = e.onEnd, n = new FIFO(), i, o, a, c = pDefer();
  const l = async () => {
    try {
      return n.isEmpty() ? a ? { done: !0 } : await new Promise((y, b) => {
        o = (v) => {
          o = null, n.push(v);
          try {
            y(t(n));
          } catch (_) {
            b(_);
          }
          return i;
        };
      }) : t(n);
    } finally {
      n.isEmpty() && queueMicrotask(() => {
        c.resolve(), c = pDefer();
      });
    }
  }, u = (y) => o != null ? o(y) : (n.push(y), i), f = (y) => (n = new FIFO(), o != null ? o({ error: y }) : (n.push({ error: y }), i)), d = (y) => {
    if (a)
      return i;
    if ((e == null ? void 0 : e.objectMode) !== !0 && (y == null ? void 0 : y.byteLength) == null)
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    return u({ done: !1, value: y });
  }, p = (y) => a ? i : (a = !0, y != null ? f(y) : u({ done: !0 })), g = () => (n = new FIFO(), p(), { done: !0 }), h = (y) => (p(y), { done: !0 });
  if (i = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: l,
    return: g,
    throw: h,
    push: d,
    end: p,
    get readableLength() {
      return n.size;
    },
    onEmpty: async (y) => {
      const b = y == null ? void 0 : y.signal;
      if (b == null || b.throwIfAborted(), n.isEmpty())
        return;
      let v, _;
      b != null && (v = new Promise((E, w) => {
        _ = () => {
          w(new AbortError$2());
        }, b.addEventListener("abort", _);
      }));
      try {
        await Promise.race([
          c.promise,
          v
        ]);
      } finally {
        _ != null && b != null && (b == null || b.removeEventListener("abort", _));
      }
    }
  }, r == null)
    return i;
  const m = i;
  return i = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return m.next();
    },
    throw(y) {
      return m.throw(y), r != null && (r(y), r = void 0), { done: !0 };
    },
    return() {
      return m.return(), r != null && (r(), r = void 0), { done: !0 };
    },
    push: d,
    end(y) {
      return m.end(y), r != null && (r(y), r = void 0), i;
    },
    get readableLength() {
      return m.readableLength;
    }
  }, i;
}
function isAsyncIterable$8(t) {
  return t[Symbol.asyncIterator] != null;
}
function merge$4(...t) {
  const e = [];
  for (const r of t)
    isAsyncIterable$8(r) || e.push(r);
  return e.length === t.length ? function* () {
    for (const r of e)
      yield* r;
  }() : async function* () {
    const r = pushable({
      objectMode: !0
    });
    Promise.resolve().then(async () => {
      try {
        await Promise.all(t.map(async (n) => {
          for await (const i of n)
            r.push(i);
        })), r.end();
      } catch (n) {
        r.end(n);
      }
    }), yield* r;
  }();
}
function pipe$2(t, ...e) {
  if (t == null)
    throw new Error("Empty pipeline");
  if (isDuplex(t)) {
    const n = t;
    t = () => n.source;
  } else if (isIterable$2(t) || isAsyncIterable$7(t)) {
    const n = t;
    t = () => n;
  }
  const r = [t, ...e];
  if (r.length > 1 && isDuplex(r[r.length - 1]) && (r[r.length - 1] = r[r.length - 1].sink), r.length > 2)
    for (let n = 1; n < r.length - 1; n++)
      isDuplex(r[n]) && (r[n] = duplexPipelineFn(r[n]));
  return rawPipe(...r);
}
const rawPipe = (...t) => {
  let e;
  for (; t.length > 0; )
    e = t.shift()(e);
  return e;
}, isAsyncIterable$7 = (t) => (t == null ? void 0 : t[Symbol.asyncIterator]) != null, isIterable$2 = (t) => (t == null ? void 0 : t[Symbol.iterator]) != null, isDuplex = (t) => t == null ? !1 : t.sink != null && t.source != null, duplexPipelineFn = (t) => (e) => {
  const r = t.sink(e);
  if ((r == null ? void 0 : r.then) != null) {
    const n = pushable({
      objectMode: !0
    });
    r.then(() => {
      n.end();
    }, (a) => {
      n.end(a);
    });
    let i;
    const o = t.source;
    if (isAsyncIterable$7(o))
      i = async function* () {
        yield* o, n.end();
      };
    else if (isIterable$2(o))
      i = function* () {
        yield* o, n.end();
      };
    else
      throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
    return merge$4(n, i());
  }
  return t.source;
};
function isAsyncIterable$6(t) {
  return t[Symbol.asyncIterator] != null;
}
function map$4(t, e) {
  if (isAsyncIterable$6(t))
    return async function* () {
      for await (const c of t)
        yield e(c);
    }();
  const r = peekable(t), { value: n, done: i } = r.next();
  if (i === !0)
    return function* () {
    }();
  const o = e(n);
  if (typeof o.then == "function")
    return async function* () {
      yield await o;
      for await (const c of r)
        yield e(c);
    }();
  const a = e;
  return function* () {
    yield o;
    for (const c of r)
      yield a(c);
  }();
}
async function* storeAddresses(t, e) {
  yield* map$4(t, async (r) => (await e.merge(r.id, {
    multiaddrs: r.multiaddrs
  }), r));
}
function uniquePeers(t) {
  const e = /* @__PURE__ */ new Set();
  return filter$2(t, (r) => e.has(r.id.toString()) ? !1 : (e.add(r.id.toString()), !0));
}
async function* requirePeers(t, e = 1) {
  let r = 0;
  for await (const n of t)
    r++, yield n;
  if (r < e)
    throw new CodeError$2(`more peers required, seen: ${r}  min: ${e}`, "NOT_FOUND");
}
class CompoundContentRouting {
  constructor(e, r) {
    $(this, "routers");
    $(this, "started");
    $(this, "components");
    this.routers = r.routers ?? [], this.started = !1, this.components = e;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = !0;
  }
  async stop() {
    this.started = !1;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(e, r = {}) {
    if (this.routers.length === 0)
      throw new CodeError$2("No content routers available", codes$1.ERR_NO_ROUTERS_AVAILABLE);
    yield* pipe$2(merge$5(...this.routers.map((n) => n.findProviders(e, r))), (n) => storeAddresses(n, this.components.peerStore), (n) => uniquePeers(n), (n) => requirePeers(n));
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(e, r = {}) {
    if (this.routers.length === 0)
      throw new CodeError$2("No content routers available", codes$1.ERR_NO_ROUTERS_AVAILABLE);
    await Promise.all(this.routers.map(async (n) => {
      await n.provide(e, r);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(e, r, n) {
    if (!this.isStarted())
      throw new CodeError$2(messages.NOT_STARTED_YET, codes$1.DHT_NOT_STARTED);
    await Promise.all(this.routers.map(async (i) => {
      await i.put(e, r, n);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(e, r) {
    if (!this.isStarted())
      throw new CodeError$2(messages.NOT_STARTED_YET, codes$1.DHT_NOT_STARTED);
    return Promise.any(this.routers.map(async (n) => n.get(e, r)));
  }
}
function isAsyncIterable$5(t) {
  return t[Symbol.asyncIterator] != null;
}
function first$2(t) {
  if (isAsyncIterable$5(t))
    return (async () => {
      for await (const e of t)
        return e;
    })();
  for (const e of t)
    return e;
}
const log$j = logger$1("libp2p:peer-routing");
class DefaultPeerRouting {
  constructor(e, r) {
    $(this, "components");
    $(this, "routers");
    this.components = e, this.routers = r.routers ?? [];
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(e, r) {
    if (this.routers.length === 0)
      throw new CodeError$2("No peer routers available", codes$1.ERR_NO_ROUTERS_AVAILABLE);
    if (e.toString() === this.components.peerId.toString())
      throw new CodeError$2("Should not try to find self", codes$1.ERR_FIND_SELF);
    const n = await pipe$2(merge$5(...this.routers.map((i) => async function* () {
      try {
        yield await i.findPeer(e, r);
      } catch (o) {
        log$j.error(o);
      }
    }())), (i) => filter$2(i, Boolean), (i) => storeAddresses(i, this.components.peerStore), async (i) => first$2(i));
    if (n != null)
      return n;
    throw new CodeError$2(messages.NOT_FOUND, codes$1.ERR_NOT_FOUND);
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(e, r) {
    if (this.routers.length === 0)
      throw new CodeError$2("No peer routers available", codes$1.ERR_NO_ROUTERS_AVAILABLE);
    yield* pipe$2(merge$5(...this.routers.map((n) => n.getClosestPeers(e, r))), (n) => storeAddresses(n, this.components.peerStore), (n) => uniquePeers(n), (n) => requirePeers(n));
  }
}
const log$i = logger$1("libp2p:registrar"), DEFAULT_MAX_INBOUND_STREAMS = 32, DEFAULT_MAX_OUTBOUND_STREAMS = 64;
class DefaultRegistrar {
  constructor(e) {
    $(this, "topologies");
    $(this, "handlers");
    $(this, "components");
    this.topologies = /* @__PURE__ */ new Map(), this.handlers = /* @__PURE__ */ new Map(), this.components = e, this._onDisconnect = this._onDisconnect.bind(this), this._onPeerUpdate = this._onPeerUpdate.bind(this), this._onConnect = this._onConnect.bind(this), this.components.events.addEventListener("peer:disconnect", this._onDisconnect), this.components.events.addEventListener("peer:connect", this._onConnect), this.components.events.addEventListener("peer:update", this._onPeerUpdate);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(e) {
    const r = this.handlers.get(e);
    if (r == null)
      throw new CodeError$2(`No handler registered for protocol ${e}`, codes$1.ERR_NO_HANDLER_FOR_PROTOCOL);
    return r;
  }
  getTopologies(e) {
    const r = this.topologies.get(e);
    return r == null ? [] : [
      ...r.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(e, r, n) {
    if (this.handlers.has(e))
      throw new CodeError$2(`Handler already registered for protocol ${e}`, codes$1.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
    const i = mergeOptions.bind({ ignoreUndefined: !0 })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
    }, n);
    this.handlers.set(e, {
      handler: r,
      options: i
    }), await this.components.peerStore.merge(this.components.peerId, {
      protocols: [e]
    });
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(e) {
    const r = Array.isArray(e) ? e : [e];
    r.forEach((n) => {
      this.handlers.delete(n);
    }), await this.components.peerStore.patch(this.components.peerId, {
      protocols: r
    });
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(e, r) {
    if (r == null)
      throw new CodeError$2("invalid topology", codes$1.ERR_INVALID_PARAMETERS);
    const n = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let i = this.topologies.get(e);
    return i == null && (i = /* @__PURE__ */ new Map(), this.topologies.set(e, i)), i.set(n, r), n;
  }
  /**
   * Unregister topology
   */
  unregister(e) {
    for (const [r, n] of this.topologies.entries())
      n.has(e) && (n.delete(e), n.size === 0 && this.topologies.delete(r));
  }
  /**
   * Remove a disconnected peer from the record
   */
  _onDisconnect(e) {
    const r = e.detail;
    this.components.peerStore.get(r).then((n) => {
      var i;
      for (const o of n.protocols) {
        const a = this.topologies.get(o);
        if (a != null)
          for (const c of a.values())
            (i = c.onDisconnect) == null || i.call(c, r);
      }
    }).catch((n) => {
      n.code !== codes$1.ERR_NOT_FOUND && log$i.error("could not inform topologies of disconnecting peer %p", r, n);
    });
  }
  /**
   * On peer connected if we already have their protocols. Usually used for reconnects
   * as change:protocols event won't be emitted due to identical protocols.
   */
  _onConnect(e) {
    const r = e.detail;
    this.components.peerStore.get(r).then((n) => {
      var o;
      const i = this.components.connectionManager.getConnections(n.id)[0];
      if (i == null) {
        log$i("peer %p connected but the connection manager did not have a connection", n);
        return;
      }
      for (const a of n.protocols) {
        const c = this.topologies.get(a);
        if (c != null)
          for (const l of c.values())
            (o = l.onConnect) == null || o.call(l, r, i);
      }
    }).catch((n) => {
      n.code !== codes$1.ERR_NOT_FOUND && log$i.error("could not inform topologies of connecting peer %p", r, n);
    });
  }
  /**
   * Check if a new peer support the multicodecs for this topology
   */
  _onPeerUpdate(e) {
    var a, c;
    const { peer: r, previous: n } = e.detail, i = ((n == null ? void 0 : n.protocols) ?? []).filter((l) => !r.protocols.includes(l)), o = r.protocols.filter((l) => !((n == null ? void 0 : n.protocols) ?? []).includes(l));
    for (const l of i) {
      const u = this.topologies.get(l);
      if (u != null)
        for (const f of u.values())
          (a = f.onDisconnect) == null || a.call(f, r.id);
    }
    for (const l of o) {
      const u = this.topologies.get(l);
      if (u != null)
        for (const f of u.values()) {
          const d = this.components.connectionManager.getConnections(r.id)[0];
          d != null && ((c = f.onConnect) == null || c.call(f, r.id, d));
        }
    }
  }
}
class TrackedMap extends Map {
  constructor(r) {
    super();
    $(this, "metric");
    const { name: n, metrics: i } = r;
    this.metric = i.registerMetric(n), this.updateComponentMetric();
  }
  set(r, n) {
    return super.set(r, n), this.updateComponentMetric(), this;
  }
  delete(r) {
    const n = super.delete(r);
    return this.updateComponentMetric(), n;
  }
  clear() {
    super.clear(), this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
}
function trackedMap(t) {
  const { name: e, metrics: r } = t;
  let n;
  return r != null ? n = new TrackedMap({ name: e, metrics: r }) : n = /* @__PURE__ */ new Map(), n;
}
const log$h = logger$1("libp2p:transports");
class DefaultTransportManager {
  constructor(e, r = {}) {
    $(this, "components");
    $(this, "transports");
    $(this, "listeners");
    $(this, "faultTolerance");
    $(this, "started");
    this.components = e, this.started = !1, this.transports = /* @__PURE__ */ new Map(), this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    }), this.faultTolerance = r.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  /**
   * Adds a `Transport` to the manager
   */
  add(e) {
    const r = e[Symbol.toStringTag];
    if (r == null)
      throw new CodeError$2("Transport must have a valid tag", codes$1.ERR_INVALID_KEY);
    if (this.transports.has(r))
      throw new CodeError$2(`There is already a transport with the tag ${r}`, codes$1.ERR_DUPLICATE_TRANSPORT);
    log$h("adding transport %s", r), this.transports.set(r, e), this.listeners.has(r) || this.listeners.set(r, []);
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = !0;
  }
  async afterStart() {
    const e = this.components.addressManager.getListenAddrs();
    await this.listen(e);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const e = [];
    for (const [r, n] of this.listeners)
      for (log$h("closing listeners for %s", r); n.length > 0; ) {
        const i = n.pop();
        i != null && e.push(i.close());
      }
    await Promise.all(e), log$h("all listeners closed");
    for (const r of this.listeners.keys())
      this.listeners.set(r, []);
    this.started = !1;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(e, r) {
    const n = this.transportForMultiaddr(e);
    if (n == null)
      throw new CodeError$2(`No transport available for address ${String(e)}`, codes$1.ERR_TRANSPORT_UNAVAILABLE);
    try {
      return await n.dial(e, {
        ...r,
        upgrader: this.components.upgrader
      });
    } catch (i) {
      throw i.code == null && (i.code = codes$1.ERR_TRANSPORT_DIAL_FAILED), i;
    }
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let e = [];
    for (const r of this.listeners.values())
      for (const n of r)
        e = [...e, ...n.getAddrs()];
    return e;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  transportForMultiaddr(e) {
    for (const r of this.transports.values())
      if (r.filter([e]).length > 0)
        return r;
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(e) {
    if (!this.isStarted())
      throw new CodeError$2("Not started", codes$1.ERR_NODE_NOT_STARTED);
    if (e == null || e.length === 0) {
      log$h("no addresses were provided for listening, this node is dial only");
      return;
    }
    const r = [];
    for (const [n, i] of this.transports.entries()) {
      const o = i.filter(e), a = [];
      for (const u of o) {
        log$h("creating listener for %s on %a", n, u);
        const f = i.createListener({
          upgrader: this.components.upgrader
        });
        let d = this.listeners.get(n) ?? [];
        d == null && (d = [], this.listeners.set(n, d)), d.push(f), f.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: f
          });
        }), f.addEventListener("close", () => {
          const p = d.findIndex((g) => g === f);
          d.splice(p, 1), this.components.events.safeDispatchEvent("transport:close", {
            detail: f
          });
        }), a.push(f.listen(u));
      }
      if (a.length === 0) {
        r.push(n);
        continue;
      }
      if ((await Promise.allSettled(a)).find((u) => u.status === "fulfilled") == null && this.faultTolerance !== FaultTolerance.NO_FATAL)
        throw new CodeError$2(`Transport (${n}) could not listen on any available address`, codes$1.ERR_NO_VALID_ADDRESSES);
    }
    if (r.length === this.transports.size) {
      const n = `no valid addresses were provided for transports [${r.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL)
        throw new CodeError$2(n, codes$1.ERR_NO_VALID_ADDRESSES);
      log$h(`libp2p in dial mode only: ${n}`);
    }
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(e) {
    log$h("removing %s", e);
    for (const r of this.listeners.get(e) ?? [])
      await r.close();
    this.transports.delete(e), this.listeners.delete(e);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const e = [];
    for (const r of this.transports.keys())
      e.push(this.remove(r));
    await Promise.all(e);
  }
}
const PROTOCOL_ID = "/multistream/1.0.0", MAX_PROTOCOL_LENGTH = 1024;
function reader(t) {
  const e = async function* () {
    let r = yield, n = new Uint8ArrayList();
    for await (const i of t) {
      if (r == null) {
        n.append(i), r = yield n, n = new Uint8ArrayList();
        continue;
      }
      for (n.append(i); n.length >= r; ) {
        const o = n.sublist(0, r);
        if (n.consume(r), r = yield o, r == null) {
          n.length > 0 && (r = yield n, n = new Uint8ArrayList());
          break;
        }
      }
    }
    if (r != null)
      throw Object.assign(new Error(`stream ended before ${r} bytes became available`), { code: "ERR_UNDER_READ", buffer: n });
  }();
  return e.next(), e;
}
function handshake(t) {
  const e = pushable$1(), r = reader(t.source), n = pDefer();
  let i;
  const o = t.sink(async function* () {
    yield* e, yield* await n.promise;
  }());
  return o.catch((c) => {
    i = c;
  }), {
    reader: r,
    writer: e,
    stream: {
      sink: async (c) => {
        if (i != null) {
          await Promise.reject(i);
          return;
        }
        n.resolve(c), await o;
      },
      source: r
    },
    rest: () => e.end(),
    write: e.push,
    read: async () => {
      const c = await r.next();
      if (c.value != null)
        return c.value;
    }
  };
}
let AbortError$1 = class extends Error {
  constructor(e, r) {
    super(e ?? "The operation was aborted"), this.type = "aborted", this.code = r ?? "ABORT_ERR";
  }
};
function getIterator(t) {
  if (t != null) {
    if (typeof t[Symbol.iterator] == "function")
      return t[Symbol.iterator]();
    if (typeof t[Symbol.asyncIterator] == "function")
      return t[Symbol.asyncIterator]();
    if (typeof t.next == "function")
      return t;
  }
  throw new Error("argument is not an iterator or iterable");
}
function abortableSource(t, e, r) {
  const n = r ?? {}, i = getIterator(t);
  async function* o() {
    let a;
    const c = () => {
      a != null && a();
    };
    for (e.addEventListener("abort", c); ; ) {
      let l;
      try {
        if (e.aborted) {
          const { abortMessage: f, abortCode: d } = n;
          throw new AbortError$1(f, d);
        }
        const u = new Promise((f, d) => {
          a = () => {
            const { abortMessage: p, abortCode: g } = n;
            d(new AbortError$1(p, g));
          };
        });
        l = await Promise.race([u, i.next()]), a = null;
      } catch (u) {
        e.removeEventListener("abort", c);
        const f = u.type === "aborted" && e.aborted;
        if (f && n.onAbort != null && n.onAbort(t), typeof i.return == "function")
          try {
            const d = i.return();
            d instanceof Promise && d.catch((p) => {
              n.onReturnError != null && n.onReturnError(p);
            });
          } catch (d) {
            n.onReturnError != null && n.onReturnError(d);
          }
        if (f && n.returnOnAbort === !0)
          return;
        throw u;
      }
      if (l.done === !0)
        break;
      yield l.value;
    }
    e.removeEventListener("abort", c);
  }
  return o();
}
function abortableSink(t, e, r) {
  return (n) => t(abortableSource(n, e, r));
}
function abortableDuplex(t, e, r) {
  return {
    sink: abortableSink(t.sink, e, {
      ...r,
      onAbort: void 0
    }),
    source: abortableSource(t.source, e, r)
  };
}
function isAsyncIterable$4(t) {
  return t[Symbol.asyncIterator] != null;
}
const defaultEncoder = (t) => {
  const e = unsigned.encodingLength(t), r = allocUnsafe$3(e);
  return unsigned.encode(t, r), defaultEncoder.bytes = e, r;
};
defaultEncoder.bytes = 0;
function encode$3(t, e) {
  e = e ?? {};
  const r = e.lengthEncoder ?? defaultEncoder;
  function* n(i) {
    const o = r(i.byteLength);
    o instanceof Uint8Array ? yield o : yield* o, i instanceof Uint8Array ? yield i : yield* i;
  }
  return isAsyncIterable$4(t) ? async function* () {
    for await (const i of t)
      yield* n(i);
  }() : function* () {
    for (const i of t)
      yield* n(i);
  }();
}
encode$3.single = (t, e) => {
  e = e ?? {};
  const r = e.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(r(t.byteLength), t);
};
const MAX_LENGTH_LENGTH$1 = 8, MAX_DATA_LENGTH$1 = 1024 * 1024 * 4;
var ReadMode$1;
(function(t) {
  t[t.LENGTH = 0] = "LENGTH", t[t.DATA = 1] = "DATA";
})(ReadMode$1 || (ReadMode$1 = {}));
const defaultDecoder$1 = (t) => {
  const e = unsigned.decode(t);
  return defaultDecoder$1.bytes = unsigned.encodingLength(e), e;
};
defaultDecoder$1.bytes = 0;
function decode$3(t, e) {
  const r = new Uint8ArrayList();
  let n = ReadMode$1.LENGTH, i = -1;
  const o = (e == null ? void 0 : e.lengthDecoder) ?? defaultDecoder$1, a = (e == null ? void 0 : e.maxLengthLength) ?? MAX_LENGTH_LENGTH$1, c = (e == null ? void 0 : e.maxDataLength) ?? MAX_DATA_LENGTH$1;
  function* l() {
    for (; r.byteLength > 0; ) {
      if (n === ReadMode$1.LENGTH)
        try {
          if (i = o(r), i < 0)
            throw errCode(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
          if (i > c)
            throw errCode(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
          const u = o.bytes;
          r.consume(u), (e == null ? void 0 : e.onLength) != null && e.onLength(i), n = ReadMode$1.DATA;
        } catch (u) {
          if (u instanceof RangeError) {
            if (r.byteLength > a)
              throw errCode(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
            break;
          }
          throw u;
        }
      if (n === ReadMode$1.DATA) {
        if (r.byteLength < i)
          break;
        const u = r.sublist(0, i);
        r.consume(i), (e == null ? void 0 : e.onData) != null && e.onData(u), yield u, n = ReadMode$1.LENGTH;
      }
    }
  }
  return isAsyncIterable$4(t) ? async function* () {
    for await (const u of t)
      r.append(u), yield* l();
    if (r.byteLength > 0)
      throw errCode(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
  }() : function* () {
    for (const u of t)
      r.append(u), yield* l();
    if (r.byteLength > 0)
      throw errCode(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
  }();
}
decode$3.fromReader = (t, e) => {
  let r = 1;
  const n = async function* () {
    for (; ; )
      try {
        const { done: o, value: a } = await t.next(r);
        if (o === !0)
          return;
        a != null && (yield a);
      } catch (o) {
        if (o.code === "ERR_UNDER_READ")
          return { done: !0, value: null };
        throw o;
      } finally {
        r = 1;
      }
  }();
  return decode$3(n, {
    ...e ?? {},
    onLength: (o) => {
      r = o;
    }
  });
};
const log$g = logger$1("libp2p:mss"), NewLine = fromString$3(`
`);
function encode$2(t) {
  const e = new Uint8ArrayList(t, NewLine);
  return encode$3.single(e);
}
function write(t, e, r = {}) {
  const n = encode$2(e);
  r.writeBytes === !0 ? t.push(n.subarray()) : t.push(n);
}
function writeAll(t, e, r = {}) {
  const n = new Uint8ArrayList();
  for (const i of e)
    n.append(encode$2(i));
  r.writeBytes === !0 ? t.push(n.subarray()) : t.push(n);
}
async function read$1(t, e) {
  let r = 1;
  const n = {
    [Symbol.asyncIterator]: () => n,
    next: async () => t.next(r)
  };
  let i = n;
  (e == null ? void 0 : e.signal) != null && (i = abortableSource(n, e.signal));
  const o = (c) => {
    r = c;
  }, a = await pipe$2(i, (c) => decode$3(c, { onLength: o, maxDataLength: MAX_PROTOCOL_LENGTH }), async (c) => first$2(c));
  if (a == null || a.length === 0)
    throw new CodeError$2("no buffer returned", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  if (a.get(a.byteLength - 1) !== NewLine[0])
    throw log$g.error("Invalid mss message - missing newline - %s", a.subarray()), new CodeError$2("missing newline", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  return a.sublist(0, -1);
}
async function readString(t, e) {
  const r = await read$1(t, e);
  return toString$4(r.subarray());
}
const log$f = logger$1("libp2p:mss:select");
async function select(t, e, r = {}) {
  e = Array.isArray(e) ? [...e] : [e];
  const { reader: n, writer: i, rest: o, stream: a } = handshake(t), c = e.shift();
  if (c == null)
    throw new Error("At least one protocol must be specified");
  log$f.trace('select: write ["%s", "%s"]', PROTOCOL_ID, c);
  const l = fromString$3(PROTOCOL_ID), u = fromString$3(c);
  writeAll(i, [l, u], r);
  let f = await readString(n, r);
  if (log$f.trace('select: read "%s"', f), f === PROTOCOL_ID && (f = await readString(n, r), log$f.trace('select: read "%s"', f)), f === c)
    return o(), { stream: a, protocol: c };
  for (const d of e) {
    log$f.trace('select: write "%s"', d), write(i, fromString$3(d), r);
    const p = await readString(n, r);
    if (log$f.trace('select: read "%s" for "%s"', p, d), p === d)
      return o(), { stream: a, protocol: d };
  }
  throw o(), new CodeError$2("protocol selection failed", "ERR_UNSUPPORTED_PROTOCOL");
}
const log$e = logger$1("libp2p:mss:handle");
async function handle(t, e, r) {
  e = Array.isArray(e) ? e : [e];
  const { writer: n, reader: i, rest: o, stream: a } = handshake(t);
  for (; ; ) {
    const c = await readString(i, r);
    if (log$e.trace('read "%s"', c), c === PROTOCOL_ID) {
      log$e.trace('respond with "%s" for "%s"', PROTOCOL_ID, c), write(n, fromString$3(PROTOCOL_ID), r);
      continue;
    }
    if (e.includes(c))
      return write(n, fromString$3(c), r), log$e.trace('respond with "%s" for "%s"', c, c), o(), { stream: a, protocol: c };
    if (c === "ls") {
      write(n, new Uint8ArrayList(...e.map((l) => encode$2(fromString$3(l)))), r), log$e.trace('respond with "%s" for %s', e, c);
      continue;
    }
    write(n, fromString$3("na"), r), log$e('respond with "na" for "%s"', c);
  }
}
const symbol$1 = Symbol.for("@libp2p/connection"), log$d = logger$1("libp2p:connection"), CLOSE_TIMEOUT$2 = 500;
var cn, un;
class ConnectionImpl {
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   */
  constructor(e) {
    /**
     * Connection identifier.
     */
    $(this, "id");
    /**
     * Observed multiaddr of the remote peer
     */
    $(this, "remoteAddr");
    /**
     * Remote peer id
     */
    $(this, "remotePeer");
    $(this, "direction");
    $(this, "timeline");
    $(this, "multiplexer");
    $(this, "encryption");
    $(this, "status");
    $(this, "transient");
    /**
     * User provided tags
     *
     */
    $(this, "tags");
    /**
     * Reference to the new stream function of the multiplexer
     */
    $(this, "_newStream");
    /**
     * Reference to the close function of the raw connection
     */
    $(this, "_close");
    $(this, "_abort");
    /**
     * Reference to the getStreams function of the muxer
     */
    $(this, "_getStreams");
    $(this, cn, "Connection");
    $(this, un, !0);
    const { remoteAddr: r, remotePeer: n, newStream: i, close: o, abort: a, getStreams: c } = e;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`, this.remoteAddr = r, this.remotePeer = n, this.direction = e.direction, this.status = "open", this.timeline = e.timeline, this.multiplexer = e.multiplexer, this.encryption = e.encryption, this.transient = e.transient ?? !1, this._newStream = i, this._close = o, this._abort = a, this._getStreams = c, this.tags = [];
  }
  /**
   * Get all the streams of the muxer
   */
  get streams() {
    return this._getStreams();
  }
  /**
   * Create a new stream from this connection
   */
  async newStream(e, r) {
    if (this.status === "closing")
      throw new CodeError$2("the connection is being closed", "ERR_CONNECTION_BEING_CLOSED");
    if (this.status === "closed")
      throw new CodeError$2("the connection is closed", "ERR_CONNECTION_CLOSED");
    if (Array.isArray(e) || (e = [e]), this.transient && (r == null ? void 0 : r.runOnTransientConnection) !== !0)
      throw new CodeError$2("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
    const n = await this._newStream(e, r);
    return n.direction = "outbound", n;
  }
  /**
   * Close the connection
   */
  async close(e = {}) {
    var r;
    if (!(this.status === "closed" || this.status === "closing")) {
      log$d("closing connection to %a", this.remoteAddr), this.status = "closing", e.signal = (e == null ? void 0 : e.signal) ?? AbortSignal.timeout(CLOSE_TIMEOUT$2);
      try {
        (r = setMaxListeners) == null || r(1 / 0, e.signal);
      } catch {
      }
      try {
        await Promise.all(this.streams.map(async (n) => n.close(e))), await this._close(e), this.timeline.close = Date.now(), this.status = "closed";
      } catch (n) {
        log$d.error("error encountered during graceful close of connection to %a", this.remoteAddr, n), this.abort(n);
      }
    }
  }
  abort(e) {
    log$d.error("aborting connection to %a due to error", this.remoteAddr, e), this.status = "closing", this.streams.forEach((r) => {
      r.abort(e);
    }), log$d.error("all streams aborted", this.streams.length), this._abort(e), this.timeline.close = Date.now(), this.status = "closed";
  }
}
cn = Symbol.toStringTag, un = symbol$1;
function createConnection(t) {
  return new ConnectionImpl(t);
}
const log$c = logger$1("libp2p:upgrader");
function findIncomingStreamLimit(t, e) {
  try {
    const { options: r } = e.getHandler(t);
    return r.maxInboundStreams;
  } catch (r) {
    if (r.code !== codes$1.ERR_NO_HANDLER_FOR_PROTOCOL)
      throw r;
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(t, e, r = {}) {
  try {
    const { options: n } = e.getHandler(t);
    if (n.maxOutboundStreams != null)
      return n.maxOutboundStreams;
  } catch (n) {
    if (n.code !== codes$1.ERR_NO_HANDLER_FOR_PROTOCOL)
      throw n;
  }
  return r.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(t, e, r) {
  let n = 0;
  return r.streams.forEach((i) => {
    i.direction === e && i.protocol === t && n++;
  }), n;
}
class DefaultUpgrader {
  constructor(e, r) {
    $(this, "components");
    $(this, "connectionEncryption");
    $(this, "muxers");
    $(this, "inboundUpgradeTimeout");
    $(this, "events");
    this.components = e, this.connectionEncryption = /* @__PURE__ */ new Map(), r.connectionEncryption.forEach((n) => {
      this.connectionEncryption.set(n.protocol, n);
    }), this.muxers = /* @__PURE__ */ new Map(), r.muxers.forEach((n) => {
      this.muxers.set(n.protocol, n);
    }), this.inboundUpgradeTimeout = r.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT, this.events = e.events;
  }
  async shouldBlockConnection(e, r, n) {
    const i = this.components.connectionGater[n];
    if (i !== void 0 && await i(e, r))
      throw new CodeError$2(`The multiaddr connection is blocked by gater.${n}`, codes$1.ERR_CONNECTION_INTERCEPTED);
  }
  /**
   * Upgrades an inbound connection
   */
  async upgradeInbound(e, r) {
    var f, d, p, g;
    if (!await this.components.connectionManager.acceptIncomingConnection(e))
      throw new CodeError$2("connection denied", codes$1.ERR_CONNECTION_DENIED);
    let i, o, a, c, l;
    const u = anySignal([AbortSignal.timeout(this.inboundUpgradeTimeout)]);
    try {
      (f = setMaxListeners) == null || f(1 / 0, u);
    } catch {
    }
    try {
      const h = abortableDuplex(e, u);
      if (e.source = h.source, e.sink = h.sink, await ((p = (d = this.components.connectionGater).denyInboundConnection) == null ? void 0 : p.call(d, e)) === !0)
        throw new CodeError$2("The multiaddr connection is blocked by gater.acceptConnection", codes$1.ERR_CONNECTION_INTERCEPTED);
      (g = this.components.metrics) == null || g.trackMultiaddrConnection(e), log$c("starting the inbound connection upgrade");
      let m = e;
      if ((r == null ? void 0 : r.skipProtection) !== !0) {
        const y = this.components.connectionProtector;
        y != null && (log$c("protecting the inbound connection"), m = await y.protect(e));
      }
      try {
        if (i = m, (r == null ? void 0 : r.skipEncryption) !== !0) {
          ({
            conn: i,
            remotePeer: o,
            protocol: l
          } = await this._encryptInbound(m));
          const y = {
            ...m,
            ...i
          };
          await this.shouldBlockConnection(o, y, "denyInboundEncryptedConnection");
        } else {
          const y = e.remoteAddr.getPeerId();
          if (y == null)
            throw new CodeError$2("inbound connection that skipped encryption must have a peer id", codes$1.ERR_INVALID_MULTIADDR);
          const b = peerIdFromString(y);
          l = "native", o = b;
        }
        if (a = i, (r == null ? void 0 : r.muxerFactory) != null)
          c = r.muxerFactory;
        else if (this.muxers.size > 0) {
          const y = await this._multiplexInbound({
            ...m,
            ...i
          }, this.muxers);
          c = y.muxerFactory, a = y.stream;
        }
      } catch (y) {
        throw log$c.error("Failed to upgrade inbound connection", y), y;
      }
      return await this.shouldBlockConnection(o, e, "denyInboundUpgradedConnection"), log$c("Successfully upgraded inbound connection"), this._createConnection({
        cryptoProtocol: l,
        direction: "inbound",
        maConn: e,
        upgradedConn: a,
        muxerFactory: c,
        remotePeer: o,
        transient: r == null ? void 0 : r.transient
      });
    } finally {
      this.components.connectionManager.afterUpgradeInbound(), u.clear();
    }
  }
  /**
   * Upgrades an outbound connection
   */
  async upgradeOutbound(e, r) {
    var d;
    const n = e.remoteAddr.getPeerId();
    let i;
    n != null && (i = peerIdFromString(n), await this.shouldBlockConnection(i, e, "denyOutboundConnection"));
    let o, a, c, l, u;
    (d = this.components.metrics) == null || d.trackMultiaddrConnection(e), log$c("Starting the outbound connection upgrade");
    let f = e;
    if ((r == null ? void 0 : r.skipProtection) !== !0) {
      const p = this.components.connectionProtector;
      p != null && (f = await p.protect(e));
    }
    try {
      if (o = f, (r == null ? void 0 : r.skipEncryption) !== !0) {
        ({
          conn: o,
          remotePeer: a,
          protocol: l
        } = await this._encryptOutbound(f, i));
        const p = {
          ...f,
          ...o
        };
        await this.shouldBlockConnection(a, p, "denyOutboundEncryptedConnection");
      } else {
        if (i == null)
          throw new CodeError$2("Encryption was skipped but no peer id was passed", codes$1.ERR_INVALID_PEER);
        l = "native", a = i;
      }
      if (c = o, (r == null ? void 0 : r.muxerFactory) != null)
        u = r.muxerFactory;
      else if (this.muxers.size > 0) {
        const p = await this._multiplexOutbound({
          ...f,
          ...o
        }, this.muxers);
        u = p.muxerFactory, c = p.stream;
      }
    } catch (p) {
      throw log$c.error("Failed to upgrade outbound connection", p), await e.close(p), p;
    }
    return await this.shouldBlockConnection(a, e, "denyOutboundUpgradedConnection"), log$c("Successfully upgraded outbound connection"), this._createConnection({
      cryptoProtocol: l,
      direction: "outbound",
      maConn: e,
      upgradedConn: c,
      muxerFactory: u,
      remotePeer: a,
      transient: r == null ? void 0 : r.transient
    });
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(e) {
    const { cryptoProtocol: r, direction: n, maConn: i, upgradedConn: o, remotePeer: a, muxerFactory: c, transient: l } = e;
    let u, f, d;
    c != null && (u = c.createStreamMuxer({
      direction: n,
      // Run anytime a remote stream is created
      onIncomingStream: (h) => {
        d != null && Promise.resolve().then(async () => {
          var E;
          const m = this.components.registrar.getProtocols(), { stream: y, protocol: b } = await handle(h, m);
          if (log$c("%s: incoming stream opened on %s", n, b), d == null)
            return;
          const v = findIncomingStreamLimit(b, this.components.registrar);
          if (countStreams(b, "inbound", d) === v) {
            const w = new CodeError$2(`Too many inbound protocol streams for protocol "${b}" - limit ${v}`, codes$1.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);
            throw h.abort(w), w;
          }
          h.source = y.source, h.sink = y.sink, h.protocol = b, await this.components.peerStore.merge(a, {
            protocols: [b]
          }), (E = this.components.metrics) == null || E.trackProtocolStream(h, d), this._onStream({ connection: d, stream: h, protocol: b });
        }).catch(async (m) => {
          log$c.error(m), h.timeline.close == null && await h.close();
        });
      }
    }), f = async (h, m = {}) => {
      var b, v;
      if (u == null)
        throw new CodeError$2("Stream is not multiplexed", codes$1.ERR_MUXER_UNAVAILABLE);
      log$c("%s: starting new stream on %s", n, h);
      const y = await u.newStream();
      try {
        if (m.signal == null) {
          log$c("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout", h), m.signal = AbortSignal.timeout(3e4);
          try {
            (b = setMaxListeners) == null || b(1 / 0, m.signal);
          } catch {
          }
        }
        const { stream: _, protocol: E } = await select(y, h, m), w = findOutgoingStreamLimit(E, this.components.registrar, m);
        if (countStreams(E, "outbound", d) >= w) {
          const x = new CodeError$2(`Too many outbound protocol streams for protocol "${E}" - limit ${w}`, codes$1.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
          throw y.abort(x), x;
        }
        return await this.components.peerStore.merge(a, {
          protocols: [E]
        }), y.source = _.source, y.sink = _.sink, y.protocol = E, (v = this.components.metrics) == null || v.trackProtocolStream(y, d), y;
      } catch (_) {
        throw log$c.error("could not create new stream", _), y.timeline.close == null && y.abort(_), _.code != null ? _ : new CodeError$2(String(_), codes$1.ERR_UNSUPPORTED_PROTOCOL);
      }
    }, Promise.all([
      u.sink(o.source),
      o.sink(u.source)
    ]).catch((h) => {
      log$c.error(h);
    }));
    const p = i.timeline;
    i.timeline = new Proxy(p, {
      set: (...h) => (d != null && h[1] === "close" && h[2] != null && p.close == null && (async () => {
        try {
          d.status === "open" && await d.close();
        } catch (m) {
          log$c.error(m);
        } finally {
          this.events.safeDispatchEvent("connection:close", {
            detail: d
          });
        }
      })().catch((m) => {
        log$c.error(m);
      }), Reflect.set(...h))
    }), i.timeline.upgraded = Date.now();
    const g = () => {
      throw new CodeError$2("connection is not multiplexed", codes$1.ERR_CONNECTION_NOT_MULTIPLEXED);
    };
    return d = createConnection({
      remoteAddr: i.remoteAddr,
      remotePeer: a,
      status: "open",
      direction: n,
      timeline: i.timeline,
      multiplexer: u == null ? void 0 : u.protocol,
      encryption: r,
      transient: l,
      newStream: f ?? g,
      getStreams: () => u != null ? u.streams : [],
      close: async (h) => {
        await i.close(h), u != null && await u.close(h);
      },
      abort: (h) => {
        i.abort(h), u != null && u.abort(h);
      }
    }), this.events.safeDispatchEvent("connection:open", {
      detail: d
    }), d;
  }
  /**
   * Routes incoming streams to the correct handler
   */
  _onStream(e) {
    const { connection: r, stream: n, protocol: i } = e, { handler: o, options: a } = this.components.registrar.getHandler(i);
    if (r.transient && a.runOnTransientConnection !== !0)
      throw new CodeError$2("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
    o({ connection: r, stream: n });
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(e) {
    const r = Array.from(this.connectionEncryption.keys());
    log$c("handling inbound crypto protocol selection", r);
    try {
      const { stream: n, protocol: i } = await handle(e, r, {
        writeBytes: !0
      }), o = this.connectionEncryption.get(i);
      if (o == null)
        throw new Error(`no crypto module found for ${i}`);
      return log$c("encrypting inbound connection..."), {
        ...await o.secureInbound(this.components.peerId, n),
        protocol: i
      };
    } catch (n) {
      throw new CodeError$2(String(n), codes$1.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(e, r) {
    const n = Array.from(this.connectionEncryption.keys());
    log$c("selecting outbound crypto protocol", n);
    try {
      const { stream: i, protocol: o } = await select(e, n, {
        writeBytes: !0
      }), a = this.connectionEncryption.get(o);
      if (a == null)
        throw new Error(`no crypto module found for ${o}`);
      return log$c("encrypting outbound connection to %p", r), {
        ...await a.secureOutbound(this.components.peerId, i, r),
        protocol: o
      };
    } catch (i) {
      throw new CodeError$2(String(i), codes$1.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(e, r) {
    const n = Array.from(r.keys());
    log$c("outbound selecting muxer %s", n);
    try {
      const { stream: i, protocol: o } = await select(e, n, {
        writeBytes: !0
      });
      log$c("%s selected as muxer protocol", o);
      const a = r.get(o);
      return { stream: i, muxerFactory: a };
    } catch (i) {
      throw log$c.error("error multiplexing outbound stream", i), new CodeError$2(String(i), codes$1.ERR_MUXER_UNAVAILABLE);
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(e, r) {
    const n = Array.from(r.keys());
    log$c("inbound handling muxers %s", n);
    try {
      const { stream: i, protocol: o } = await handle(e, n, {
        writeBytes: !0
      }), a = r.get(o);
      return { stream: i, muxerFactory: a };
    } catch (i) {
      throw log$c.error("error multiplexing inbound stream", i), new CodeError$2(String(i), codes$1.ERR_MUXER_UNAVAILABLE);
    }
  }
}
const log$b = logger$1("libp2p");
var ue, Oe, Xe;
class Libp2pNode extends EventEmitter$2 {
  constructor(r) {
    var u;
    super();
    /**
     * Called whenever peer discovery services emit `peer` events and adds peers
     * to the peer store.
     */
    ie(this, Oe);
    $(this, "peerId");
    $(this, "peerStore");
    $(this, "contentRouting");
    $(this, "peerRouting");
    $(this, "keychain");
    $(this, "metrics");
    $(this, "services");
    $(this, "components");
    ie(this, ue, void 0);
    const n = new EventEmitter$2(), i = n.dispatchEvent.bind(n);
    n.dispatchEvent = (f) => {
      const d = i(f), p = this.dispatchEvent(new CustomEvent(f.type, { detail: f.detail }));
      return d || p;
    };
    try {
      (u = setMaxListeners) == null || u(1 / 0, n);
    } catch {
    }
    fe(this, ue, !1), this.peerId = r.peerId, this.services = {};
    const o = this.components = defaultComponents({
      peerId: r.peerId,
      events: n,
      datastore: r.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(r.connectionGater)
    });
    this.peerStore = this.configureComponent("peerStore", new PersistentPeerStore(o, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...r.peerStore
    })), r.metrics != null && (this.metrics = this.configureComponent("metrics", r.metrics(this.components))), o.events.addEventListener("peer:update", (f) => {
      if (f.detail.previous == null) {
        const d = {
          id: f.detail.peer.id,
          multiaddrs: f.detail.peer.addresses.map((p) => p.multiaddr),
          protocols: f.detail.peer.protocols
        };
        this.safeDispatchEvent("peer:discovery", { detail: d });
      }
    }), r.connectionProtector != null && this.configureComponent("connectionProtector", r.connectionProtector(o)), this.components.upgrader = new DefaultUpgrader(this.components, {
      connectionEncryption: (r.connectionEncryption ?? []).map((f, d) => this.configureComponent(`connection-encryption-${d}`, f(this.components))),
      muxers: (r.streamMuxers ?? []).map((f, d) => this.configureComponent(`stream-muxers-${d}`, f(this.components))),
      inboundUpgradeTimeout: r.connectionManager.inboundUpgradeTimeout
    }), this.configureComponent("transportManager", new DefaultTransportManager(this.components, r.transportManager)), this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, r.connectionManager)), this.configureComponent("registrar", new DefaultRegistrar(this.components)), this.configureComponent("addressManager", new DefaultAddressManager(this.components, r.addresses));
    const a = DefaultKeyChain.generateOptions();
    this.keychain = this.configureComponent("keyChain", new DefaultKeyChain(this.components, {
      ...a,
      ...r.keychain
    }));
    const c = (r.peerRouters ?? []).map((f, d) => this.configureComponent(`peer-router-${d}`, f(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: c
    }));
    const l = (r.contentRouters ?? []).map((f, d) => this.configureComponent(`content-router-${d}`, f(this.components)));
    if (this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: l
    })), (r.peerDiscovery ?? []).forEach((f, d) => {
      this.configureComponent(`peer-discovery-${d}`, f(this.components)).addEventListener("peer", (g) => {
        re(this, Oe, Xe).call(this, g);
      });
    }), r.transports.forEach((f, d) => {
      this.components.transportManager.add(this.configureComponent(`transport-${d}`, f(this.components)));
    }), r.services != null)
      for (const f of Object.keys(r.services)) {
        const d = r.services[f], p = d(this.components);
        if (p == null) {
          log$b.error("service factory %s returned null or undefined instance", f);
          continue;
        }
        this.services[f] = p, this.configureComponent(f, p), p[contentRouting] != null && (log$b("registering service %s for content routing", f), l.push(p[contentRouting])), p[peerRouting] != null && (log$b("registering service %s for peer routing", f), c.push(p[peerRouting])), p[peerDiscovery] != null && (log$b("registering service %s for peer discovery", f), p[peerDiscovery].addEventListener("peer", (g) => {
          re(this, Oe, Xe).call(this, g);
        }));
      }
  }
  configureComponent(r, n) {
    return n == null && log$b.error("component %s was null or undefined", r), this.components[r] = n, n;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    var n, i, o, a;
    if (Y(this, ue))
      return;
    fe(this, ue, !0), log$b("libp2p is starting"), (await this.keychain.listKeys()).find((c) => c.name === "self") == null && (log$b("importing self key into keychain"), await this.keychain.importPeer("self", this.components.peerId));
    try {
      await ((i = (n = this.components).beforeStart) == null ? void 0 : i.call(n)), await this.components.start(), await ((a = (o = this.components).afterStart) == null ? void 0 : a.call(o)), this.safeDispatchEvent("start", { detail: this }), log$b("libp2p has started");
    } catch (c) {
      throw log$b.error("An error occurred starting libp2p", c), await this.stop(), c;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    var r, n, i, o;
    Y(this, ue) && (log$b("libp2p is stopping"), fe(this, ue, !1), await ((n = (r = this.components).beforeStop) == null ? void 0 : n.call(r)), await this.components.stop(), await ((o = (i = this.components).afterStop) == null ? void 0 : o.call(i)), this.safeDispatchEvent("stop", { detail: this }), log$b("libp2p has stopped"));
  }
  isStarted() {
    return Y(this, ue);
  }
  getConnections(r) {
    return this.components.connectionManager.getConnections(r);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const r = new PeerSet();
    for (const n of this.components.connectionManager.getConnections())
      r.add(n.remotePeer);
    return Array.from(r);
  }
  async dial(r, n = {}) {
    return this.components.connectionManager.openConnection(r, n);
  }
  async dialProtocol(r, n, i = {}) {
    if (n == null)
      throw new CodeError$2("no protocols were provided to open a stream", codes$1.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    if (n = Array.isArray(n) ? n : [n], n.length === 0)
      throw new CodeError$2("no protocols were provided to open a stream", codes$1.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    return (await this.dial(r, i)).newStream(n, i);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(r, n = {}) {
    isMultiaddr$1(r) && (r = peerIdFromString(r.getPeerId() ?? "")), await this.components.connectionManager.closeConnections(r, n);
  }
  /**
   * Get the public key for the given peer id
   */
  async getPublicKey(r, n = {}) {
    if (log$b("getPublicKey %p", r), r.publicKey != null)
      return r.publicKey;
    const i = await this.peerStore.get(r);
    if (i.id.publicKey != null)
      return i.id.publicKey;
    const o = concat$6([
      fromString$3("/pk/"),
      r.multihash.digest
    ]), a = await this.contentRouting.get(o, n);
    return unmarshalPublicKey(a), await this.peerStore.patch(r, {
      publicKey: a
    }), a;
  }
  async handle(r, n, i) {
    Array.isArray(r) || (r = [r]), await Promise.all(r.map(async (o) => {
      await this.components.registrar.handle(o, n, i);
    }));
  }
  async unhandle(r) {
    Array.isArray(r) || (r = [r]), await Promise.all(r.map(async (n) => {
      await this.components.registrar.unhandle(n);
    }));
  }
  async register(r, n) {
    return this.components.registrar.register(r, n);
  }
  unregister(r) {
    this.components.registrar.unregister(r);
  }
}
ue = new WeakMap(), Oe = new WeakSet(), Xe = function(r) {
  const { detail: n } = r;
  if (n.id.toString() === this.peerId.toString()) {
    log$b.error(new Error(codes$1.ERR_DISCOVERED_SELF));
    return;
  }
  this.components.peerStore.merge(n.id, {
    multiaddrs: n.multiaddrs,
    protocols: n.protocols
  }).catch((i) => {
    log$b.error(i);
  });
};
async function createLibp2pNode(t) {
  if (t.peerId == null) {
    const e = t.datastore;
    if (e != null)
      try {
        const r = new DefaultKeyChain({
          datastore: e
        }, mergeOptions(DefaultKeyChain.generateOptions(), t.keychain));
        t.peerId = await r.exportPeerId("self");
      } catch (r) {
        if (r.code !== "ERR_NOT_FOUND")
          throw r;
      }
  }
  return t.peerId == null && (t.peerId = await createEd25519PeerId()), new Libp2pNode(validateConfig(t));
}
async function createLibp2p(t) {
  const e = await createLibp2pNode(t);
  return t.start !== !1 && await e.start(), e;
}
function isAsyncIterable$3(t) {
  return t[Symbol.asyncIterator] != null;
}
const MAX_LENGTH_LENGTH = 8, MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(t) {
  t[t.LENGTH = 0] = "LENGTH", t[t.DATA = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
const defaultDecoder = (t) => {
  const e = decode$4(t);
  return defaultDecoder.bytes = encodingLength(e), e;
};
defaultDecoder.bytes = 0;
function decode$2(t, e) {
  const r = new Uint8ArrayList();
  let n = ReadMode.LENGTH, i = -1;
  const o = (e == null ? void 0 : e.lengthDecoder) ?? defaultDecoder, a = (e == null ? void 0 : e.maxLengthLength) ?? MAX_LENGTH_LENGTH, c = (e == null ? void 0 : e.maxDataLength) ?? MAX_DATA_LENGTH;
  function* l() {
    for (; r.byteLength > 0; ) {
      if (n === ReadMode.LENGTH)
        try {
          if (i = o(r), i < 0)
            throw errCode(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
          if (i > c)
            throw errCode(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
          const u = o.bytes;
          r.consume(u), (e == null ? void 0 : e.onLength) != null && e.onLength(i), n = ReadMode.DATA;
        } catch (u) {
          if (u instanceof RangeError) {
            if (r.byteLength > a)
              throw errCode(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
            break;
          }
          throw u;
        }
      if (n === ReadMode.DATA) {
        if (r.byteLength < i)
          break;
        const u = r.sublist(0, i);
        r.consume(i), (e == null ? void 0 : e.onData) != null && e.onData(u), yield u, n = ReadMode.LENGTH;
      }
    }
  }
  return isAsyncIterable$3(t) ? async function* () {
    for await (const u of t)
      r.append(u), yield* l();
    if (r.byteLength > 0)
      throw errCode(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
  }() : function* () {
    for (const u of t)
      r.append(u), yield* l();
    if (r.byteLength > 0)
      throw errCode(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
  }();
}
decode$2.fromReader = (t, e) => {
  let r = 1;
  const n = async function* () {
    for (; ; )
      try {
        const { done: o, value: a } = await t.next(r);
        if (o === !0)
          return;
        a != null && (yield a);
      } catch (o) {
        if (o.code === "ERR_UNDER_READ")
          return { done: !0, value: null };
        throw o;
      } finally {
        r = 1;
      }
  }();
  return decode$2(n, {
    ...e ?? {},
    onLength: (o) => {
      r = o;
    }
  });
};
let CodeError$1 = class extends Error {
  constructor(r, n) {
    super(r);
    $(this, "code");
    this.code = n;
  }
};
class AbortError extends CodeError$1 {
  constructor(r) {
    super(r, "ABORT_ERR");
    $(this, "type");
    this.type = "aborted";
  }
}
function byteStream(t) {
  const e = pushable();
  t.sink(e).catch((o) => {
    e.end(o);
  }), t.sink = async (o) => {
    for await (const a of o)
      e.push(a);
    e.end();
  };
  let r = t.source;
  t.source[Symbol.iterator] != null ? r = t.source[Symbol.iterator]() : t.source[Symbol.asyncIterator] != null && (r = t.source[Symbol.asyncIterator]());
  const n = new Uint8ArrayList();
  return {
    read: async (o, a) => {
      var u, f;
      (u = a == null ? void 0 : a.signal) == null || u.throwIfAborted();
      let c;
      const l = new Promise((d, p) => {
        var g;
        c = () => {
          p(new AbortError("Read aborted"));
        }, (g = a == null ? void 0 : a.signal) == null || g.addEventListener("abort", c);
      });
      try {
        if (o == null) {
          const { done: p, value: g } = await Promise.race([
            r.next(),
            l
          ]);
          return p === !0 ? new Uint8ArrayList() : g;
        }
        for (; n.byteLength < o; ) {
          const { value: p, done: g } = await Promise.race([
            r.next(),
            l
          ]);
          if (g === !0)
            throw new CodeError$1("unexpected end of input", "ERR_UNEXPECTED_EOF");
          n.append(p);
        }
        const d = n.sublist(0, o);
        return n.consume(o), d;
      } finally {
        c != null && ((f = a == null ? void 0 : a.signal) == null || f.removeEventListener("abort", c));
      }
    },
    write: async (o, a) => {
      var c;
      (c = a == null ? void 0 : a.signal) == null || c.throwIfAborted(), o instanceof Uint8Array ? e.push(o) : e.push(o.subarray()), await e.onEmpty(a);
    },
    unwrap: () => {
      const o = t.source;
      return t.source = async function* () {
        yield* n, yield* o;
      }(), t;
    }
  };
}
class CodeError extends Error {
  constructor(r, n) {
    super(r);
    $(this, "code");
    this.code = n;
  }
}
const defaultLengthDecoder = (t) => decode$4(t);
defaultLengthDecoder.bytes = 0;
function lpStream(t, e) {
  const r = byteStream(t);
  return {
    read: async (i) => {
      let o = -1;
      const a = new Uint8ArrayList(), c = (e == null ? void 0 : e.lengthDecoder) ?? defaultLengthDecoder;
      for (; ; ) {
        a.append(await r.read(1, i));
        try {
          o = c(a);
        } catch (l) {
          if (l instanceof RangeError)
            continue;
          throw l;
        }
        if (o > -1)
          break;
        if ((e == null ? void 0 : e.maxLengthLength) != null && a.byteLength > e.maxLengthLength)
          throw new CodeError("message length length too long", "ERR_MSG_LENGTH_TOO_LONG");
      }
      if ((e == null ? void 0 : e.maxDataLength) != null && o > e.maxDataLength)
        throw new CodeError("message length too long", "ERR_MSG_DATA_TOO_LONG");
      return r.read(o, i);
    },
    write: async (i, o) => {
      await r.write(encode$3.single(i, e), o);
    },
    unwrap: () => r.unwrap()
  };
}
function pair() {
  const t = pDefer();
  let e = !1;
  return {
    sink: async (r) => {
      if (e)
        throw new Error("already piped");
      e = !0, t.resolve(r);
    },
    source: async function* () {
      yield* await t.promise;
    }()
  };
}
function duplexPair() {
  const t = pair(), e = pair();
  return [
    {
      source: t.source,
      sink: e.sink
    },
    {
      source: e.source,
      sink: t.sink
    }
  ];
}
const NOISE_MSG_MAX_LENGTH_BYTES = 65535, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var rt, nt;
const DUMP_SESSION_KEYS = Boolean((nt = (rt = globalThis.process) == null ? void 0 : rt.env) == null ? void 0 : nt.DUMP_SESSION_KEYS);
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
const u8a = (t) => t instanceof Uint8Array, u32 = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), createView = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function toBytes$1(t) {
  if (typeof t == "string" && (t = utf8ToBytes(t)), !u8a(t))
    throw new Error(`expected Uint8Array, got ${typeof t}`);
  return t;
}
const isPlainObject = (t) => Object.prototype.toString.call(t) === "[object Object]" && t.constructor === Object;
function checkOpts(t, e) {
  if (e !== void 0 && (typeof e != "object" || !isPlainObject(e)))
    throw new Error("Options should be object or undefined");
  return Object.assign(t, e);
}
function ensureBytes(t, e) {
  if (!(t instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  if (typeof e == "number" && t.length !== e)
    throw new Error(`Uint8Array length ${e} expected`);
}
function equalBytes(t, e) {
  if (t.length !== e.length)
    throw new Error("equalBytes: Different size of Uint8Arrays");
  let r = !0;
  for (let n = 0; n < t.length; n++)
    r && (r = t[n] === e[n]);
  return r;
}
function setBigUint64(t, e, r, n) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, r, n);
  const i = BigInt(32), o = BigInt(4294967295), a = Number(r >> i & o), c = Number(r & o), l = n ? 4 : 0, u = n ? 0 : 4;
  t.setUint32(e + l, a, n), t.setUint32(e + u, c, n);
}
function number(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`Wrong positive integer: ${t}`);
}
function bool(t) {
  if (typeof t != "boolean")
    throw new Error(`Expected boolean, not ${t}`);
}
function bytes(t, ...e) {
  if (!(t instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);
}
function hash(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(t.outputLen), number(t.blockLen);
}
function exists(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(t, e) {
  bytes(t);
  const r = e.outputLen;
  if (t.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const assert = { number, bool, bytes, hash, exists, output }, u8to16 = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
class Poly1305 {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e = toBytes$1(e), ensureBytes(e, 32);
    const r = u8to16(e, 0), n = u8to16(e, 2), i = u8to16(e, 4), o = u8to16(e, 6), a = u8to16(e, 8), c = u8to16(e, 10), l = u8to16(e, 12), u = u8to16(e, 14);
    this.r[0] = r & 8191, this.r[1] = (r >>> 13 | n << 3) & 8191, this.r[2] = (n >>> 10 | i << 6) & 7939, this.r[3] = (i >>> 7 | o << 9) & 8191, this.r[4] = (o >>> 4 | a << 12) & 255, this.r[5] = a >>> 1 & 8190, this.r[6] = (a >>> 14 | c << 2) & 8191, this.r[7] = (c >>> 11 | l << 5) & 8065, this.r[8] = (l >>> 8 | u << 8) & 8191, this.r[9] = u >>> 5 & 127;
    for (let f = 0; f < 8; f++)
      this.pad[f] = u8to16(e, 16 + 2 * f);
  }
  process(e, r, n = !1) {
    const i = n ? 0 : 2048, { h: o, r: a } = this, c = a[0], l = a[1], u = a[2], f = a[3], d = a[4], p = a[5], g = a[6], h = a[7], m = a[8], y = a[9], b = u8to16(e, r + 0), v = u8to16(e, r + 2), _ = u8to16(e, r + 4), E = u8to16(e, r + 6), w = u8to16(e, r + 8), S = u8to16(e, r + 10), x = u8to16(e, r + 12), I = u8to16(e, r + 14);
    let C = o[0] + (b & 8191), M = o[1] + ((b >>> 13 | v << 3) & 8191), O = o[2] + ((v >>> 10 | _ << 6) & 8191), B = o[3] + ((_ >>> 7 | E << 9) & 8191), k = o[4] + ((E >>> 4 | w << 12) & 8191), U = o[5] + (w >>> 1 & 8191), R = o[6] + ((w >>> 14 | S << 2) & 8191), P = o[7] + ((S >>> 11 | x << 5) & 8191), T = o[8] + ((x >>> 8 | I << 8) & 8191), L = o[9] + (I >>> 5 | i), A = 0, N = A + C * c + M * (5 * y) + O * (5 * m) + B * (5 * h) + k * (5 * g);
    A = N >>> 13, N &= 8191, N += U * (5 * p) + R * (5 * d) + P * (5 * f) + T * (5 * u) + L * (5 * l), A += N >>> 13, N &= 8191;
    let D = A + C * l + M * c + O * (5 * y) + B * (5 * m) + k * (5 * h);
    A = D >>> 13, D &= 8191, D += U * (5 * g) + R * (5 * p) + P * (5 * d) + T * (5 * f) + L * (5 * u), A += D >>> 13, D &= 8191;
    let F = A + C * u + M * l + O * c + B * (5 * y) + k * (5 * m);
    A = F >>> 13, F &= 8191, F += U * (5 * h) + R * (5 * g) + P * (5 * p) + T * (5 * d) + L * (5 * f), A += F >>> 13, F &= 8191;
    let j = A + C * f + M * u + O * l + B * c + k * (5 * y);
    A = j >>> 13, j &= 8191, j += U * (5 * m) + R * (5 * h) + P * (5 * g) + T * (5 * p) + L * (5 * d), A += j >>> 13, j &= 8191;
    let K = A + C * d + M * f + O * u + B * l + k * c;
    A = K >>> 13, K &= 8191, K += U * (5 * y) + R * (5 * m) + P * (5 * h) + T * (5 * g) + L * (5 * p), A += K >>> 13, K &= 8191;
    let G = A + C * p + M * d + O * f + B * u + k * l;
    A = G >>> 13, G &= 8191, G += U * c + R * (5 * y) + P * (5 * m) + T * (5 * h) + L * (5 * g), A += G >>> 13, G &= 8191;
    let W = A + C * g + M * p + O * d + B * f + k * u;
    A = W >>> 13, W &= 8191, W += U * l + R * c + P * (5 * y) + T * (5 * m) + L * (5 * h), A += W >>> 13, W &= 8191;
    let H = A + C * h + M * g + O * p + B * d + k * f;
    A = H >>> 13, H &= 8191, H += U * u + R * l + P * c + T * (5 * y) + L * (5 * m), A += H >>> 13, H &= 8191;
    let q = A + C * m + M * h + O * g + B * p + k * d;
    A = q >>> 13, q &= 8191, q += U * f + R * u + P * l + T * c + L * (5 * y), A += q >>> 13, q &= 8191;
    let z = A + C * y + M * m + O * h + B * g + k * p;
    A = z >>> 13, z &= 8191, z += U * d + R * f + P * u + T * l + L * c, A += z >>> 13, z &= 8191, A = (A << 2) + A | 0, A = A + N | 0, N = A & 8191, A = A >>> 13, D += A, o[0] = N, o[1] = D, o[2] = F, o[3] = j, o[4] = K, o[5] = G, o[6] = W, o[7] = H, o[8] = q, o[9] = z;
  }
  finalize() {
    const { h: e, pad: r } = this, n = new Uint16Array(10);
    let i = e[1] >>> 13;
    e[1] &= 8191;
    for (let c = 2; c < 10; c++)
      e[c] += i, i = e[c] >>> 13, e[c] &= 8191;
    e[0] += i * 5, i = e[0] >>> 13, e[0] &= 8191, e[1] += i, i = e[1] >>> 13, e[1] &= 8191, e[2] += i, n[0] = e[0] + 5, i = n[0] >>> 13, n[0] &= 8191;
    for (let c = 1; c < 10; c++)
      n[c] = e[c] + i, i = n[c] >>> 13, n[c] &= 8191;
    n[9] -= 1 << 13;
    let o = (i ^ 1) - 1;
    for (let c = 0; c < 10; c++)
      n[c] &= o;
    o = ~o;
    for (let c = 0; c < 10; c++)
      e[c] = e[c] & o | n[c];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let a = e[0] + r[0];
    e[0] = a & 65535;
    for (let c = 1; c < 8; c++)
      a = (e[c] + r[c] | 0) + (a >>> 16) | 0, e[c] = a & 65535;
  }
  update(e) {
    assert.exists(this);
    const { buffer: r, blockLen: n } = this;
    e = toBytes$1(e);
    const i = e.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(n - this.pos, i - o);
      if (a === n) {
        for (; n <= i - o; o += n)
          this.process(e, o);
        continue;
      }
      r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === n && (this.process(r, 0, !1), this.pos = 0);
    }
    return this;
  }
  destroy() {
    this.h.fill(0), this.r.fill(0), this.buffer.fill(0), this.pad.fill(0);
  }
  digestInto(e) {
    assert.exists(this), assert.output(e, this), this.finished = !0;
    const { buffer: r, h: n } = this;
    let { pos: i } = this;
    if (i) {
      for (r[i++] = 1; i < 16; i++)
        r[i] = 0;
      this.process(r, 0, !0);
    }
    this.finalize();
    let o = 0;
    for (let a = 0; a < 8; a++)
      e[o++] = n[a] >>> 0, e[o++] = n[a] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const n = e.slice(0, r);
    return this.destroy(), n;
  }
}
function wrapConstructorWithKey(t) {
  const e = (n, i) => t(i).update(toBytes$1(n)).digest(), r = t(new Uint8Array(32));
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;
}
const poly1305 = wrapConstructorWithKey((t) => new Poly1305(t)), sigma16 = utf8ToBytes("expand 16-byte k"), sigma32 = utf8ToBytes("expand 32-byte k"), sigma16_32 = u32(sigma16), sigma32_32 = u32(sigma32), isAligned32 = (t) => !(t.byteOffset % 4), salsaBasic = (t) => {
  const { core: e, rounds: r, counterRight: n, counterLen: i, allow128bitKeys: o, extendNonceFn: a, blockLen: c } = checkOpts({ rounds: 20, counterRight: !1, counterLen: 8, allow128bitKeys: !0, blockLen: 64 }, t);
  assert.number(i), assert.number(r), assert.number(c), assert.bool(n), assert.bool(o);
  const l = c / 4;
  if (c % 4 !== 0)
    throw new Error("Salsa/ChaCha: blockLen should be aligned to 4 bytes");
  return (u, f, d, p, g = 0) => {
    if (assert.bytes(u), assert.bytes(f), assert.bytes(d), p || (p = new Uint8Array(d.length)), assert.bytes(p), assert.number(g), g < 0 || g >= 2 ** 32 - 1)
      throw new Error("Salsa/ChaCha: counter overflow");
    if (p.length < d.length)
      throw new Error(`Salsa/ChaCha: output (${p.length}) is shorter than data (${d.length})`);
    const h = [];
    let m, y;
    if (u.length === 32)
      m = u, y = sigma32_32;
    else if (u.length === 16 && o)
      m = new Uint8Array(32), m.set(u), m.set(u, 16), y = sigma16_32, h.push(m);
    else
      throw new Error(`Salsa/ChaCha: wrong key length=${u.length}, expected`);
    if (a) {
      if (f.length <= 16)
        throw new Error("Salsa/ChaCha: extended nonce should be bigger than 16 bytes");
      m = a(y, m, f.subarray(0, 16), new Uint8Array(32)), h.push(m), f = f.subarray(16);
    }
    const b = 16 - i;
    if (f.length !== b)
      throw new Error(`Salsa/ChaCha: nonce should be ${b} or 16 bytes`);
    if (b !== 12) {
      const C = new Uint8Array(12);
      C.set(f, n ? 0 : 12 - f.length), h.push(f = C);
    }
    const v = new Uint8Array(c), _ = u32(v), E = u32(m), w = u32(f), S = isAligned32(d) && u32(d), x = isAligned32(p) && u32(p);
    h.push(_);
    const I = d.length;
    for (let C = 0, M = g; C < I; M++) {
      if (e(y, E, w, _, M, r), M >= 2 ** 32 - 1)
        throw new Error("Salsa/ChaCha: counter overflow");
      const O = Math.min(c, I - C);
      if (O === c && x && S) {
        const B = C / 4;
        if (C % 4 !== 0)
          throw new Error("Salsa/ChaCha: wrong block position");
        for (let k = 0; k < l; k++)
          x[B + k] = S[B + k] ^ _[k];
        C += c;
        continue;
      }
      for (let B = 0; B < O; B++)
        p[C + B] = d[C + B] ^ v[B];
      C += O;
    }
    for (let C = 0; C < h.length; C++)
      h[C].fill(0);
    return p;
  };
}, rotl = (t, e) => t << e | t >>> 32 - e;
function chachaCore(t, e, r, n, i, o = 20) {
  let a = t[0], c = t[1], l = t[2], u = t[3], f = e[0], d = e[1], p = e[2], g = e[3], h = e[4], m = e[5], y = e[6], b = e[7], v = i, _ = r[0], E = r[1], w = r[2], S = a, x = c, I = l, C = u, M = f, O = d, B = p, k = g, U = h, R = m, P = y, T = b, L = v, A = _, N = E, D = w;
  for (let j = 0; j < o; j += 2)
    S = S + M | 0, L = rotl(L ^ S, 16), U = U + L | 0, M = rotl(M ^ U, 12), S = S + M | 0, L = rotl(L ^ S, 8), U = U + L | 0, M = rotl(M ^ U, 7), x = x + O | 0, A = rotl(A ^ x, 16), R = R + A | 0, O = rotl(O ^ R, 12), x = x + O | 0, A = rotl(A ^ x, 8), R = R + A | 0, O = rotl(O ^ R, 7), I = I + B | 0, N = rotl(N ^ I, 16), P = P + N | 0, B = rotl(B ^ P, 12), I = I + B | 0, N = rotl(N ^ I, 8), P = P + N | 0, B = rotl(B ^ P, 7), C = C + k | 0, D = rotl(D ^ C, 16), T = T + D | 0, k = rotl(k ^ T, 12), C = C + k | 0, D = rotl(D ^ C, 8), T = T + D | 0, k = rotl(k ^ T, 7), S = S + O | 0, D = rotl(D ^ S, 16), P = P + D | 0, O = rotl(O ^ P, 12), S = S + O | 0, D = rotl(D ^ S, 8), P = P + D | 0, O = rotl(O ^ P, 7), x = x + B | 0, L = rotl(L ^ x, 16), T = T + L | 0, B = rotl(B ^ T, 12), x = x + B | 0, L = rotl(L ^ x, 8), T = T + L | 0, B = rotl(B ^ T, 7), I = I + k | 0, A = rotl(A ^ I, 16), U = U + A | 0, k = rotl(k ^ U, 12), I = I + k | 0, A = rotl(A ^ I, 8), U = U + A | 0, k = rotl(k ^ U, 7), C = C + M | 0, N = rotl(N ^ C, 16), R = R + N | 0, M = rotl(M ^ R, 12), C = C + M | 0, N = rotl(N ^ C, 8), R = R + N | 0, M = rotl(M ^ R, 7);
  let F = 0;
  n[F++] = a + S | 0, n[F++] = c + x | 0, n[F++] = l + I | 0, n[F++] = u + C | 0, n[F++] = f + M | 0, n[F++] = d + O | 0, n[F++] = p + B | 0, n[F++] = g + k | 0, n[F++] = h + U | 0, n[F++] = m + R | 0, n[F++] = y + P | 0, n[F++] = b + T | 0, n[F++] = v + L | 0, n[F++] = _ + A | 0, n[F++] = E + N | 0, n[F++] = w + D | 0;
}
function hchacha(t, e, r, n) {
  const i = u32(e), o = u32(r), a = u32(n);
  let c = t[0], l = t[1], u = t[2], f = t[3], d = i[0], p = i[1], g = i[2], h = i[3], m = i[4], y = i[5], b = i[6], v = i[7], _ = o[0], E = o[1], w = o[2], S = o[3];
  for (let x = 0; x < 20; x += 2)
    c = c + d | 0, _ = rotl(_ ^ c, 16), m = m + _ | 0, d = rotl(d ^ m, 12), c = c + d | 0, _ = rotl(_ ^ c, 8), m = m + _ | 0, d = rotl(d ^ m, 7), l = l + p | 0, E = rotl(E ^ l, 16), y = y + E | 0, p = rotl(p ^ y, 12), l = l + p | 0, E = rotl(E ^ l, 8), y = y + E | 0, p = rotl(p ^ y, 7), u = u + g | 0, w = rotl(w ^ u, 16), b = b + w | 0, g = rotl(g ^ b, 12), u = u + g | 0, w = rotl(w ^ u, 8), b = b + w | 0, g = rotl(g ^ b, 7), f = f + h | 0, S = rotl(S ^ f, 16), v = v + S | 0, h = rotl(h ^ v, 12), f = f + h | 0, S = rotl(S ^ f, 8), v = v + S | 0, h = rotl(h ^ v, 7), c = c + p | 0, S = rotl(S ^ c, 16), b = b + S | 0, p = rotl(p ^ b, 12), c = c + p | 0, S = rotl(S ^ c, 8), b = b + S | 0, p = rotl(p ^ b, 7), l = l + g | 0, _ = rotl(_ ^ l, 16), v = v + _ | 0, g = rotl(g ^ v, 12), l = l + g | 0, _ = rotl(_ ^ l, 8), v = v + _ | 0, g = rotl(g ^ v, 7), u = u + h | 0, E = rotl(E ^ u, 16), m = m + E | 0, h = rotl(h ^ m, 12), u = u + h | 0, E = rotl(E ^ u, 8), m = m + E | 0, h = rotl(h ^ m, 7), f = f + d | 0, w = rotl(w ^ f, 16), y = y + w | 0, d = rotl(d ^ y, 12), f = f + d | 0, w = rotl(w ^ f, 8), y = y + w | 0, d = rotl(d ^ y, 7);
  return a[0] = c, a[1] = l, a[2] = u, a[3] = f, a[4] = _, a[5] = E, a[6] = w, a[7] = S, n;
}
salsaBasic({ core: chachaCore, counterRight: !1, counterLen: 8 });
const chacha20 = salsaBasic({
  core: chachaCore,
  counterRight: !1,
  counterLen: 4,
  allow128bitKeys: !1
});
salsaBasic({
  core: chachaCore,
  counterRight: !1,
  counterLen: 8,
  extendNonceFn: hchacha,
  allow128bitKeys: !1
});
salsaBasic({
  core: chachaCore,
  counterRight: !1,
  counterLen: 4,
  rounds: 8
});
salsaBasic({
  core: chachaCore,
  counterRight: !1,
  counterLen: 4,
  rounds: 12
});
const ZERO = new Uint8Array(16), updatePadded = (t, e) => {
  t.update(e);
  const r = e.length % 16;
  r && t.update(ZERO.subarray(r));
}, computeTag = (t, e, r, n, i) => {
  const o = t(e, r, new Uint8Array(32)), a = poly1305.create(o);
  i && updatePadded(a, i), updatePadded(a, n);
  const c = new Uint8Array(16), l = createView(c);
  setBigUint64(l, 0, BigInt(i ? i.length : 0), !0), setBigUint64(l, 8, BigInt(n.length), !0), a.update(c);
  const u = a.digest();
  return o.fill(0), u;
}, _poly1305_aead = (t) => (e, r, n) => (ensureBytes(e, 32), ensureBytes(r), {
  tagLength: 16,
  encrypt: (o) => {
    const a = new Uint8Array(o.length + 16);
    t(e, r, o, a, 1);
    const c = computeTag(t, e, r, a.subarray(0, -16), n);
    return a.set(c, o.length), a;
  },
  decrypt: (o) => {
    if (o.length < 16)
      throw new Error(`Encrypted data should be at least ${16}`);
    const a = o.subarray(-16), c = o.subarray(0, -16), l = computeTag(t, e, r, c, n);
    if (!equalBytes(a, l))
      throw new Error("Wrong tag");
    return t(e, r, c, void 0, 1);
  }
}), chacha20_poly1305 = _poly1305_aead(chacha20), U32_MASK64 = BigInt(2 ** 32 - 1), _32n = BigInt(32);
function fromBig(t, e = !1) {
  return e ? { h: Number(t & U32_MASK64), l: Number(t >> _32n & U32_MASK64) } : { h: Number(t >> _32n & U32_MASK64) | 0, l: Number(t & U32_MASK64) | 0 };
}
function split(t, e = !1) {
  let r = new Uint32Array(t.length), n = new Uint32Array(t.length);
  for (let i = 0; i < t.length; i++) {
    const { h: o, l: a } = fromBig(t[i], e);
    [r[i], n[i]] = [o, a];
  }
  return [r, n];
}
const toBig = (t, e) => BigInt(t >>> 0) << _32n | BigInt(e >>> 0), shrSH = (t, e, r) => t >>> r, shrSL = (t, e, r) => t << 32 - r | e >>> r, rotrSH = (t, e, r) => t >>> r | e << 32 - r, rotrSL = (t, e, r) => t << 32 - r | e >>> r, rotrBH = (t, e, r) => t << 64 - r | e >>> r - 32, rotrBL = (t, e, r) => t >>> r - 32 | e << 64 - r, rotr32H = (t, e) => e, rotr32L = (t, e) => t, rotlSH = (t, e, r) => t << r | e >>> 32 - r, rotlSL = (t, e, r) => e << r | t >>> 32 - r, rotlBH = (t, e, r) => e << r - 32 | t >>> 64 - r, rotlBL = (t, e, r) => t << r - 32 | e >>> 64 - r;
function add(t, e, r, n) {
  const i = (e >>> 0) + (n >>> 0);
  return { h: t + r + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const add3L = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0), add3H = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0, add4L = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0), add4H = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0, add5L = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), add5H = (t, e, r, n, i, o) => e + r + n + i + o + (t / 2 ** 32 | 0) | 0, u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
}, [SHA512_Kh, SHA512_Kl] = u64.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t) => BigInt(t))), SHA512_W_H = new Uint32Array(80), SHA512_W_L = new Uint32Array(80);
class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: r, Bh: n, Bl: i, Ch: o, Cl: a, Dh: c, Dl: l, Eh: u, El: f, Fh: d, Fl: p, Gh: g, Gl: h, Hh: m, Hl: y } = this;
    return [e, r, n, i, o, a, c, l, u, f, d, p, g, h, m, y];
  }
  // prettier-ignore
  set(e, r, n, i, o, a, c, l, u, f, d, p, g, h, m, y) {
    this.Ah = e | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = a | 0, this.Dh = c | 0, this.Dl = l | 0, this.Eh = u | 0, this.El = f | 0, this.Fh = d | 0, this.Fl = p | 0, this.Gh = g | 0, this.Gl = h | 0, this.Hh = m | 0, this.Hl = y | 0;
  }
  process(e, r) {
    for (let _ = 0; _ < 16; _++, r += 4)
      SHA512_W_H[_] = e.getUint32(r), SHA512_W_L[_] = e.getUint32(r += 4);
    for (let _ = 16; _ < 80; _++) {
      const E = SHA512_W_H[_ - 15] | 0, w = SHA512_W_L[_ - 15] | 0, S = u64.rotrSH(E, w, 1) ^ u64.rotrSH(E, w, 8) ^ u64.shrSH(E, w, 7), x = u64.rotrSL(E, w, 1) ^ u64.rotrSL(E, w, 8) ^ u64.shrSL(E, w, 7), I = SHA512_W_H[_ - 2] | 0, C = SHA512_W_L[_ - 2] | 0, M = u64.rotrSH(I, C, 19) ^ u64.rotrBH(I, C, 61) ^ u64.shrSH(I, C, 6), O = u64.rotrSL(I, C, 19) ^ u64.rotrBL(I, C, 61) ^ u64.shrSL(I, C, 6), B = u64.add4L(x, O, SHA512_W_L[_ - 7], SHA512_W_L[_ - 16]), k = u64.add4H(B, S, M, SHA512_W_H[_ - 7], SHA512_W_H[_ - 16]);
      SHA512_W_H[_] = k | 0, SHA512_W_L[_] = B | 0;
    }
    let { Ah: n, Al: i, Bh: o, Bl: a, Ch: c, Cl: l, Dh: u, Dl: f, Eh: d, El: p, Fh: g, Fl: h, Gh: m, Gl: y, Hh: b, Hl: v } = this;
    for (let _ = 0; _ < 80; _++) {
      const E = u64.rotrSH(d, p, 14) ^ u64.rotrSH(d, p, 18) ^ u64.rotrBH(d, p, 41), w = u64.rotrSL(d, p, 14) ^ u64.rotrSL(d, p, 18) ^ u64.rotrBL(d, p, 41), S = d & g ^ ~d & m, x = p & h ^ ~p & y, I = u64.add5L(v, w, x, SHA512_Kl[_], SHA512_W_L[_]), C = u64.add5H(I, b, E, S, SHA512_Kh[_], SHA512_W_H[_]), M = I | 0, O = u64.rotrSH(n, i, 28) ^ u64.rotrBH(n, i, 34) ^ u64.rotrBH(n, i, 39), B = u64.rotrSL(n, i, 28) ^ u64.rotrBL(n, i, 34) ^ u64.rotrBL(n, i, 39), k = n & o ^ n & c ^ o & c, U = i & a ^ i & l ^ a & l;
      b = m | 0, v = y | 0, m = g | 0, y = h | 0, g = d | 0, h = p | 0, { h: d, l: p } = u64.add(u | 0, f | 0, C | 0, M | 0), u = c | 0, f = l | 0, c = o | 0, l = a | 0, o = n | 0, a = i | 0;
      const R = u64.add3L(M, B, U);
      n = u64.add3H(R, C, O, k), i = R | 0;
    }
    ({ h: n, l: i } = u64.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: o, l: a } = u64.add(this.Bh | 0, this.Bl | 0, o | 0, a | 0), { h: c, l } = u64.add(this.Ch | 0, this.Cl | 0, c | 0, l | 0), { h: u, l: f } = u64.add(this.Dh | 0, this.Dl | 0, u | 0, f | 0), { h: d, l: p } = u64.add(this.Eh | 0, this.El | 0, d | 0, p | 0), { h: g, l: h } = u64.add(this.Fh | 0, this.Fl | 0, g | 0, h | 0), { h: m, l: y } = u64.add(this.Gh | 0, this.Gl | 0, m | 0, y | 0), { h: b, l: v } = u64.add(this.Hh | 0, this.Hl | 0, b | 0, v | 0), this.set(n, i, o, a, c, l, u, f, d, p, g, h, m, y, b, v);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class SHA512_224 extends SHA512 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
class SHA512_256 extends SHA512 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
class SHA384 extends SHA512 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
const sha512 = wrapConstructor(() => new SHA512());
wrapConstructor(() => new SHA512_224());
wrapConstructor(() => new SHA512_256());
wrapConstructor(() => new SHA384());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0), _1n$2 = BigInt(1), _2n$1 = BigInt(2), _8n = BigInt(8), VERIFY_DEFAULT = { zip215: !0 };
function validateOpts$1(t) {
  const e = validateBasic(t);
  return validateObject(t, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  }), Object.freeze({ ...e });
}
function twistedEdwards(t) {
  const e = validateOpts$1(t), { Fp: r, n, prehash: i, hash: o, randomBytes: a, nByteLength: c, h: l } = e, u = _2n$1 << BigInt(c * 8) - _1n$2, f = r.create, d = e.uvRatio || ((L, A) => {
    try {
      return { isValid: !0, value: r.sqrt(L * r.inv(A)) };
    } catch {
      return { isValid: !1, value: _0n$1 };
    }
  }), p = e.adjustScalarBytes || ((L) => L), g = e.domain || ((L, A, N) => {
    if (A.length || N)
      throw new Error("Contexts/pre-hash are not supported");
    return L;
  }), h = (L) => typeof L == "bigint" && _0n$1 < L, m = (L, A) => h(L) && h(A) && L < A, y = (L) => L === _0n$1 || m(L, u);
  function b(L, A) {
    if (m(L, A))
      return L;
    throw new Error(`Expected valid scalar < ${A}, got ${typeof L} ${L}`);
  }
  function v(L) {
    return L === _0n$1 ? L : b(L, n);
  }
  const _ = /* @__PURE__ */ new Map();
  function E(L) {
    if (!(L instanceof w))
      throw new Error("ExtendedPoint expected");
  }
  class w {
    constructor(A, N, D, F) {
      if (this.ex = A, this.ey = N, this.ez = D, this.et = F, !y(A))
        throw new Error("x required");
      if (!y(N))
        throw new Error("y required");
      if (!y(D))
        throw new Error("z required");
      if (!y(F))
        throw new Error("t required");
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(A) {
      if (A instanceof w)
        throw new Error("extended point not allowed");
      const { x: N, y: D } = A || {};
      if (!y(N) || !y(D))
        throw new Error("invalid affine point");
      return new w(N, D, _1n$2, f(N * D));
    }
    static normalizeZ(A) {
      const N = r.invertBatch(A.map((D) => D.ez));
      return A.map((D, F) => D.toAffine(N[F])).map(w.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(A) {
      this._WINDOW_SIZE = A, _.delete(this);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      const { a: A, d: N } = e;
      if (this.is0())
        throw new Error("bad point: ZERO");
      const { ex: D, ey: F, ez: j, et: K } = this, G = f(D * D), W = f(F * F), H = f(j * j), q = f(H * H), z = f(G * A), Z = f(H * f(z + W)), J = f(q + f(N * f(G * W)));
      if (Z !== J)
        throw new Error("bad point: equation left != right (1)");
      const ee = f(D * F), Q = f(j * K);
      if (ee !== Q)
        throw new Error("bad point: equation left != right (2)");
    }
    // Compare one point to another.
    equals(A) {
      E(A);
      const { ex: N, ey: D, ez: F } = this, { ex: j, ey: K, ez: G } = A, W = f(N * G), H = f(j * F), q = f(D * G), z = f(K * F);
      return W === H && q === z;
    }
    is0() {
      return this.equals(w.ZERO);
    }
    negate() {
      return new w(f(-this.ex), this.ey, this.ez, f(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: A } = e, { ex: N, ey: D, ez: F } = this, j = f(N * N), K = f(D * D), G = f(_2n$1 * f(F * F)), W = f(A * j), H = N + D, q = f(f(H * H) - j - K), z = W + K, Z = z - G, J = W - K, ee = f(q * Z), Q = f(z * J), ne = f(q * J), ae = f(Z * z);
      return new w(ee, Q, ae, ne);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(A) {
      E(A);
      const { a: N, d: D } = e, { ex: F, ey: j, ez: K, et: G } = this, { ex: W, ey: H, ez: q, et: z } = A;
      if (N === BigInt(-1)) {
        const Ce = f((j - F) * (H + W)), Le = f((j + F) * (H - W)), xe = f(Le - Ce);
        if (xe === _0n$1)
          return this.double();
        const Be = f(K * _2n$1 * z), ke = f(G * _2n$1 * q), Ne = ke + Be, Me = Le + Ce, De = ke - Be, He = f(Ne * xe), ze = f(Me * De), qe = f(Ne * De), Ye = f(xe * Me);
        return new w(He, ze, Ye, qe);
      }
      const Z = f(F * W), J = f(j * H), ee = f(G * D * z), Q = f(K * q), ne = f((F + j) * (W + H) - Z - J), ae = Q - ee, me = Q + ee, Te = f(J - N * Z), Ke = f(ne * ae), Ve = f(me * Te), We = f(ne * Te), Ge = f(ae * me);
      return new w(Ke, Ve, Ge, We);
    }
    subtract(A) {
      return this.add(A.negate());
    }
    wNAF(A) {
      return I.wNAFCached(this, _, A, w.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(A) {
      const { p: N, f: D } = this.wNAF(b(A, n));
      return w.normalizeZ([N, D])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(A) {
      let N = v(A);
      return N === _0n$1 ? x : this.equals(x) || N === _1n$2 ? this : this.equals(S) ? this.wNAF(N).p : I.unsafeLadder(this, N);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(l).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return I.unsafeLadder(this, n).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(A) {
      const { ex: N, ey: D, ez: F } = this, j = this.is0();
      A == null && (A = j ? _8n : r.inv(F));
      const K = f(N * A), G = f(D * A), W = f(F * A);
      if (j)
        return { x: _0n$1, y: _1n$2 };
      if (W !== _1n$2)
        throw new Error("invZ was invalid");
      return { x: K, y: G };
    }
    clearCofactor() {
      const { h: A } = e;
      return A === _1n$2 ? this : this.multiplyUnsafe(A);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(A, N = !1) {
      const { d: D, a: F } = e, j = r.BYTES;
      A = ensureBytes$1("pointHex", A, j);
      const K = A.slice(), G = A[j - 1];
      K[j - 1] = G & -129;
      const W = bytesToNumberLE(K);
      W === _0n$1 || (N ? b(W, u) : b(W, r.ORDER));
      const H = f(W * W), q = f(H - _1n$2), z = f(D * H - F);
      let { isValid: Z, value: J } = d(q, z);
      if (!Z)
        throw new Error("Point.fromHex: invalid y coordinate");
      const ee = (J & _1n$2) === _1n$2, Q = (G & 128) !== 0;
      if (!N && J === _0n$1 && Q)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return Q !== ee && (J = f(-J)), w.fromAffine({ x: J, y: W });
    }
    static fromPrivateKey(A) {
      return O(A).point;
    }
    toRawBytes() {
      const { x: A, y: N } = this.toAffine(), D = numberToBytesLE(N, r.BYTES);
      return D[D.length - 1] |= A & _1n$2 ? 128 : 0, D;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  w.BASE = new w(e.Gx, e.Gy, _1n$2, f(e.Gx * e.Gy)), w.ZERO = new w(_0n$1, _1n$2, _1n$2, _0n$1);
  const { BASE: S, ZERO: x } = w, I = wNAF(w, c * 8);
  function C(L) {
    return mod(L, n);
  }
  function M(L) {
    return C(bytesToNumberLE(L));
  }
  function O(L) {
    const A = c;
    L = ensureBytes$1("private key", L, A);
    const N = ensureBytes$1("hashed private key", o(L), 2 * A), D = p(N.slice(0, A)), F = N.slice(A, 2 * A), j = M(D), K = S.multiply(j), G = K.toRawBytes();
    return { head: D, prefix: F, scalar: j, point: K, pointBytes: G };
  }
  function B(L) {
    return O(L).pointBytes;
  }
  function k(L = new Uint8Array(), ...A) {
    const N = concatBytes(...A);
    return M(o(g(N, ensureBytes$1("context", L), !!i)));
  }
  function U(L, A, N = {}) {
    L = ensureBytes$1("message", L), i && (L = i(L));
    const { prefix: D, scalar: F, pointBytes: j } = O(A), K = k(N.context, D, L), G = S.multiply(K).toRawBytes(), W = k(N.context, G, j, L), H = C(K + W * F);
    v(H);
    const q = concatBytes(G, numberToBytesLE(H, r.BYTES));
    return ensureBytes$1("result", q, c * 2);
  }
  const R = VERIFY_DEFAULT;
  function P(L, A, N, D = R) {
    const { context: F, zip215: j } = D, K = r.BYTES;
    L = ensureBytes$1("signature", L, 2 * K), A = ensureBytes$1("message", A), i && (A = i(A));
    const G = bytesToNumberLE(L.slice(K, 2 * K));
    let W, H, q;
    try {
      W = w.fromHex(N, j), H = w.fromHex(L.slice(0, K), j), q = S.multiplyUnsafe(G);
    } catch {
      return !1;
    }
    if (!j && W.isSmallOrder())
      return !1;
    const z = k(F, H.toRawBytes(), W.toRawBytes(), A);
    return H.add(W.multiplyUnsafe(z)).subtract(q).clearCofactor().equals(w.ZERO);
  }
  return S._setWindowSize(8), {
    CURVE: e,
    getPublicKey: B,
    sign: U,
    verify: P,
    ExtendedPoint: w,
    utils: {
      getExtendedPublicKey: O,
      // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
      randomPrivateKey: () => a(r.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(L = 8, A = w.BASE) {
        return A._setWindowSize(L), A.multiply(BigInt(3)), A;
      }
    }
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n = BigInt(0), _1n$1 = BigInt(1);
function validateOpts(t) {
  return validateObject(t, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  }), Object.freeze({ ...t });
}
function montgomery(t) {
  const e = validateOpts(t), { P: r } = e, n = (_) => mod(_, r), i = e.montgomeryBits, o = Math.ceil(i / 8), a = e.nByteLength, c = e.adjustScalarBytes || ((_) => _), l = e.powPminus2 || ((_) => pow(_, r - BigInt(2), r));
  function u(_, E, w) {
    const S = n(_ * (E - w));
    return E = n(E - S), w = n(w + S), [E, w];
  }
  function f(_) {
    if (typeof _ == "bigint" && _0n <= _ && _ < r)
      return _;
    throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
  }
  const d = (e.a - BigInt(2)) / BigInt(4);
  function p(_, E) {
    const w = f(_), S = f(E), x = w;
    let I = _1n$1, C = _0n, M = w, O = _1n$1, B = _0n, k;
    for (let R = BigInt(i - 1); R >= _0n; R--) {
      const P = S >> R & _1n$1;
      B ^= P, k = u(B, I, M), I = k[0], M = k[1], k = u(B, C, O), C = k[0], O = k[1], B = P;
      const T = I + C, L = n(T * T), A = I - C, N = n(A * A), D = L - N, F = M + O, j = M - O, K = n(j * T), G = n(F * A), W = K + G, H = K - G;
      M = n(W * W), O = n(x * n(H * H)), I = n(L * N), C = n(D * (L + n(d * D)));
    }
    k = u(B, I, M), I = k[0], M = k[1], k = u(B, C, O), C = k[0], O = k[1];
    const U = l(C);
    return n(I * U);
  }
  function g(_) {
    return numberToBytesLE(n(_), o);
  }
  function h(_) {
    const E = ensureBytes$1("u coordinate", _, o);
    return a === o && (E[a - 1] &= 127), bytesToNumberLE(E);
  }
  function m(_) {
    const E = ensureBytes$1("scalar", _);
    if (E.length !== o && E.length !== a)
      throw new Error(`Expected ${o} or ${a} bytes, got ${E.length}`);
    return bytesToNumberLE(c(E));
  }
  function y(_, E) {
    const w = h(E), S = m(_), x = p(w, S);
    if (x === _0n)
      throw new Error("Invalid private or public key received");
    return g(x);
  }
  const b = g(e.Gu);
  function v(_) {
    return y(_, b);
  }
  return {
    scalarMult: y,
    scalarMultBase: v,
    getSharedSecret: (_, E) => y(_, E),
    getPublicKey: (_) => v(_),
    utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) },
    GuBytes: b
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5), _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
function ed25519_pow_2_252_3(t) {
  const e = ED25519_P, n = t * t % e * t % e, i = pow2(n, _2n, e) * n % e, o = pow2(i, _1n, e) * t % e, a = pow2(o, _5n, e) * o % e, c = pow2(a, _10n, e) * a % e, l = pow2(c, _20n, e) * c % e, u = pow2(l, _40n, e) * l % e, f = pow2(u, _80n, e) * u % e, d = pow2(f, _80n, e) * u % e, p = pow2(d, _10n, e) * a % e;
  return { pow_p_5_8: pow2(p, _2n, e) * t % e, b2: n };
}
function adjustScalarBytes(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
function uvRatio(t, e) {
  const r = ED25519_P, n = mod(e * e * e, r), i = mod(n * n * e, r), o = ed25519_pow_2_252_3(t * i).pow_p_5_8;
  let a = mod(t * n * o, r);
  const c = mod(e * a * a, r), l = a, u = mod(a * ED25519_SQRT_M1, r), f = c === t, d = c === mod(-t, r), p = c === mod(-t * ED25519_SQRT_M1, r);
  return f && (a = l), (d || p) && (a = u), isNegativeLE(a, r) && (a = mod(-a, r)), { isValid: f || d, value: a };
}
const Fp = Field(ED25519_P, void 0, !0), ed25519Defaults = {
  // Param: a
  a: BigInt(-1),
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field p over which we'll do calculations; 2n**255n - 19n
  Fp,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: BigInt(8),
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes: randomBytes$2,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
};
twistedEdwards(ed25519Defaults);
function ed25519_domain(t, e, r) {
  if (e.length > 255)
    throw new Error("Context is too big");
  return concatBytes$1(utf8ToBytes$2("SigEd25519 no Ed25519 collisions"), new Uint8Array([r ? 1 : 0, e.length]), e, t);
}
twistedEdwards({ ...ed25519Defaults, domain: ed25519_domain });
twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain,
  prehash: sha512
});
const x25519 = /* @__PURE__ */ (() => montgomery({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (t) => {
    const e = ED25519_P, { pow_p_5_8: r, b2: n } = ed25519_pow_2_252_3(t);
    return mod(pow2(r, BigInt(3), e) * n, e);
  },
  adjustScalarBytes,
  randomBytes: randomBytes$2
}))(), ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
Fp.pow(_2n, ELL2_C1);
Fp.sqrt(Fp.neg(Fp.ONE));
(Fp.ORDER - BigInt(5)) / BigInt(8);
BigInt(486662);
FpSqrtEven(Fp, Fp.neg(BigInt(486664)));
BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function extract(t, e, r) {
  return assert$1.hash(t), r === void 0 && (r = new Uint8Array(t.outputLen)), hmac(t, toBytes$3(r), toBytes$3(e));
}
const HKDF_COUNTER = new Uint8Array([0]), EMPTY_BUFFER$4 = new Uint8Array();
function expand$2(t, e, r, n = 32) {
  if (assert$1.hash(t), assert$1.number(n), n > 255 * t.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const i = Math.ceil(n / t.outputLen);
  r === void 0 && (r = EMPTY_BUFFER$4);
  const o = new Uint8Array(i * t.outputLen), a = hmac.create(t, e), c = a._cloneInto(), l = new Uint8Array(a.outputLen);
  for (let u = 0; u < i; u++)
    HKDF_COUNTER[0] = u + 1, c.update(u === 0 ? EMPTY_BUFFER$4 : l).update(r).update(HKDF_COUNTER).digestInto(l), o.set(l, t.outputLen * u), a._cloneInto(c);
  return a.destroy(), c.destroy(), l.fill(0), HKDF_COUNTER.fill(0), o.slice(0, n);
}
const pureJsCrypto = {
  hashSHA256(t) {
    return sha256$1(t);
  },
  getHKDF(t, e) {
    const r = extract(sha256$1, e, t), i = expand$2(sha256$1, r, void 0, 96), o = i.subarray(0, 32), a = i.subarray(32, 64), c = i.subarray(64, 96);
    return [o, a, c];
  },
  generateX25519KeyPair() {
    const t = x25519.utils.randomPrivateKey();
    return {
      publicKey: x25519.getPublicKey(t),
      privateKey: t
    };
  },
  generateX25519KeyPairFromSeed(t) {
    return {
      publicKey: x25519.getPublicKey(t),
      privateKey: t
    };
  },
  generateX25519SharedKey(t, e) {
    return x25519.getSharedSecret(t, e);
  },
  chaCha20Poly1305Encrypt(t, e, r, n) {
    return chacha20_poly1305(n, e, r).encrypt(t);
  },
  chaCha20Poly1305Decrypt(t, e, r, n, i) {
    const o = chacha20_poly1305(n, e, r).decrypt(t);
    return i && i.set(o), o;
  }
}, allocUnsafe = (t) => globalThis.Buffer ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t), uint16BEEncode = (t) => {
  const e = allocUnsafe(2);
  return new DataView(e.buffer, e.byteOffset, e.byteLength).setUint16(0, t, !1), e;
};
uint16BEEncode.bytes = 2;
const uint16BEDecode = (t) => {
  if (t.length < 2)
    throw RangeError("Could not decode int16BE");
  return t instanceof Uint8Array ? new DataView(t.buffer, t.byteOffset, t.byteLength).getUint16(0, !1) : t.getUint16(0);
};
uint16BEDecode.bytes = 2;
function encode0(t) {
  return concat$6([t.ne, t.ciphertext], t.ne.length + t.ciphertext.length);
}
function encode1(t) {
  return concat$6([t.ne, t.ns, t.ciphertext], t.ne.length + t.ns.length + t.ciphertext.length);
}
function encode2(t) {
  return concat$6([t.ns, t.ciphertext], t.ns.length + t.ciphertext.length);
}
function decode0(t) {
  if (t.length < 32)
    throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
  return {
    ne: t.subarray(0, 32),
    ciphertext: t.subarray(32, t.length),
    ns: new Uint8Array(0)
  };
}
function decode1(t) {
  if (t.length < 80)
    throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
  return {
    ne: t.subarray(0, 32),
    ns: t.subarray(32, 80),
    ciphertext: t.subarray(80, t.length)
  };
}
function decode2(t) {
  if (t.length < 48)
    throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
  return {
    ne: new Uint8Array(0),
    ns: t.subarray(0, 48),
    ciphertext: t.subarray(48, t.length)
  };
}
const CHACHA_TAG_LENGTH = 16;
function encryptStream(t, e) {
  return async function* (r) {
    for await (const n of r)
      for (let i = 0; i < n.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let o = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        o > n.length && (o = n.length);
        const a = t.encrypt(n.subarray(i, o), t.session);
        e == null || e.encryptedPackets.increment(), yield uint16BEEncode(a.byteLength), yield a;
      }
  };
}
function decryptStream(t, e) {
  return async function* (r) {
    for await (const n of r)
      for (let i = 0; i < n.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {
        let o = i + NOISE_MSG_MAX_LENGTH_BYTES;
        if (o > n.length && (o = n.length), o - CHACHA_TAG_LENGTH < i)
          throw new Error("Invalid chunk");
        const a = n.subarray(i, o), c = n.subarray(i, o - CHACHA_TAG_LENGTH), { plaintext: l, valid: u } = t.decrypt(a, t.session, c);
        if (!u)
          throw e == null || e.decryptErrors.increment(), new Error("Failed to validate decrypted chunk");
        e == null || e.decryptedPackets.increment(), yield l;
      }
  };
}
var NoiseExtensions;
(function(t) {
  let e;
  t.codec = () => (e == null && (e = message$1((r, n, i = {}) => {
    if (i.lengthDelimited !== !1 && n.fork(), r.webtransportCerthashes != null)
      for (const o of r.webtransportCerthashes)
        n.uint32(10), n.bytes(o);
    i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {
      webtransportCerthashes: []
    }, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.webtransportCerthashes.push(r.bytes());
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage$1(r, t.codec()), t.decode = (r) => decodeMessage$1(r, t.codec());
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(t) {
  let e;
  t.codec = () => (e == null && (e = message$1((r, n, i = {}) => {
    i.lengthDelimited !== !1 && n.fork(), (i.writeDefaults === !0 || r.identityKey != null && r.identityKey.byteLength > 0) && (n.uint32(10), n.bytes(r.identityKey ?? new Uint8Array(0))), (i.writeDefaults === !0 || r.identitySig != null && r.identitySig.byteLength > 0) && (n.uint32(18), n.bytes(r.identitySig ?? new Uint8Array(0))), r.extensions != null && (n.uint32(34), NoiseExtensions.codec().encode(r.extensions, n, {
      writeDefaults: !1
    })), i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {
      identityKey: new Uint8Array(0),
      identitySig: new Uint8Array(0)
    }, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 1:
          i.identityKey = r.bytes();
          break;
        case 2:
          i.identitySig = r.bytes();
          break;
        case 4:
          i.extensions = NoiseExtensions.codec().decode(r, r.uint32());
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage$1(r, t.codec()), t.decode = (r) => decodeMessage$1(r, t.codec());
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));
async function getPayload(t, e, r) {
  const n = await signPayload(t, getHandshakePayload(e));
  if (t.publicKey == null)
    throw new Error("PublicKey was missing from local PeerId");
  return createHandshakePayload(t.publicKey, n, r);
}
function createHandshakePayload(t, e, r) {
  return NoiseHandshakePayload.encode({
    identityKey: t,
    identitySig: e,
    extensions: r ?? { webtransportCerthashes: [] }
  }).subarray();
}
async function signPayload(t, e) {
  if (t.privateKey == null)
    throw new Error("PrivateKey was missing from PeerId");
  return (await unmarshalPrivateKey(t.privateKey)).sign(e);
}
async function getPeerIdFromPayload(t) {
  return peerIdFromKeys(t.identityKey);
}
function decodePayload(t) {
  return NoiseHandshakePayload.decode(t);
}
function getHandshakePayload(t) {
  const e = fromString$3("noise-libp2p-static-key:");
  return concat$6([e, t], e.length + t.length);
}
async function verifySignedPayload(t, e, r) {
  const n = await peerIdFromKeys(e.identityKey);
  if (!n.equals(r))
    throw new Error(`Payload identity key ${n.toString()} does not match expected remote peer ${r.toString()}`);
  const i = getHandshakePayload(t);
  if (n.publicKey == null)
    throw new Error("PublicKey was missing from PeerId");
  if (e.identitySig == null)
    throw new Error("Signature was missing from message");
  if (!await unmarshalPublicKey(n.publicKey).verify(i, e.identitySig))
    throw new Error("Static key doesn't match to peer that signed payload!");
  return n;
}
function isValidPublicKey(t) {
  return !(!(t instanceof Uint8Array) || t.length !== 32);
}
const log$a = logger$1("libp2p:noise");
let keyLogger;
DUMP_SESSION_KEYS ? keyLogger = log$a : keyLogger = Object.assign(() => {
}, {
  enabled: !1,
  trace: () => {
  },
  error: () => {
  }
});
function logLocalStaticKeys(t) {
  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString$4(t.publicKey, "hex")}`), keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString$4(t.privateKey, "hex")}`);
}
function logLocalEphemeralKeys(t) {
  t ? (keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString$4(t.publicKey, "hex")}`), keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString$4(t.privateKey, "hex")}`)) : keyLogger("Missing local ephemeral keys.");
}
function logRemoteStaticKey(t) {
  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString$4(t, "hex")}`);
}
function logRemoteEphemeralKey(t) {
  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString$4(t, "hex")}`);
}
function logCipherState(t) {
  t.cs1 && t.cs2 ? (keyLogger(`CIPHER_STATE_1 ${t.cs1.n.getUint64()} ${toString$4(t.cs1.k, "hex")}`), keyLogger(`CIPHER_STATE_2 ${t.cs2.n.getUint64()} ${toString$4(t.cs2.k, "hex")}`)) : keyLogger("Missing cipher state.");
}
const MIN_NONCE = 0, MAX_NONCE = 4294967295, ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
class Nonce {
  constructor(e = MIN_NONCE) {
    $(this, "n");
    $(this, "bytes");
    $(this, "view");
    this.n = e, this.bytes = new Uint8Array(12), this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength), this.view.setUint32(4, e, !0);
  }
  increment() {
    this.n++, this.view.setUint32(4, this.n, !0);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE)
      throw new Error(ERR_MAX_NONCE);
  }
}
class AbstractHandshake {
  constructor(e) {
    $(this, "crypto");
    this.crypto = e;
  }
  encryptWithAd(e, r, n) {
    const i = this.encrypt(e.k, e.n, r, n);
    return e.n.increment(), i;
  }
  decryptWithAd(e, r, n, i) {
    const { plaintext: o, valid: a } = this.decrypt(e.k, e.n, r, n, i);
    return a && e.n.increment(), { plaintext: o, valid: a };
  }
  // Cipher state related
  hasKey(e) {
    return !this.isEmptyKey(e.k);
  }
  createEmptyKey() {
    return new Uint8Array(32);
  }
  isEmptyKey(e) {
    const r = this.createEmptyKey();
    return equals$2(r, e);
  }
  encrypt(e, r, n, i) {
    return r.assertValue(), this.crypto.chaCha20Poly1305Encrypt(i, r.getBytes(), n, e);
  }
  encryptAndHash(e, r) {
    let n;
    return this.hasKey(e.cs) ? n = this.encryptWithAd(e.cs, e.h, r) : n = r, this.mixHash(e, n), n;
  }
  decrypt(e, r, n, i, o) {
    r.assertValue();
    const a = this.crypto.chaCha20Poly1305Decrypt(i, r.getBytes(), n, e, o);
    return a ? {
      plaintext: a,
      valid: !0
    } : {
      plaintext: new Uint8Array(0),
      valid: !1
    };
  }
  decryptAndHash(e, r) {
    let n, i = !0;
    return this.hasKey(e.cs) ? { plaintext: n, valid: i } = this.decryptWithAd(e.cs, e.h, r) : n = r, this.mixHash(e, r), { plaintext: n, valid: i };
  }
  dh(e, r) {
    try {
      const n = this.crypto.generateX25519SharedKey(e, r);
      return n.length === 32 ? n : n.subarray(0, 32);
    } catch (n) {
      const i = n;
      return log$a.error(i), new Uint8Array(32);
    }
  }
  mixHash(e, r) {
    e.h = this.getHash(e.h, r);
  }
  getHash(e, r) {
    return this.crypto.hashSHA256(concat$6([e, r], e.length + r.length));
  }
  mixKey(e, r) {
    const [n, i] = this.crypto.getHKDF(e.ck, r);
    e.cs = this.initializeKey(i), e.ck = n;
  }
  initializeKey(e) {
    return { k: e, n: new Nonce() };
  }
  // Symmetric state related
  initializeSymmetric(e) {
    const r = fromString$3(e, "utf-8"), n = this.hashProtocolName(r), i = n, o = this.createEmptyKey();
    return { cs: this.initializeKey(o), ck: i, h: n };
  }
  hashProtocolName(e) {
    if (e.length <= 32) {
      const r = new Uint8Array(32);
      return r.set(e), r;
    } else
      return this.getHash(e, new Uint8Array(0));
  }
  split(e) {
    const [r, n] = this.crypto.getHKDF(e.ck, new Uint8Array(0)), i = this.initializeKey(r), o = this.initializeKey(n);
    return { cs1: i, cs2: o };
  }
  writeMessageRegular(e, r) {
    const n = this.encryptWithAd(e, new Uint8Array(0), r), i = this.createEmptyKey(), o = new Uint8Array(0);
    return { ne: i, ns: o, ciphertext: n };
  }
  readMessageRegular(e, r) {
    return this.decryptWithAd(e, new Uint8Array(0), r.ciphertext);
  }
}
class XX extends AbstractHandshake {
  initializeInitiator(e, r, n, i) {
    const o = "Noise_XX_25519_ChaChaPoly_SHA256", a = this.initializeSymmetric(o);
    this.mixHash(a, e);
    const c = new Uint8Array(32);
    return { ss: a, s: r, rs: n, psk: i, re: c };
  }
  initializeResponder(e, r, n, i) {
    const o = "Noise_XX_25519_ChaChaPoly_SHA256", a = this.initializeSymmetric(o);
    this.mixHash(a, e);
    const c = new Uint8Array(32);
    return { ss: a, s: r, rs: n, psk: i, re: c };
  }
  writeMessageA(e, r, n) {
    const i = new Uint8Array(0);
    n !== void 0 ? e.e = n : e.e = this.crypto.generateX25519KeyPair();
    const o = e.e.publicKey;
    this.mixHash(e.ss, o);
    const a = this.encryptAndHash(e.ss, r);
    return { ne: o, ns: i, ciphertext: a };
  }
  writeMessageB(e, r) {
    e.e = this.crypto.generateX25519KeyPair();
    const n = e.e.publicKey;
    this.mixHash(e.ss, n), this.mixKey(e.ss, this.dh(e.e.privateKey, e.re));
    const i = e.s.publicKey, o = this.encryptAndHash(e.ss, i);
    this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
    const a = this.encryptAndHash(e.ss, r);
    return { ne: n, ns: o, ciphertext: a };
  }
  writeMessageC(e, r) {
    const n = e.s.publicKey, i = this.encryptAndHash(e.ss, n);
    this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
    const o = this.encryptAndHash(e.ss, r), c = { ne: this.createEmptyKey(), ns: i, ciphertext: o }, { cs1: l, cs2: u } = this.split(e.ss);
    return { h: e.ss.h, messageBuffer: c, cs1: l, cs2: u };
  }
  readMessageA(e, r) {
    return isValidPublicKey(r.ne) && (e.re = r.ne), this.mixHash(e.ss, e.re), this.decryptAndHash(e.ss, r.ciphertext);
  }
  readMessageB(e, r) {
    if (isValidPublicKey(r.ne) && (e.re = r.ne), this.mixHash(e.ss, e.re), !e.e)
      throw new Error("Handshake state `e` param is missing.");
    this.mixKey(e.ss, this.dh(e.e.privateKey, e.re));
    const { plaintext: n, valid: i } = this.decryptAndHash(e.ss, r.ns);
    i && isValidPublicKey(n) && (e.rs = n), this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
    const { plaintext: o, valid: a } = this.decryptAndHash(e.ss, r.ciphertext);
    return { plaintext: o, valid: i && a };
  }
  readMessageC(e, r) {
    const { plaintext: n, valid: i } = this.decryptAndHash(e.ss, r.ns);
    if (i && isValidPublicKey(n) && (e.rs = n), !e.e)
      throw new Error("Handshake state `e` param is missing.");
    this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
    const { plaintext: o, valid: a } = this.decryptAndHash(e.ss, r.ciphertext), { cs1: c, cs2: l } = this.split(e.ss);
    return { h: e.ss.h, plaintext: o, valid: i && a, cs1: c, cs2: l };
  }
  initSession(e, r, n) {
    const i = this.createEmptyKey(), o = new Uint8Array(32);
    let a;
    return e ? a = this.initializeInitiator(r, n, o, i) : a = this.initializeResponder(r, n, o, i), {
      hs: a,
      i: e,
      mc: 0
    };
  }
  sendMessage(e, r, n) {
    let i;
    if (e.mc === 0)
      i = this.writeMessageA(e.hs, r, n);
    else if (e.mc === 1)
      i = this.writeMessageB(e.hs, r);
    else if (e.mc === 2) {
      const { h: o, messageBuffer: a, cs1: c, cs2: l } = this.writeMessageC(e.hs, r);
      i = a, e.h = o, e.cs1 = c, e.cs2 = l;
    } else if (e.mc > 2)
      if (e.i) {
        if (!e.cs1)
          throw new Error("CS1 (cipher state) is not defined");
        i = this.writeMessageRegular(e.cs1, r);
      } else {
        if (!e.cs2)
          throw new Error("CS2 (cipher state) is not defined");
        i = this.writeMessageRegular(e.cs2, r);
      }
    else
      throw new Error("Session invalid.");
    return e.mc++, i;
  }
  recvMessage(e, r) {
    let n = new Uint8Array(0), i = !1;
    if (e.mc === 0)
      ({ plaintext: n, valid: i } = this.readMessageA(e.hs, r));
    else if (e.mc === 1)
      ({ plaintext: n, valid: i } = this.readMessageB(e.hs, r));
    else if (e.mc === 2) {
      const { h: o, plaintext: a, valid: c, cs1: l, cs2: u } = this.readMessageC(e.hs, r);
      n = a, i = c, e.h = o, e.cs1 = l, e.cs2 = u;
    }
    return e.mc++, { plaintext: n, valid: i };
  }
}
class XXHandshake {
  constructor(e, r, n, i, o, a, c, l) {
    $(this, "isInitiator");
    $(this, "session");
    $(this, "remotePeer");
    $(this, "remoteExtensions", { webtransportCerthashes: [] });
    $(this, "payload");
    $(this, "connection");
    $(this, "xx");
    $(this, "staticKeypair");
    $(this, "prologue");
    this.isInitiator = e, this.payload = r, this.prologue = n, this.staticKeypair = o, this.connection = a, c && (this.remotePeer = c), this.xx = l ?? new XX(i), this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
  }
  // stage 0
  async propose() {
    if (logLocalStaticKeys(this.session.hs.s), this.isInitiator) {
      log$a.trace("Stage 0 - Initiator starting to send first message.");
      const e = this.xx.sendMessage(this.session, new Uint8Array(0));
      await this.connection.write(encode0(e)), log$a.trace("Stage 0 - Initiator finished sending first message."), logLocalEphemeralKeys(this.session.hs.e);
    } else {
      log$a.trace("Stage 0 - Responder waiting to receive first message...");
      const e = decode0((await this.connection.read()).subarray()), { valid: r } = this.xx.recvMessage(this.session, e);
      if (!r)
        throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");
      log$a.trace("Stage 0 - Responder received first message."), logRemoteEphemeralKey(this.session.hs.re);
    }
  }
  // stage 1
  async exchange() {
    if (this.isInitiator) {
      log$a.trace("Stage 1 - Initiator waiting to receive first message from responder...");
      const e = decode1((await this.connection.read()).subarray()), { plaintext: r, valid: n } = this.xx.recvMessage(this.session, e);
      if (!n)
        throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");
      log$a.trace("Stage 1 - Initiator received the message."), logRemoteEphemeralKey(this.session.hs.re), logRemoteStaticKey(this.session.hs.rs), log$a.trace("Initiator going to check remote's signature...");
      try {
        const i = decodePayload(r);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(i), await verifySignedPayload(this.session.hs.rs, i, this.remotePeer), this.setRemoteNoiseExtension(i.extensions);
      } catch (i) {
        const o = i;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${o.message}`);
      }
      log$a.trace("All good with the signature!");
    } else {
      log$a.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
      const e = this.xx.sendMessage(this.session, this.payload);
      await this.connection.write(encode1(e)), log$a.trace("Stage 1 - Responder sent the second handshake message with signed payload."), logLocalEphemeralKeys(this.session.hs.e);
    }
  }
  // stage 2
  async finish() {
    if (this.isInitiator) {
      log$a.trace("Stage 2 - Initiator sending third handshake message.");
      const e = this.xx.sendMessage(this.session, this.payload);
      await this.connection.write(encode2(e)), log$a.trace("Stage 2 - Initiator sent message with signed payload.");
    } else {
      log$a.trace("Stage 2 - Responder waiting for third handshake message...");
      const e = decode2((await this.connection.read()).subarray()), { plaintext: r, valid: n } = this.xx.recvMessage(this.session, e);
      if (!n)
        throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");
      log$a.trace("Stage 2 - Responder received the message, finished handshake.");
      try {
        const i = decodePayload(r);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(i), await verifySignedPayload(this.session.hs.rs, i, this.remotePeer), this.setRemoteNoiseExtension(i.extensions);
      } catch (i) {
        const o = i;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${o.message}`);
      }
    }
    logCipherState(this.session);
  }
  encrypt(e, r) {
    const n = this.getCS(r);
    return this.xx.encryptWithAd(n, new Uint8Array(0), e);
  }
  decrypt(e, r, n) {
    const i = this.getCS(r, !1);
    return this.xx.decryptWithAd(i, new Uint8Array(0), e, n);
  }
  getRemoteStaticKey() {
    return this.session.hs.rs;
  }
  getCS(e, r = !0) {
    if (!e.cs1 || !e.cs2)
      throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");
    return this.isInitiator ? r ? e.cs1 : e.cs2 : r ? e.cs2 : e.cs1;
  }
  setRemoteNoiseExtension(e) {
    e && (this.remoteExtensions = e);
  }
}
function registerMetrics(t) {
  return {
    xxHandshakeSuccesses: t.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: t.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: t.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: t.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: t.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}
class Noise {
  constructor(e = {}) {
    $(this, "protocol", "/noise");
    $(this, "crypto");
    $(this, "prologue");
    $(this, "staticKeys");
    $(this, "extensions");
    $(this, "metrics");
    const { staticNoiseKey: r, extensions: n, crypto: i, prologueBytes: o, metrics: a } = e;
    this.crypto = i ?? pureJsCrypto, this.extensions = n, this.metrics = a ? registerMetrics(a) : void 0, r ? this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(r) : this.staticKeys = this.crypto.generateX25519KeyPair(), this.prologue = o ?? new Uint8Array(0);
  }
  /**
   * Encrypt outgoing data to the remote party (handshake as initiator)
   *
   * @param {PeerId} localPeer - PeerId of the receiving peer
   * @param {Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>} connection - streaming iterable duplex that will be encrypted
   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.
   * @returns {Promise<SecuredConnection>}
   */
  async secureOutbound(e, r, n) {
    const i = lpStream(r, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    }), o = await this.performHandshake({
      connection: i,
      isInitiator: !0,
      localPeer: e,
      remotePeer: n
    });
    return {
      conn: await this.createSecureConnection(i, o),
      remoteExtensions: o.remoteExtensions,
      remotePeer: o.remotePeer
    };
  }
  /**
   * Decrypt incoming data (handshake as responder).
   *
   * @param {PeerId} localPeer - PeerId of the receiving peer.
   * @param {Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>} connection - streaming iterable duplex that will be encryption.
   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.
   * @returns {Promise<SecuredConnection>}
   */
  async secureInbound(e, r, n) {
    const i = lpStream(r, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    }), o = await this.performHandshake({
      connection: i,
      isInitiator: !1,
      localPeer: e,
      remotePeer: n
    });
    return {
      conn: await this.createSecureConnection(i, o),
      remotePeer: o.remotePeer,
      remoteExtensions: o.remoteExtensions
    };
  }
  /**
   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.
   * If noise pipes disabled or remote peer static key is unknown, use XX.
   *
   * @param {HandshakeParams} params
   */
  async performHandshake(e) {
    const r = await getPayload(e.localPeer, this.staticKeys.publicKey, this.extensions);
    return this.performXXHandshake(e, r);
  }
  async performXXHandshake(e, r) {
    var c, l;
    const { isInitiator: n, remotePeer: i, connection: o } = e, a = new XXHandshake(n, r, this.prologue, this.crypto, this.staticKeys, o, i);
    try {
      await a.propose(), await a.exchange(), await a.finish(), (c = this.metrics) == null || c.xxHandshakeSuccesses.increment();
    } catch (u) {
      if ((l = this.metrics) == null || l.xxHandshakeErrors.increment(), u instanceof Error)
        throw u.message = `Error occurred during XX handshake: ${u.message}`, u;
    }
    return a;
  }
  async createSecureConnection(e, r) {
    const [n, i] = duplexPair(), o = e.unwrap();
    return await pipe$2(
      n,
      // write to wrapper
      encryptStream(r, this.metrics),
      // encrypt data + prefix with message length
      o,
      // send to the remote peer
      (a) => decode$2(a, { lengthDecoder: uint16BEDecode }),
      // read message length prefix
      decryptStream(r, this.metrics),
      // decrypt the incoming data
      n
      // pipe to the wrapper
    ), i;
  }
}
function noise(t = {}) {
  return () => new Noise(t);
}
const ERR_INVALID_FRAME = "ERR_INVALID_FRAME", ERR_UNREQUESTED_PING = "ERR_UNREQUESTED_PING", ERR_NOT_MATCHING_PING = "ERR_NOT_MATCHING_PING", ERR_STREAM_ALREADY_EXISTS = "ERR_STREAM_ALREADY_EXISTS", ERR_DECODE_INVALID_VERSION = "ERR_DECODE_INVALID_VERSION", ERR_BOTH_CLIENTS = "ERR_BOTH_CLIENTS", ERR_RECV_WINDOW_EXCEEDED = "ERR_RECV_WINDOW_EXCEEDED", PROTOCOL_ERRORS = /* @__PURE__ */ new Set([
  ERR_INVALID_FRAME,
  ERR_UNREQUESTED_PING,
  ERR_NOT_MATCHING_PING,
  ERR_STREAM_ALREADY_EXISTS,
  ERR_DECODE_INVALID_VERSION,
  ERR_BOTH_CLIENTS,
  ERR_RECV_WINDOW_EXCEEDED
]), ERR_INVALID_CONFIG = "ERR_INVALID_CONFIG", ERR_MUXER_LOCAL_CLOSED = "ERR_MUXER_LOCAL_CLOSED", ERR_MUXER_REMOTE_CLOSED = "ERR_MUXER_REMOTE_CLOSED", ERR_STREAM_ABORT = "ERR_STREAM_ABORT", ERR_MAX_OUTBOUND_STREAMS_EXCEEDED = "ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED", ERR_DECODE_IN_PROGRESS = "ERR_DECODE_IN_PROGRESS", INITIAL_STREAM_WINDOW = 256 * 1024, MAX_STREAM_WINDOW = 16 * 1024 * 1024, defaultConfig = {
  log: logger$1("libp2p:yamux"),
  enableKeepAlive: !0,
  keepAliveInterval: 3e4,
  maxInboundStreams: 1e3,
  maxOutboundStreams: 1e3,
  initialStreamWindowSize: INITIAL_STREAM_WINDOW,
  maxStreamWindowSize: MAX_STREAM_WINDOW,
  maxMessageSize: 64 * 1024
};
function verifyConfig(t) {
  if (t.keepAliveInterval <= 0)
    throw new CodeError$2("keep-alive interval must be positive", ERR_INVALID_CONFIG);
  if (t.maxInboundStreams < 0)
    throw new CodeError$2("max inbound streams must be larger or equal 0", ERR_INVALID_CONFIG);
  if (t.maxOutboundStreams < 0)
    throw new CodeError$2("max outbound streams must be larger or equal 0", ERR_INVALID_CONFIG);
  if (t.initialStreamWindowSize < INITIAL_STREAM_WINDOW)
    throw new CodeError$2("InitialStreamWindowSize must be larger or equal 256 kB", ERR_INVALID_CONFIG);
  if (t.maxStreamWindowSize < t.initialStreamWindowSize)
    throw new CodeError$2("MaxStreamWindowSize must be larger than the InitialStreamWindowSize", ERR_INVALID_CONFIG);
  if (t.maxStreamWindowSize > 2 ** 32 - 1)
    throw new CodeError$2("MaxStreamWindowSize must be less than equal MAX_UINT32", ERR_INVALID_CONFIG);
  if (t.maxMessageSize < 1024)
    throw new CodeError$2("MaxMessageSize must be greater than a kilobyte", ERR_INVALID_CONFIG);
}
var FrameType;
(function(t) {
  t[t.Data = 0] = "Data", t[t.WindowUpdate = 1] = "WindowUpdate", t[t.Ping = 2] = "Ping", t[t.GoAway = 3] = "GoAway";
})(FrameType || (FrameType = {}));
var Flag;
(function(t) {
  t[t.SYN = 1] = "SYN", t[t.ACK = 2] = "ACK", t[t.FIN = 4] = "FIN", t[t.RST = 8] = "RST";
})(Flag || (Flag = {}));
const flagCodes = Object.values(Flag).filter((t) => typeof t != "string"), YAMUX_VERSION = 0;
var GoAwayCode;
(function(t) {
  t[t.NormalTermination = 0] = "NormalTermination", t[t.ProtocolError = 1] = "ProtocolError", t[t.InternalError = 2] = "InternalError";
})(GoAwayCode || (GoAwayCode = {}));
const HEADER_LENGTH = 12;
function stringifyHeader(t) {
  const e = flagCodes.filter((r) => (t.flag & r) === r).map((r) => Flag[r]).join("|");
  return `streamID=${t.streamID} type=${FrameType[t.type]} flag=${e} length=${t.length}`;
}
const twoPow24 = 2 ** 24;
function decodeHeader(t) {
  if (t[0] !== YAMUX_VERSION)
    throw new CodeError$2("Invalid frame version", ERR_DECODE_INVALID_VERSION);
  return {
    type: t[1],
    flag: (t[2] << 8) + t[3],
    streamID: t[4] * twoPow24 + (t[5] << 16) + (t[6] << 8) + t[7],
    length: t[8] * twoPow24 + (t[9] << 16) + (t[10] << 8) + t[11]
  };
}
class Decoder {
  constructor(e) {
    $(this, "source");
    /** Buffer for in-progress frames */
    $(this, "buffer");
    /** Used to sanity check against decoding while in an inconsistent state */
    $(this, "frameInProgress");
    this.source = returnlessSource(e), this.buffer = new Uint8ArrayList(), this.frameInProgress = !1;
  }
  /**
   * Emits frames from the decoder source.
   *
   * Note: If `readData` is emitted, it _must_ be called before the next iteration
   * Otherwise an error is thrown
   */
  async *emitFrames() {
    for await (const e of this.source)
      for (this.buffer.append(e); ; ) {
        const r = this.readHeader();
        if (r === void 0)
          break;
        const { type: n, length: i } = r;
        n === FrameType.Data ? (this.frameInProgress = !0, yield {
          header: r,
          readData: this.readBytes.bind(this, i)
        }) : yield { header: r };
      }
  }
  readHeader() {
    if (this.frameInProgress)
      throw new CodeError$2("decoding frame already in progress", ERR_DECODE_IN_PROGRESS);
    if (this.buffer.length < HEADER_LENGTH)
      return;
    const e = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
    return this.buffer.consume(HEADER_LENGTH), e;
  }
  async readBytes(e) {
    if (this.buffer.length < e) {
      for await (const n of this.source)
        if (this.buffer.append(n), this.buffer.length >= e)
          break;
    }
    const r = this.buffer.sublist(0, e);
    return this.buffer.consume(e), this.frameInProgress = !1, r;
  }
}
function returnlessSource(t) {
  if (t[Symbol.iterator] !== void 0) {
    const e = t[Symbol.iterator]();
    return e.return = void 0, {
      [Symbol.iterator]() {
        return e;
      }
    };
  } else if (t[Symbol.asyncIterator] !== void 0) {
    const e = t[Symbol.asyncIterator]();
    return e.return = void 0, {
      [Symbol.asyncIterator]() {
        return e;
      }
    };
  } else
    throw new Error("a source must be either an iterable or an async iterable");
}
function encodeHeader(t) {
  const e = new Uint8Array(HEADER_LENGTH);
  return e[1] = t.type, e[2] = t.flag >>> 8, e[3] = t.flag, e[4] = t.streamID >>> 24, e[5] = t.streamID >>> 16, e[6] = t.streamID >>> 8, e[7] = t.streamID, e[8] = t.length >>> 24, e[9] = t.length >>> 16, e[10] = t.length >>> 8, e[11] = t.length, e;
}
const ERR_STREAM_RESET = "ERR_STREAM_RESET", ERR_SINK_INVALID_STATE = "ERR_SINK_INVALID_STATE";
function isPromise$2(t) {
  return t != null && typeof t.then == "function";
}
class AbstractStream {
  constructor(e) {
    $(this, "id");
    $(this, "direction");
    $(this, "timeline");
    $(this, "protocol");
    $(this, "metadata");
    $(this, "source");
    $(this, "status");
    $(this, "readStatus");
    $(this, "writeStatus");
    $(this, "sinkController");
    $(this, "sinkEnd");
    $(this, "endErr");
    $(this, "streamSource");
    $(this, "onEnd");
    $(this, "onCloseRead");
    $(this, "onCloseWrite");
    $(this, "onReset");
    $(this, "onAbort");
    $(this, "log");
    this.sinkController = new AbortController(), this.sinkEnd = pDefer(), this.log = e.log, this.status = "open", this.readStatus = "ready", this.writeStatus = "ready", this.id = e.id, this.metadata = e.metadata ?? {}, this.direction = e.direction, this.timeline = {
      open: Date.now()
    }, this.onEnd = e.onEnd, this.onCloseRead = e == null ? void 0 : e.onCloseRead, this.onCloseWrite = e == null ? void 0 : e.onCloseWrite, this.onReset = e == null ? void 0 : e.onReset, this.onAbort = e == null ? void 0 : e.onAbort, this.source = this.streamSource = pushable({
      onEnd: (r) => {
        r != null ? this.log.trace("source ended with error", r) : this.log.trace("source ended"), this.readStatus = "closed", this.onSourceEnd(r);
      }
    }), this.sink = this.sink.bind(this);
  }
  async sink(e) {
    if (this.writeStatus !== "ready")
      throw new CodeError$2(`writable end state is "${this.writeStatus}" not "ready"`, ERR_SINK_INVALID_STATE);
    try {
      this.writeStatus = "writing";
      const r = {
        signal: this.sinkController.signal
      };
      if (this.direction === "outbound") {
        const n = this.sendNewStream(r);
        isPromise$2(n) && await n;
      }
      e = abortableSource(e, this.sinkController.signal, {
        returnOnAbort: !0
      }), this.log.trace("sink reading from source");
      for await (let n of e) {
        n = n instanceof Uint8Array ? new Uint8ArrayList(n) : n;
        const i = this.sendData(n, r);
        isPromise$2(i) && await i;
      }
      this.log.trace("sink finished reading from source"), this.writeStatus = "done", this.log.trace("sink calling closeWrite"), await this.closeWrite(r), this.onSinkEnd();
    } catch (r) {
      throw this.log.trace("sink ended with error, calling abort with error", r), this.abort(r), r;
    } finally {
      this.log.trace("resolve sink end"), this.sinkEnd.resolve();
    }
  }
  onSourceEnd(e) {
    var r;
    this.timeline.closeRead == null && (this.timeline.closeRead = Date.now(), e != null && this.endErr == null && (this.endErr = e), (r = this.onCloseRead) == null || r.call(this), this.timeline.closeWrite != null ? (this.log.trace("source and sink ended"), this.timeline.close = Date.now(), this.onEnd != null && this.onEnd(this.endErr)) : this.log.trace("source ended, waiting for sink to end"));
  }
  onSinkEnd(e) {
    var r;
    this.timeline.closeWrite == null && (this.timeline.closeWrite = Date.now(), e != null && this.endErr == null && (this.endErr = e), (r = this.onCloseWrite) == null || r.call(this), this.timeline.closeRead != null ? (this.log.trace("sink and source ended"), this.timeline.close = Date.now(), this.onEnd != null && this.onEnd(this.endErr)) : this.log.trace("sink ended, waiting for source to end"));
  }
  // Close for both Reading and Writing
  async close(e) {
    this.log.trace("closing gracefully"), this.status = "closing", await Promise.all([
      this.closeRead(e),
      this.closeWrite(e)
    ]), this.status = "closed", this.log.trace("closed gracefully");
  }
  async closeRead(e = {}) {
    if (this.readStatus === "closing" || this.readStatus === "closed")
      return;
    this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
    const r = this.readStatus;
    this.readStatus = "closing", r === "ready" && (this.log.trace("ending internal source queue"), this.streamSource.end()), this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null && (this.log.trace("send close read to remote"), await this.sendCloseRead(e)), this.log.trace("closed readable end of stream");
  }
  async closeWrite(e = {}) {
    if (this.writeStatus === "closing" || this.writeStatus === "closed")
      return;
    this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
    const r = this.writeStatus;
    this.writeStatus === "ready" && (this.log.trace("sink was never sunk, sink an empty array"), await this.sink([])), this.writeStatus = "closing", r === "writing" && await new Promise((n, i) => {
      queueMicrotask(() => {
        this.log.trace("aborting source passed to .sink"), this.sinkController.abort(), this.sinkEnd.promise.then(n, i);
      });
    }), this.status !== "reset" && this.status !== "aborted" && this.timeline.closeWrite == null && (this.log.trace("send close write to remote"), await this.sendCloseWrite(e)), this.writeStatus = "closed", this.log.trace("closed writable end of stream");
  }
  /**
   * Close immediately for reading and writing and send a reset message (local
   * error)
   */
  abort(e) {
    var n;
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset")
      return;
    this.log("abort with error", e), this.log("try to send reset to remote");
    const r = this.sendReset();
    isPromise$2(r) && r.catch((i) => {
      this.log.error("error sending reset message", i);
    }), this.status = "aborted", this.timeline.abort = Date.now(), this._closeSinkAndSource(e), (n = this.onAbort) == null || n.call(this, e);
  }
  /**
   * Receive a reset message - close immediately for reading and writing (remote
   * error)
   */
  reset() {
    var r;
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset")
      return;
    const e = new CodeError$2("stream reset", ERR_STREAM_RESET);
    this.status = "reset", this._closeSinkAndSource(e), (r = this.onReset) == null || r.call(this);
  }
  _closeSinkAndSource(e) {
    this._closeSink(e), this._closeSource(e);
  }
  _closeSink(e) {
    this.writeStatus === "writing" && (this.log.trace("end sink source"), this.sinkController.abort()), this.onSinkEnd(e);
  }
  _closeSource(e) {
    this.readStatus !== "closing" && this.readStatus !== "closed" && (this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength), this.readStatus = "closing", this.streamSource.end(e));
  }
  /**
   * The remote closed for writing so we should expect to receive no more
   * messages
   */
  remoteCloseWrite() {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      this.log("received remote close write but local source is already closed");
      return;
    }
    this.log.trace("remote close write"), this._closeSource();
  }
  /**
   * The remote closed for reading so we should not send any more
   * messages
   */
  remoteCloseRead() {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      this.log("received remote close read but local sink is already closed");
      return;
    }
    this.log.trace("remote close read"), this._closeSink();
  }
  /**
   * The underlying muxer has closed, no more messages can be sent or will
   * be received, close immediately to free up resources
   */
  destroy() {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      this.log("received destroy but we are already closed");
      return;
    }
    this.log.trace("muxer destroyed"), this._closeSinkAndSource();
  }
  /**
   * When an extending class reads data from it's implementation-specific source,
   * call this method to allow the stream consumer to read the data.
   */
  sourcePush(e) {
    this.streamSource.push(e);
  }
  /**
   * Returns the amount of unread data - can be used to prevent large amounts of
   * data building up when the stream consumer is too slow.
   */
  sourceReadableLength() {
    return this.streamSource.readableLength;
  }
}
function isAsyncIterable$2(t) {
  return t[Symbol.asyncIterator] != null;
}
function forEach(t, e) {
  if (isAsyncIterable$2(t))
    return async function* () {
      for await (const c of t)
        await e(c), yield c;
    }();
  const r = peekable(t), { value: n, done: i } = r.next();
  if (i === !0)
    return function* () {
    }();
  const o = e(n);
  if (typeof (o == null ? void 0 : o.then) == "function")
    return async function* () {
      yield n;
      for await (const c of r)
        await e(c), yield c;
    }();
  const a = e;
  return function* () {
    yield n;
    for (const c of r)
      a(c), yield c;
  }();
}
var StreamState;
(function(t) {
  t[t.Init = 0] = "Init", t[t.SYNSent = 1] = "SYNSent", t[t.SYNReceived = 2] = "SYNReceived", t[t.Established = 3] = "Established", t[t.Finished = 4] = "Finished";
})(StreamState || (StreamState = {}));
class YamuxStream extends AbstractStream {
  constructor(r) {
    super({
      ...r,
      onEnd: (n) => {
        var i;
        this.state = StreamState.Finished, (i = r.onEnd) == null || i.call(r, n);
      }
    });
    $(this, "name");
    $(this, "state");
    $(this, "config");
    $(this, "_id");
    /** The number of available bytes to send */
    $(this, "sendWindowCapacity");
    /** Callback to notify that the sendWindowCapacity has been updated */
    $(this, "sendWindowCapacityUpdate");
    /** The number of bytes available to receive in a full window */
    $(this, "recvWindow");
    /** The number of available bytes to receive */
    $(this, "recvWindowCapacity");
    /**
     * An 'epoch' is the time it takes to process and read data
     *
     * Used in conjunction with RTT to determine whether to increase the recvWindow
     */
    $(this, "epochStart");
    $(this, "getRTT");
    $(this, "sendFrame");
    this.config = r.config, this._id = parseInt(r.id, 10), this.name = r.name, this.state = r.state, this.sendWindowCapacity = INITIAL_STREAM_WINDOW, this.recvWindow = this.config.initialStreamWindowSize, this.recvWindowCapacity = this.recvWindow, this.epochStart = Date.now(), this.getRTT = r.getRTT, this.sendFrame = r.sendFrame, this.source = forEach(this.source, () => {
      this.sendWindowUpdate();
    });
  }
  /**
   * Send a message to the remote muxer informing them a new stream is being
   * opened.
   *
   * This is a noop for Yamux because the first window update is sent when
   * .newStream is called on the muxer which opens the stream on the remote.
   */
  async sendNewStream() {
  }
  /**
   * Send a data message to the remote muxer
   */
  async sendData(r, n = {}) {
    for (r = r.sublist(); r.byteLength !== 0; ) {
      if (this.sendWindowCapacity === 0 && await this.waitForSendWindowCapacity(n), this.status !== "open")
        return;
      const i = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, r.length), o = this.getSendFlags();
      this.sendFrame({
        type: FrameType.Data,
        flag: o,
        streamID: this._id,
        length: i
      }, r.subarray(0, i)), this.sendWindowCapacity -= i, r.consume(i);
    }
  }
  /**
   * Send a reset message to the remote muxer
   */
  async sendReset() {
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: Flag.RST,
      streamID: this._id,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be sent by this end of the stream
   */
  async sendCloseWrite() {
    const r = this.getSendFlags() | Flag.FIN;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: r,
      streamID: this._id,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be read by this end of the stream
   */
  async sendCloseRead() {
  }
  /**
   * Wait for the send window to be non-zero
   *
   * Will throw with ERR_STREAM_ABORT if the stream gets aborted
   */
  async waitForSendWindowCapacity(r = {}) {
    var a, c;
    if (this.sendWindowCapacity > 0)
      return;
    let n, i;
    const o = () => {
      this.status === "open" ? i(new CodeError$2("stream aborted", ERR_STREAM_ABORT)) : n();
    };
    (a = r.signal) == null || a.addEventListener("abort", o);
    try {
      await new Promise((l, u) => {
        this.sendWindowCapacityUpdate = () => {
          l();
        }, i = u, n = l;
      });
    } finally {
      (c = r.signal) == null || c.removeEventListener("abort", o);
    }
  }
  /**
   * handleWindowUpdate is called when the stream receives a window update frame
   */
  handleWindowUpdate(r) {
    var i, o;
    (i = this.log) == null || i.trace("stream received window update id=%s", this._id), this.processFlags(r.flag);
    const n = this.sendWindowCapacity;
    this.sendWindowCapacity += r.length, n === 0 && r.length > 0 && ((o = this.sendWindowCapacityUpdate) == null || o.call(this));
  }
  /**
   * handleData is called when the stream receives a data frame
   */
  async handleData(r, n) {
    var o;
    if ((o = this.log) == null || o.trace("stream received data id=%s", this._id), this.processFlags(r.flag), this.recvWindowCapacity < r.length)
      throw new CodeError$2("receive window exceeded", ERR_RECV_WINDOW_EXCEEDED, { available: this.recvWindowCapacity, recv: r.length });
    const i = await n();
    this.recvWindowCapacity -= r.length, this.sourcePush(i);
  }
  /**
   * processFlags is used to update the state of the stream based on set flags, if any.
   */
  processFlags(r) {
    (r & Flag.ACK) === Flag.ACK && this.state === StreamState.SYNSent && (this.state = StreamState.Established), (r & Flag.FIN) === Flag.FIN && this.remoteCloseWrite(), (r & Flag.RST) === Flag.RST && this.reset();
  }
  /**
   * getSendFlags determines any flags that are appropriate
   * based on the current stream state.
   *
   * The state is updated as a side-effect.
   */
  getSendFlags() {
    switch (this.state) {
      case StreamState.Init:
        return this.state = StreamState.SYNSent, Flag.SYN;
      case StreamState.SYNReceived:
        return this.state = StreamState.Established, Flag.ACK;
      default:
        return 0;
    }
  }
  /**
   * potentially sends a window update enabling further writes to take place.
   */
  sendWindowUpdate() {
    const r = this.getSendFlags(), n = Date.now(), i = this.getRTT();
    if (r === 0 && i > 0 && n - this.epochStart < i * 4 && (this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize)), this.recvWindowCapacity >= this.recvWindow && r === 0)
      return;
    const o = this.recvWindow - this.recvWindowCapacity;
    this.recvWindowCapacity = this.recvWindow, this.epochStart = n, this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: r,
      streamID: this._id,
      length: o
    });
  }
}
const YAMUX_PROTOCOL_ID = "/yamux/1.0.0", CLOSE_TIMEOUT$1 = 500;
class Yamux {
  constructor(e = {}) {
    $(this, "protocol", YAMUX_PROTOCOL_ID);
    $(this, "_init");
    this._init = e;
  }
  createStreamMuxer(e) {
    return new YamuxMuxer({
      ...this._init,
      ...e
    });
  }
}
class YamuxMuxer {
  constructor(e) {
    $(this, "protocol", YAMUX_PROTOCOL_ID);
    $(this, "source");
    $(this, "sink");
    $(this, "config");
    $(this, "log");
    /** Used to close the muxer from either the sink or source */
    $(this, "closeController");
    /** The next stream id to be used when initiating a new stream */
    $(this, "nextStreamID");
    /** Primary stream mapping, streamID => stream */
    $(this, "_streams");
    /** The next ping id to be used when pinging */
    $(this, "nextPingID");
    /** Tracking info for the currently active ping */
    $(this, "activePing");
    /** Round trip time */
    $(this, "rtt");
    /** True if client, false if server */
    $(this, "client");
    $(this, "localGoAway");
    $(this, "remoteGoAway");
    /** Number of tracked inbound streams */
    $(this, "numInboundStreams");
    /** Number of tracked outbound streams */
    $(this, "numOutboundStreams");
    $(this, "onIncomingStream");
    $(this, "onStreamEnd");
    var r;
    this.client = e.direction === "outbound", this.config = { ...defaultConfig, ...e }, this.log = this.config.log, verifyConfig(this.config), this.closeController = new AbortController(), this.onIncomingStream = e.onIncomingStream, this.onStreamEnd = e.onStreamEnd, this._streams = /* @__PURE__ */ new Map(), this.source = pushable({
      onEnd: () => {
        var n;
        (n = this.log) == null || n.trace("muxer source ended"), this._streams.forEach((i) => {
          i.destroy();
        });
      }
    }), this.sink = async (n) => {
      var a, c, l;
      n = abortableSource(n, this.closeController.signal, { returnOnAbort: !0 });
      let i, o;
      try {
        const u = new Decoder(n);
        await pipe$2(u.emitFrames.bind(u), async (f) => {
          for await (const { header: d, readData: p } of f)
            await this.handleFrame(d, p);
        }), i = GoAwayCode.NormalTermination;
      } catch (u) {
        const f = u.code;
        PROTOCOL_ERRORS.has(f) ? ((a = this.log) == null || a.error("protocol error in sink", u), i = GoAwayCode.ProtocolError) : ((c = this.log) == null || c.error("internal error in sink", u), i = GoAwayCode.InternalError), o = u;
      }
      (l = this.log) == null || l.trace("muxer sink ended"), o != null ? this.abort(o, i) : await this.close({ reason: i });
    }, this.numInboundStreams = 0, this.numOutboundStreams = 0, this.nextStreamID = this.client ? 1 : 2, this.nextPingID = 0, this.rtt = 0, (r = this.log) == null || r.trace("muxer created"), this.config.enableKeepAlive && this.keepAliveLoop().catch((n) => {
      var i;
      return (i = this.log) == null ? void 0 : i.error("keepalive error: %s", n);
    });
  }
  get streams() {
    return Array.from(this._streams.values());
  }
  newStream(e) {
    var i;
    if (this.remoteGoAway !== void 0)
      throw new CodeError$2("muxer closed remotely", ERR_MUXER_REMOTE_CLOSED);
    if (this.localGoAway !== void 0)
      throw new CodeError$2("muxer closed locally", ERR_MUXER_LOCAL_CLOSED);
    const r = this.nextStreamID;
    if (this.nextStreamID += 2, this.numOutboundStreams >= this.config.maxOutboundStreams)
      throw new CodeError$2("max outbound streams exceeded", ERR_MAX_OUTBOUND_STREAMS_EXCEEDED);
    (i = this.log) == null || i.trace("new outgoing stream id=%s", r);
    const n = this._newStream(r, e, StreamState.Init, "outbound");
    return this._streams.set(r, n), this.numOutboundStreams++, n.sendWindowUpdate(), n;
  }
  /**
   * Initiate a ping and wait for a response
   *
   * Note: only a single ping will be initiated at a time.
   * If a ping is already in progress, a new ping will not be initiated.
   *
   * @returns the round-trip-time in milliseconds
   */
  async ping() {
    if (this.remoteGoAway !== void 0)
      throw new CodeError$2("muxer closed remotely", ERR_MUXER_REMOTE_CLOSED);
    if (this.localGoAway !== void 0)
      throw new CodeError$2("muxer closed locally", ERR_MUXER_LOCAL_CLOSED);
    if (this.activePing === void 0) {
      let e = () => {
      };
      this.activePing = {
        id: this.nextPingID++,
        // this promise awaits resolution or the close controller aborting
        promise: new Promise((i, o) => {
          const a = () => {
            o(new CodeError$2("muxer closed locally", ERR_MUXER_LOCAL_CLOSED));
          };
          this.closeController.signal.addEventListener("abort", a, { once: !0 }), e = () => {
            this.closeController.signal.removeEventListener("abort", a), i();
          };
        }),
        resolve: e
      };
      const r = Date.now();
      this.sendPing(this.activePing.id);
      try {
        await this.activePing.promise;
      } finally {
        delete this.activePing;
      }
      const n = Date.now();
      this.rtt = n - r;
    } else
      await this.activePing.promise;
    return this.rtt;
  }
  /**
   * Get the ping round trip time
   *
   * Note: Will return 0 if no successful ping has yet been completed
   *
   * @returns the round-trip-time in milliseconds
   */
  getRTT() {
    return this.rtt;
  }
  /**
   * Close the muxer
   */
  async close(e = {}) {
    var n;
    if (this.closeController.signal.aborted)
      return;
    const r = (e == null ? void 0 : e.reason) ?? GoAwayCode.NormalTermination;
    (n = this.log) == null || n.trace("muxer close reason=%s", r), e.signal = e.signal ?? AbortSignal.timeout(CLOSE_TIMEOUT$1);
    try {
      await Promise.all([...this._streams.values()].map(async (i) => i.close(e))), this.sendGoAway(r), this._closeMuxer();
    } catch (i) {
      this.abort(i);
    }
  }
  abort(e, r) {
    var n;
    if (!this.closeController.signal.aborted) {
      r = r ?? GoAwayCode.InternalError, (n = this.log) == null || n.error("muxer abort reason=%s error=%s", r, e);
      for (const i of this._streams.values())
        i.abort(e);
      this.sendGoAway(r), this._closeMuxer();
    }
  }
  isClosed() {
    return this.closeController.signal.aborted;
  }
  /**
   * Called when either the local or remote shuts down the muxer
   */
  _closeMuxer() {
    this.closeController.abort(), this.source.end();
  }
  /** Create a new stream */
  _newStream(e, r, n, i) {
    if (this._streams.get(e) != null)
      throw new CodeError$2("Stream already exists", ERR_STREAM_ALREADY_EXISTS, { id: e });
    const o = new YamuxStream({
      id: e.toString(),
      name: r,
      state: n,
      direction: i,
      sendFrame: this.sendFrame.bind(this),
      onEnd: () => {
        var a;
        this.closeStream(e), (a = this.onStreamEnd) == null || a.call(this, o);
      },
      log: logger$1(`libp2p:yamux:${i}:${e}`),
      config: this.config,
      getRTT: this.getRTT.bind(this)
    });
    return o;
  }
  /**
   * closeStream is used to close a stream once both sides have
   * issued a close.
   */
  closeStream(e) {
    this.client === (e % 2 === 0) ? this.numInboundStreams-- : this.numOutboundStreams--, this._streams.delete(e);
  }
  async keepAliveLoop() {
    var r;
    const e = new Promise((n, i) => {
      this.closeController.signal.addEventListener("abort", i, { once: !0 });
    });
    for ((r = this.log) == null || r.trace("muxer keepalive enabled interval=%s", this.config.keepAliveInterval); ; ) {
      let n;
      try {
        await Promise.race([
          e,
          new Promise((i) => {
            n = setTimeout(i, this.config.keepAliveInterval);
          })
        ]), this.ping().catch((i) => {
          var o;
          return (o = this.log) == null ? void 0 : o.error("ping error: %s", i);
        });
      } catch {
        clearInterval(n);
        return;
      }
    }
  }
  async handleFrame(e, r) {
    var a;
    const { streamID: n, type: i, length: o } = e;
    if ((a = this.log) == null || a.trace("received frame %s", stringifyHeader(e)), n === 0)
      switch (i) {
        case FrameType.Ping: {
          this.handlePing(e);
          return;
        }
        case FrameType.GoAway: {
          this.handleGoAway(o);
          return;
        }
        default:
          throw new CodeError$2("Invalid frame type", ERR_INVALID_FRAME, { header: e });
      }
    else
      switch (e.type) {
        case FrameType.Data:
        case FrameType.WindowUpdate: {
          await this.handleStreamMessage(e, r);
          return;
        }
        default:
          throw new CodeError$2("Invalid frame type", ERR_INVALID_FRAME, { header: e });
      }
  }
  handlePing(e) {
    var r, n;
    if (e.flag === Flag.SYN)
      (r = this.log) == null || r.trace("received ping request pingId=%s", e.length), this.sendPing(e.length, Flag.ACK);
    else if (e.flag === Flag.ACK)
      (n = this.log) == null || n.trace("received ping response pingId=%s", e.length), this.handlePingResponse(e.length);
    else
      throw new CodeError$2("Invalid frame flag", ERR_INVALID_FRAME, { header: e });
  }
  handlePingResponse(e) {
    if (this.activePing === void 0)
      throw new CodeError$2("ping not requested", ERR_UNREQUESTED_PING);
    if (this.activePing.id !== e)
      throw new CodeError$2("ping doesn't match our id", ERR_NOT_MATCHING_PING);
    this.activePing.resolve();
  }
  handleGoAway(e) {
    var r;
    (r = this.log) == null || r.trace("received GoAway reason=%s", GoAwayCode[e] ?? "unknown"), this.remoteGoAway = e;
    for (const n of this._streams.values())
      n.reset();
    this._closeMuxer();
  }
  async handleStreamMessage(e, r) {
    var c, l;
    const { streamID: n, flag: i, type: o } = e;
    (i & Flag.SYN) === Flag.SYN && this.incomingStream(n);
    const a = this._streams.get(n);
    if (a === void 0) {
      if (o === FrameType.Data) {
        if ((c = this.log) == null || c.call(this, "discarding data for stream id=%s", n), r === void 0)
          throw new Error("unreachable");
        await r();
      } else
        (l = this.log) == null || l.call(this, "frame for missing stream id=%s", n);
      return;
    }
    switch (o) {
      case FrameType.WindowUpdate: {
        a.handleWindowUpdate(e);
        return;
      }
      case FrameType.Data: {
        if (r === void 0)
          throw new Error("unreachable");
        await a.handleData(e, r);
        return;
      }
      default:
        throw new Error("unreachable");
    }
  }
  incomingStream(e) {
    var n, i, o;
    if (this.client !== (e % 2 === 0))
      throw new CodeError$2("both endpoints are clients", ERR_BOTH_CLIENTS);
    if (this._streams.has(e))
      return;
    if ((n = this.log) == null || n.trace("new incoming stream id=%s", e), this.localGoAway !== void 0) {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: e,
        length: 0
      });
      return;
    }
    if (this.numInboundStreams >= this.config.maxInboundStreams) {
      (i = this.log) == null || i.call(this, "maxIncomingStreams exceeded, forcing stream reset"), this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: e,
        length: 0
      });
      return;
    }
    const r = this._newStream(e, void 0, StreamState.SYNReceived, "inbound");
    this.numInboundStreams++, this._streams.set(e, r), (o = this.onIncomingStream) == null || o.call(this, r);
  }
  sendFrame(e, r) {
    var n;
    if ((n = this.log) == null || n.trace("sending frame %s", stringifyHeader(e)), e.type === FrameType.Data) {
      if (r === void 0)
        throw new CodeError$2("invalid frame", ERR_INVALID_FRAME);
      this.source.push(encodeHeader(e)), this.source.push(r);
    } else
      this.source.push(encodeHeader(e));
  }
  sendPing(e, r = Flag.SYN) {
    var n, i;
    r === Flag.SYN ? (n = this.log) == null || n.trace("sending ping request pingId=%s", e) : (i = this.log) == null || i.trace("sending ping response pingId=%s", e), this.sendFrame({
      type: FrameType.Ping,
      flag: r,
      streamID: 0,
      length: e
    });
  }
  sendGoAway(e = GoAwayCode.NormalTermination) {
    var r;
    (r = this.log) == null || r.call(this, "sending GoAway reason=%s", GoAwayCode[e]), this.localGoAway = e, this.sendFrame({
      type: FrameType.GoAway,
      flag: 0,
      streamID: 0,
      length: e
    });
  }
}
function yamux(t = {}) {
  return () => new Yamux(t);
}
function extractSNI(t) {
  let e;
  try {
    e = getProtocol$1("sni").code;
  } catch {
    return null;
  }
  for (const [r, n] of t)
    if (r === e && n !== void 0)
      return n;
  return null;
}
function hasTLS(t) {
  return t.some(([e, r]) => e === getProtocol$1("tls").code);
}
function interpretNext(t, e, r) {
  const n = interpreters[getProtocol$1(t).name];
  if (n === void 0)
    throw new Error(`Can't interpret protocol ${getProtocol$1(t).name}`);
  const i = n(e, r);
  return t === getProtocol$1("ip6").code ? `[${i}]` : i;
}
const interpreters = {
  ip4: (t, e) => t,
  ip6: (t, e) => e.length === 0 ? t : `[${t}]`,
  tcp: (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    return `tcp://${interpretNext(r[0], r[1] ?? "", e)}:${t}`;
  },
  udp: (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    return `udp://${interpretNext(r[0], r[1] ?? "", e)}:${t}`;
  },
  dnsaddr: (t, e) => t,
  dns4: (t, e) => t,
  dns6: (t, e) => t,
  dns: (t, e) => t,
  ipfs: (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    return `${interpretNext(r[0], r[1] ?? "", e)}/ipfs/${t}`;
  },
  p2p: (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    return `${interpretNext(r[0], r[1] ?? "", e)}/p2p/${t}`;
  },
  http: (t, e) => {
    const r = hasTLS(e), n = extractSNI(e);
    if (r && n !== null)
      return `https://${n}`;
    const i = r ? "https://" : "http://", o = e.pop();
    if (o === void 0)
      throw new Error("Unexpected end of multiaddr");
    let a = interpretNext(o[0], o[1] ?? "", e);
    return a = a.replace("tcp://", ""), `${i}${a}`;
  },
  tls: (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    return interpretNext(r[0], r[1] ?? "", e);
  },
  sni: (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    return interpretNext(r[0], r[1] ?? "", e);
  },
  https: (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    let n = interpretNext(r[0], r[1] ?? "", e);
    return n = n.replace("tcp://", ""), `https://${n}`;
  },
  ws: (t, e) => {
    const r = hasTLS(e), n = extractSNI(e);
    if (r && n !== null)
      return `wss://${n}`;
    const i = r ? "wss://" : "ws://", o = e.pop();
    if (o === void 0)
      throw new Error("Unexpected end of multiaddr");
    let a = interpretNext(o[0], o[1] ?? "", e);
    return a = a.replace("tcp://", ""), `${i}${a}`;
  },
  wss: (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    let n = interpretNext(r[0], r[1] ?? "", e);
    return n = n.replace("tcp://", ""), `wss://${n}`;
  },
  "p2p-websocket-star": (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    return `${interpretNext(r[0], r[1] ?? "", e)}/p2p-websocket-star`;
  },
  "p2p-webrtc-star": (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    return `${interpretNext(r[0], r[1] ?? "", e)}/p2p-webrtc-star`;
  },
  "p2p-webrtc-direct": (t, e) => {
    const r = e.pop();
    if (r === void 0)
      throw new Error("Unexpected end of multiaddr");
    return `${interpretNext(r[0], r[1] ?? "", e)}/p2p-webrtc-direct`;
  }
};
function multiaddrToUri(t, e) {
  const n = multiaddr$1(t).stringTuples(), i = n.pop();
  if (i === void 0)
    throw new Error("Unexpected end of multiaddr");
  const o = getProtocol$1(i[0]), a = interpreters[o.name];
  if (a == null)
    throw new Error(`No interpreter found for ${o.name}`);
  let c = a(i[1] ?? "", n);
  return (e == null ? void 0 : e.assumeHttp) !== !1 && i[0] === getProtocol$1("tcp").code && (c = c.replace("tcp://", "http://"), (i[1] === "443" || i[1] === "80") && (i[1] === "443" && (c = c.replace("http://", "https://")), c = c.substring(0, c.lastIndexOf(":")))), c;
}
const ready = async (t) => {
  if (t.readyState >= 2)
    throw new Error("socket closed");
  t.readyState !== 1 && await new Promise((e, r) => {
    function n() {
      t.removeEventListener("open", i), t.removeEventListener("error", o);
    }
    function i() {
      n(), e();
    }
    function o(a) {
      n(), r(a.error ?? new Error(`connect ECONNREFUSED ${t.url}`));
    }
    t.addEventListener("open", i), t.addEventListener("error", o);
  });
}, sink = (t, e) => (e = e ?? {}, e.closeOnEnd = e.closeOnEnd !== !1, async (n) => {
  for await (const i of n) {
    try {
      await ready(t);
    } catch (o) {
      if (o.message === "socket closed")
        break;
      throw o;
    }
    if (t.readyState === t.CLOSING || t.readyState === t.CLOSED)
      break;
    t.send(i);
  }
  e.closeOnEnd != null && t.readyState <= 1 && await new Promise((i, o) => {
    t.addEventListener("close", (a) => {
      if (a.wasClean || a.code === 1006)
        i();
      else {
        const c = Object.assign(new Error("ws error"), { event: a });
        o(c);
      }
    }), setTimeout(() => {
      t.close();
    });
  });
});
var node = {}, eventIterator = {};
Object.defineProperty(eventIterator, "__esModule", { value: !0 });
class EventQueue {
  constructor() {
    this.pullQueue = [], this.pushQueue = [], this.eventHandlers = {}, this.isPaused = !1, this.isStopped = !1;
  }
  push(e) {
    if (this.isStopped)
      return;
    const r = { value: e, done: !1 };
    if (this.pullQueue.length) {
      const n = this.pullQueue.shift();
      n && n.resolve(r);
    } else
      this.pushQueue.push(Promise.resolve(r)), this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused && (this.isPaused = !0, this.eventHandlers.highWater ? this.eventHandlers.highWater() : console && console.warn(`EventIterator queue reached ${this.pushQueue.length} items`));
  }
  stop() {
    if (!this.isStopped) {
      this.isStopped = !0, this.remove();
      for (const e of this.pullQueue)
        e.resolve({ value: void 0, done: !0 });
      this.pullQueue.length = 0;
    }
  }
  fail(e) {
    if (!this.isStopped)
      if (this.isStopped = !0, this.remove(), this.pullQueue.length) {
        for (const r of this.pullQueue)
          r.reject(e);
        this.pullQueue.length = 0;
      } else {
        const r = Promise.reject(e);
        r.catch(() => {
        }), this.pushQueue.push(r);
      }
  }
  remove() {
    Promise.resolve().then(() => {
      this.removeCallback && this.removeCallback();
    });
  }
  [Symbol.asyncIterator]() {
    return {
      next: (e) => {
        const r = this.pushQueue.shift();
        return r ? (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused && (this.isPaused = !1, this.eventHandlers.lowWater && this.eventHandlers.lowWater()), r) : this.isStopped ? Promise.resolve({ value: void 0, done: !0 }) : new Promise((n, i) => {
          this.pullQueue.push({ resolve: n, reject: i });
        });
      },
      return: () => (this.isStopped = !0, this.pushQueue.length = 0, this.remove(), Promise.resolve({ value: void 0, done: !0 }))
    };
  }
}
let EventIterator$1 = class {
  constructor(e, { highWaterMark: r = 100, lowWaterMark: n = 1 } = {}) {
    const i = new EventQueue();
    i.highWaterMark = r, i.lowWaterMark = n, i.removeCallback = e({
      push: (o) => i.push(o),
      stop: () => i.stop(),
      fail: (o) => i.fail(o),
      on: (o, a) => {
        i.eventHandlers[o] = a;
      }
    }) || (() => {
    }), this[Symbol.asyncIterator] = () => i[Symbol.asyncIterator](), Object.freeze(this);
  }
};
eventIterator.EventIterator = EventIterator$1;
eventIterator.default = EventIterator$1;
Object.defineProperty(node, "__esModule", { value: !0 });
const event_iterator_1 = eventIterator;
var EventIterator = node.EventIterator = event_iterator_1.EventIterator;
function stream(t) {
  return new event_iterator_1.EventIterator((e) => (this.addListener("data", e.push), this.addListener("end", e.stop), this.addListener("error", e.fail), e.on("highWater", () => this.pause()), e.on("lowWater", () => this.resume()), () => {
    this.removeListener("data", e.push), this.removeListener("end", e.stop), this.removeListener("error", e.fail), this.destroy ? this.destroy() : typeof this.close == "function" && this.close();
  }), t);
}
node.stream = stream;
node.default = event_iterator_1.EventIterator;
function isArrayBuffer(t) {
  var e;
  return t instanceof ArrayBuffer || ((e = t == null ? void 0 : t.constructor) == null ? void 0 : e.name) === "ArrayBuffer" && typeof (t == null ? void 0 : t.byteLength) == "number";
}
const source = (t) => {
  t.binaryType = "arraybuffer";
  const e = async () => {
    await new Promise((o, a) => {
      if (n) {
        o();
        return;
      }
      if (i != null) {
        a(i);
        return;
      }
      const c = (f) => {
        t.removeEventListener("open", l), t.removeEventListener("error", u), f();
      }, l = () => {
        c(o);
      }, u = (f) => {
        c(() => {
          a(f.error ?? new Error(`connect ECONNREFUSED ${t.url}`));
        });
      };
      t.addEventListener("open", l), t.addEventListener("error", u);
    });
  }, r = async function* () {
    const o = new EventIterator(({ push: a, stop: c, fail: l }) => {
      const u = (d) => {
        let p = null;
        typeof d.data == "string" && (p = fromString$1(d.data)), isArrayBuffer(d.data) && (p = new Uint8Array(d.data)), d.data instanceof Uint8Array && (p = d.data), p != null && a(p);
      }, f = (d) => {
        l(d.error ?? new Error("Socket error"));
      };
      return t.addEventListener("message", u), t.addEventListener("error", f), t.addEventListener("close", c), () => {
        t.removeEventListener("message", u), t.removeEventListener("error", f), t.removeEventListener("close", c);
      };
    }, { highWaterMark: 1 / 0 });
    await e();
    for await (const a of o)
      yield isArrayBuffer(a) ? new Uint8Array(a) : a;
  }();
  let n = t.readyState === 1, i;
  return t.addEventListener("open", () => {
    n = !0, i = null;
  }), t.addEventListener("close", () => {
    n = !1, i = null;
  }), t.addEventListener("error", (o) => {
    n || (i = o.error ?? new Error(`connect ECONNREFUSED ${t.url}`));
  }), Object.assign(r, {
    connected: e
  });
}, duplex = (t, e) => {
  e = e ?? {};
  const r = source(t);
  let n = e.remoteAddress, i = e.remotePort;
  if (t.url != null)
    try {
      const a = new URL(t.url);
      n = a.hostname, i = parseInt(a.port, 10);
    } catch {
    }
  if (n == null || i == null)
    throw new Error("Remote connection did not have address and/or port");
  return {
    sink: sink(t, e),
    source: r,
    connected: async () => {
      await r.connected();
    },
    close: async () => {
      (t.readyState === t.CONNECTING || t.readyState === t.OPEN) && await new Promise((a) => {
        t.addEventListener("close", () => {
          a();
        }), t.close();
      });
    },
    destroy: () => {
      t.terminate != null ? t.terminate() : t.close();
    },
    remoteAddress: n,
    remotePort: i,
    socket: t
  };
};
var bufferUtilExports = {}, bufferUtil$1 = {
  get exports() {
    return bufferUtilExports;
  },
  set exports(t) {
    bufferUtilExports = t;
  }
}, constants = {
  BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
  kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
  kListener: Symbol("kListener"),
  kStatusCode: Symbol("status-code"),
  kWebSocket: Symbol("websocket"),
  NOOP: () => {
  }
}, bufferutilExports = {}, bufferutil = {
  get exports() {
    return bufferutilExports;
  },
  set exports(t) {
    bufferutilExports = t;
  }
}, nodeGypBuildExports = {}, nodeGypBuild$1 = {
  get exports() {
    return nodeGypBuildExports;
  },
  set exports(t) {
    nodeGypBuildExports = t;
  }
};
function commonjsRequire(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var nodeGypBuild, hasRequiredNodeGypBuild$1;
function requireNodeGypBuild$1() {
  if (hasRequiredNodeGypBuild$1)
    return nodeGypBuild;
  hasRequiredNodeGypBuild$1 = 1;
  var t = fs__default, e = path__default, r = require$$0, n = typeof __webpack_require__ == "function" ? __non_webpack_require__ : commonjsRequire, i = process.config && process.config.variables || {}, o = !!process.env.PREBUILDS_ONLY, a = process.versions.modules, c = C() ? "electron" : I() ? "node-webkit" : "node", l = process.env.npm_config_arch || r.arch(), u = process.env.npm_config_platform || r.platform(), f = process.env.LIBC || (M(u) ? "musl" : "glibc"), d = process.env.ARM_VERSION || (l === "arm64" ? "8" : i.arm_version) || "", p = (process.versions.uv || "").split(".")[0];
  nodeGypBuild = g;
  function g(O) {
    return n(g.resolve(O));
  }
  g.resolve = g.path = function(O) {
    O = e.resolve(O || ".");
    try {
      var B = n(e.join(O, "package.json")).name.toUpperCase().replace(/-/g, "_");
      process.env[B + "_PREBUILD"] && (O = process.env[B + "_PREBUILD"]);
    } catch {
    }
    if (!o) {
      var k = m(e.join(O, "build/Release"), y);
      if (k)
        return k;
      var U = m(e.join(O, "build/Debug"), y);
      if (U)
        return U;
    }
    var R = L(O);
    if (R)
      return R;
    var P = L(e.dirname(process.execPath));
    if (P)
      return P;
    var T = [
      "platform=" + u,
      "arch=" + l,
      "runtime=" + c,
      "abi=" + a,
      "uv=" + p,
      d ? "armv=" + d : "",
      "libc=" + f,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ == "function" ? "webpack=true" : ""
      // eslint-disable-line
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + T + `
    loaded from: ` + O + `
`);
    function L(A) {
      var N = h(e.join(A, "prebuilds")).map(b), D = N.filter(v(u, l)).sort(_)[0];
      if (D) {
        var F = e.join(A, "prebuilds", D.name), j = h(F).map(E), K = j.filter(w(c, a)), G = K.sort(x(c))[0];
        if (G)
          return e.join(F, G.file);
      }
    }
  };
  function h(O) {
    try {
      return t.readdirSync(O);
    } catch {
      return [];
    }
  }
  function m(O, B) {
    var k = h(O).filter(B);
    return k[0] && e.join(O, k[0]);
  }
  function y(O) {
    return /\.node$/.test(O);
  }
  function b(O) {
    var B = O.split("-");
    if (B.length === 2) {
      var k = B[0], U = B[1].split("+");
      if (k && U.length && U.every(Boolean))
        return { name: O, platform: k, architectures: U };
    }
  }
  function v(O, B) {
    return function(k) {
      return k == null || k.platform !== O ? !1 : k.architectures.includes(B);
    };
  }
  function _(O, B) {
    return O.architectures.length - B.architectures.length;
  }
  function E(O) {
    var B = O.split("."), k = B.pop(), U = { file: O, specificity: 0 };
    if (k === "node") {
      for (var R = 0; R < B.length; R++) {
        var P = B[R];
        if (P === "node" || P === "electron" || P === "node-webkit")
          U.runtime = P;
        else if (P === "napi")
          U.napi = !0;
        else if (P.slice(0, 3) === "abi")
          U.abi = P.slice(3);
        else if (P.slice(0, 2) === "uv")
          U.uv = P.slice(2);
        else if (P.slice(0, 4) === "armv")
          U.armv = P.slice(4);
        else if (P === "glibc" || P === "musl")
          U.libc = P;
        else
          continue;
        U.specificity++;
      }
      return U;
    }
  }
  function w(O, B) {
    return function(k) {
      return !(k == null || k.runtime !== O && !S(k) || k.abi !== B && !k.napi || k.uv && k.uv !== p || k.armv && k.armv !== d || k.libc && k.libc !== f);
    };
  }
  function S(O) {
    return O.runtime === "node" && O.napi;
  }
  function x(O) {
    return function(B, k) {
      return B.runtime !== k.runtime ? B.runtime === O ? -1 : 1 : B.abi !== k.abi ? B.abi ? -1 : 1 : B.specificity !== k.specificity ? B.specificity > k.specificity ? -1 : 1 : 0;
    };
  }
  function I() {
    return !!(process.versions && process.versions.nw);
  }
  function C() {
    return process.versions && process.versions.electron || process.env.ELECTRON_RUN_AS_NODE ? !0 : typeof window < "u" && window.process && window.process.type === "renderer";
  }
  function M(O) {
    return O === "linux" && t.existsSync("/etc/alpine-release");
  }
  return g.parseTags = E, g.matchTags = w, g.compareTags = x, g.parseTuple = b, g.matchTuple = v, g.compareTuples = _, nodeGypBuild;
}
var hasRequiredNodeGypBuild;
function requireNodeGypBuild() {
  return hasRequiredNodeGypBuild || (hasRequiredNodeGypBuild = 1, function(t) {
    typeof process.addon == "function" ? t.exports = process.addon.bind(process) : t.exports = requireNodeGypBuild$1();
  }(nodeGypBuild$1)), nodeGypBuildExports;
}
var fallback$1, hasRequiredFallback$1;
function requireFallback$1() {
  return hasRequiredFallback$1 || (hasRequiredFallback$1 = 1, fallback$1 = { mask: (r, n, i, o, a) => {
    for (var c = 0; c < a; c++)
      i[o + c] = r[c] ^ n[c & 3];
  }, unmask: (r, n) => {
    const i = r.length;
    for (var o = 0; o < i; o++)
      r[o] ^= n[o & 3];
  } }), fallback$1;
}
var hasRequiredBufferutil;
function requireBufferutil() {
  return hasRequiredBufferutil || (hasRequiredBufferutil = 1, function(t) {
    try {
      t.exports = requireNodeGypBuild()(__dirname);
    } catch {
      t.exports = requireFallback$1();
    }
  }(bufferutil)), bufferutilExports;
}
var unmask$1, mask;
const { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants, FastBuffer$2 = Buffer[Symbol.species];
function concat$5(t, e) {
  if (t.length === 0)
    return EMPTY_BUFFER$3;
  if (t.length === 1)
    return t[0];
  const r = Buffer.allocUnsafe(e);
  let n = 0;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    r.set(o, n), n += o.length;
  }
  return n < e ? new FastBuffer$2(r.buffer, r.byteOffset, n) : r;
}
function _mask(t, e, r, n, i) {
  for (let o = 0; o < i; o++)
    r[n + o] = t[o] ^ e[o & 3];
}
function _unmask(t, e) {
  for (let r = 0; r < t.length; r++)
    t[r] ^= e[r & 3];
}
function toArrayBuffer$1(t) {
  return t.length === t.buffer.byteLength ? t.buffer : t.buffer.slice(t.byteOffset, t.byteOffset + t.length);
}
function toBuffer$2(t) {
  if (toBuffer$2.readOnly = !0, Buffer.isBuffer(t))
    return t;
  let e;
  return t instanceof ArrayBuffer ? e = new FastBuffer$2(t) : ArrayBuffer.isView(t) ? e = new FastBuffer$2(t.buffer, t.byteOffset, t.byteLength) : (e = Buffer.from(t), toBuffer$2.readOnly = !1), e;
}
bufferUtil$1.exports = {
  concat: concat$5,
  mask: _mask,
  toArrayBuffer: toArrayBuffer$1,
  toBuffer: toBuffer$2,
  unmask: _unmask
};
if (!process.env.WS_NO_BUFFER_UTIL)
  try {
    const t = requireBufferutil();
    mask = bufferUtilExports.mask = function(e, r, n, i, o) {
      o < 48 ? _mask(e, r, n, i, o) : t.mask(e, r, n, i, o);
    }, unmask$1 = bufferUtilExports.unmask = function(e, r) {
      e.length < 32 ? _unmask(e, r) : t.unmask(e, r);
    };
  } catch {
  }
const kDone = Symbol("kDone"), kRun = Symbol("kRun");
let Limiter$1 = class {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(e) {
    this[kDone] = () => {
      this.pending--, this[kRun]();
    }, this.concurrency = e || 1 / 0, this.jobs = [], this.pending = 0;
  }
  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(e) {
    this.jobs.push(e), this[kRun]();
  }
  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending !== this.concurrency && this.jobs.length) {
      const e = this.jobs.shift();
      this.pending++, e(this[kDone]);
    }
  }
};
var limiter = Limiter$1;
const zlib = require$$0$1, bufferUtil = bufferUtilExports, Limiter = limiter, { kStatusCode: kStatusCode$2 } = constants, FastBuffer$1 = Buffer[Symbol.species], TRAILER = Buffer.from([0, 0, 255, 255]), kPerMessageDeflate = Symbol("permessage-deflate"), kTotalLength = Symbol("total-length"), kCallback = Symbol("callback"), kBuffers = Symbol("buffers"), kError$1 = Symbol("error");
let zlibLimiter, PerMessageDeflate$4 = class {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(e, r, n) {
    if (this._maxPayload = n | 0, this._options = e || {}, this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024, this._isServer = !!r, this._deflate = null, this._inflate = null, this.params = null, !zlibLimiter) {
      const i = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
      zlibLimiter = new Limiter(i);
    }
  }
  /**
   * @type {String}
   */
  static get extensionName() {
    return "permessage-deflate";
  }
  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const e = {};
    return this._options.serverNoContextTakeover && (e.server_no_context_takeover = !0), this._options.clientNoContextTakeover && (e.client_no_context_takeover = !0), this._options.serverMaxWindowBits && (e.server_max_window_bits = this._options.serverMaxWindowBits), this._options.clientMaxWindowBits ? e.client_max_window_bits = this._options.clientMaxWindowBits : this._options.clientMaxWindowBits == null && (e.client_max_window_bits = !0), e;
  }
  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(e) {
    return e = this.normalizeParams(e), this.params = this._isServer ? this.acceptAsServer(e) : this.acceptAsClient(e), this.params;
  }
  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate && (this._inflate.close(), this._inflate = null), this._deflate) {
      const e = this._deflate[kCallback];
      this._deflate.close(), this._deflate = null, e && e(
        new Error(
          "The deflate stream was closed while data was being processed"
        )
      );
    }
  }
  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(e) {
    const r = this._options, n = e.find((i) => !(r.serverNoContextTakeover === !1 && i.server_no_context_takeover || i.server_max_window_bits && (r.serverMaxWindowBits === !1 || typeof r.serverMaxWindowBits == "number" && r.serverMaxWindowBits > i.server_max_window_bits) || typeof r.clientMaxWindowBits == "number" && !i.client_max_window_bits));
    if (!n)
      throw new Error("None of the extension offers can be accepted");
    return r.serverNoContextTakeover && (n.server_no_context_takeover = !0), r.clientNoContextTakeover && (n.client_no_context_takeover = !0), typeof r.serverMaxWindowBits == "number" && (n.server_max_window_bits = r.serverMaxWindowBits), typeof r.clientMaxWindowBits == "number" ? n.client_max_window_bits = r.clientMaxWindowBits : (n.client_max_window_bits === !0 || r.clientMaxWindowBits === !1) && delete n.client_max_window_bits, n;
  }
  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(e) {
    const r = e[0];
    if (this._options.clientNoContextTakeover === !1 && r.client_no_context_takeover)
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    if (!r.client_max_window_bits)
      typeof this._options.clientMaxWindowBits == "number" && (r.client_max_window_bits = this._options.clientMaxWindowBits);
    else if (this._options.clientMaxWindowBits === !1 || typeof this._options.clientMaxWindowBits == "number" && r.client_max_window_bits > this._options.clientMaxWindowBits)
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    return r;
  }
  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(e) {
    return e.forEach((r) => {
      Object.keys(r).forEach((n) => {
        let i = r[n];
        if (i.length > 1)
          throw new Error(`Parameter "${n}" must have only a single value`);
        if (i = i[0], n === "client_max_window_bits") {
          if (i !== !0) {
            const o = +i;
            if (!Number.isInteger(o) || o < 8 || o > 15)
              throw new TypeError(
                `Invalid value for parameter "${n}": ${i}`
              );
            i = o;
          } else if (!this._isServer)
            throw new TypeError(
              `Invalid value for parameter "${n}": ${i}`
            );
        } else if (n === "server_max_window_bits") {
          const o = +i;
          if (!Number.isInteger(o) || o < 8 || o > 15)
            throw new TypeError(
              `Invalid value for parameter "${n}": ${i}`
            );
          i = o;
        } else if (n === "client_no_context_takeover" || n === "server_no_context_takeover") {
          if (i !== !0)
            throw new TypeError(
              `Invalid value for parameter "${n}": ${i}`
            );
        } else
          throw new Error(`Unknown parameter "${n}"`);
        r[n] = i;
      });
    }), e;
  }
  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(e, r, n) {
    zlibLimiter.add((i) => {
      this._decompress(e, r, (o, a) => {
        i(), n(o, a);
      });
    });
  }
  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(e, r, n) {
    zlibLimiter.add((i) => {
      this._compress(e, r, (o, a) => {
        i(), n(o, a);
      });
    });
  }
  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(e, r, n) {
    const i = this._isServer ? "client" : "server";
    if (!this._inflate) {
      const o = `${i}_max_window_bits`, a = typeof this.params[o] != "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[o];
      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits: a
      }), this._inflate[kPerMessageDeflate] = this, this._inflate[kTotalLength] = 0, this._inflate[kBuffers] = [], this._inflate.on("error", inflateOnError), this._inflate.on("data", inflateOnData);
    }
    this._inflate[kCallback] = n, this._inflate.write(e), r && this._inflate.write(TRAILER), this._inflate.flush(() => {
      const o = this._inflate[kError$1];
      if (o) {
        this._inflate.close(), this._inflate = null, n(o);
        return;
      }
      const a = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );
      this._inflate._readableState.endEmitted ? (this._inflate.close(), this._inflate = null) : (this._inflate[kTotalLength] = 0, this._inflate[kBuffers] = [], r && this.params[`${i}_no_context_takeover`] && this._inflate.reset()), n(null, a);
    });
  }
  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(e, r, n) {
    const i = this._isServer ? "server" : "client";
    if (!this._deflate) {
      const o = `${i}_max_window_bits`, a = typeof this.params[o] != "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[o];
      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits: a
      }), this._deflate[kTotalLength] = 0, this._deflate[kBuffers] = [], this._deflate.on("data", deflateOnData);
    }
    this._deflate[kCallback] = n, this._deflate.write(e), this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate)
        return;
      let o = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );
      r && (o = new FastBuffer$1(o.buffer, o.byteOffset, o.length - 4)), this._deflate[kCallback] = null, this._deflate[kTotalLength] = 0, this._deflate[kBuffers] = [], r && this.params[`${i}_no_context_takeover`] && this._deflate.reset(), n(null, o);
    });
  }
};
var permessageDeflate = PerMessageDeflate$4;
function deflateOnData(t) {
  this[kBuffers].push(t), this[kTotalLength] += t.length;
}
function inflateOnData(t) {
  if (this[kTotalLength] += t.length, this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(t);
    return;
  }
  this[kError$1] = new RangeError("Max payload size exceeded"), this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH", this[kError$1][kStatusCode$2] = 1009, this.removeListener("data", inflateOnData), this.reset();
}
function inflateOnError(t) {
  this[kPerMessageDeflate]._inflate = null, t[kStatusCode$2] = 1007, this[kCallback](t);
}
var validationExports = {}, validation = {
  get exports() {
    return validationExports;
  },
  set exports(t) {
    validationExports = t;
  }
}, utf8ValidateExports = {}, utf8Validate = {
  get exports() {
    return utf8ValidateExports;
  },
  set exports(t) {
    utf8ValidateExports = t;
  }
}, fallback, hasRequiredFallback;
function requireFallback() {
  if (hasRequiredFallback)
    return fallback;
  hasRequiredFallback = 1;
  function t(e) {
    const r = e.length;
    let n = 0;
    for (; n < r; )
      if (!(e[n] & 128))
        n++;
      else if ((e[n] & 224) === 192) {
        if (n + 1 === r || (e[n + 1] & 192) !== 128 || (e[n] & 254) === 192)
          return !1;
        n += 2;
      } else if ((e[n] & 240) === 224) {
        if (n + 2 >= r || (e[n + 1] & 192) !== 128 || (e[n + 2] & 192) !== 128 || e[n] === 224 && (e[n + 1] & 224) === 128 || // overlong
        e[n] === 237 && (e[n + 1] & 224) === 160)
          return !1;
        n += 3;
      } else if ((e[n] & 248) === 240) {
        if (n + 3 >= r || (e[n + 1] & 192) !== 128 || (e[n + 2] & 192) !== 128 || (e[n + 3] & 192) !== 128 || e[n] === 240 && (e[n + 1] & 240) === 128 || // overlong
        e[n] === 244 && e[n + 1] > 143 || e[n] > 244)
          return !1;
        n += 4;
      } else
        return !1;
    return !0;
  }
  return fallback = t, fallback;
}
var hasRequiredUtf8Validate;
function requireUtf8Validate() {
  return hasRequiredUtf8Validate || (hasRequiredUtf8Validate = 1, function(t) {
    try {
      t.exports = requireNodeGypBuild()(__dirname);
    } catch {
      t.exports = requireFallback();
    }
  }(utf8Validate)), utf8ValidateExports;
}
var isValidUTF8_1;
const { isUtf8 } = require$$0$2, tokenChars$2 = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  // 80 - 95
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0
  // 112 - 127
];
function isValidStatusCode$2(t) {
  return t >= 1e3 && t <= 1014 && t !== 1004 && t !== 1005 && t !== 1006 || t >= 3e3 && t <= 4999;
}
function _isValidUTF8(t) {
  const e = t.length;
  let r = 0;
  for (; r < e; )
    if (!(t[r] & 128))
      r++;
    else if ((t[r] & 224) === 192) {
      if (r + 1 === e || (t[r + 1] & 192) !== 128 || (t[r] & 254) === 192)
        return !1;
      r += 2;
    } else if ((t[r] & 240) === 224) {
      if (r + 2 >= e || (t[r + 1] & 192) !== 128 || (t[r + 2] & 192) !== 128 || t[r] === 224 && (t[r + 1] & 224) === 128 || // Overlong
      t[r] === 237 && (t[r + 1] & 224) === 160)
        return !1;
      r += 3;
    } else if ((t[r] & 248) === 240) {
      if (r + 3 >= e || (t[r + 1] & 192) !== 128 || (t[r + 2] & 192) !== 128 || (t[r + 3] & 192) !== 128 || t[r] === 240 && (t[r + 1] & 240) === 128 || // Overlong
      t[r] === 244 && t[r + 1] > 143 || t[r] > 244)
        return !1;
      r += 4;
    } else
      return !1;
  return !0;
}
validation.exports = {
  isValidStatusCode: isValidStatusCode$2,
  isValidUTF8: _isValidUTF8,
  tokenChars: tokenChars$2
};
if (isUtf8)
  isValidUTF8_1 = validationExports.isValidUTF8 = function(t) {
    return t.length < 24 ? _isValidUTF8(t) : isUtf8(t);
  };
else if (!process.env.WS_NO_UTF_8_VALIDATE)
  try {
    const t = requireUtf8Validate();
    isValidUTF8_1 = validationExports.isValidUTF8 = function(e) {
      return e.length < 32 ? _isValidUTF8(e) : t(e);
    };
  } catch {
  }
const { Writable } = require$$0$3, PerMessageDeflate$3 = permessageDeflate, {
  BINARY_TYPES: BINARY_TYPES$1,
  EMPTY_BUFFER: EMPTY_BUFFER$2,
  kStatusCode: kStatusCode$1,
  kWebSocket: kWebSocket$2
} = constants, { concat: concat$4, toArrayBuffer, unmask } = bufferUtilExports, { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports, FastBuffer = Buffer[Symbol.species], GET_INFO = 0, GET_PAYLOAD_LENGTH_16 = 1, GET_PAYLOAD_LENGTH_64 = 2, GET_MASK = 3, GET_DATA = 4, INFLATING = 5;
let Receiver$1 = class extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(e = {}) {
    super(), this._binaryType = e.binaryType || BINARY_TYPES$1[0], this._extensions = e.extensions || {}, this._isServer = !!e.isServer, this._maxPayload = e.maxPayload | 0, this._skipUTF8Validation = !!e.skipUTF8Validation, this[kWebSocket$2] = void 0, this._bufferedBytes = 0, this._buffers = [], this._compressed = !1, this._payloadLength = 0, this._mask = void 0, this._fragmented = 0, this._masked = !1, this._fin = !1, this._opcode = 0, this._totalPayloadLength = 0, this._messageLength = 0, this._fragments = [], this._state = GET_INFO, this._loop = !1;
  }
  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(e, r, n) {
    if (this._opcode === 8 && this._state == GET_INFO)
      return n();
    this._bufferedBytes += e.length, this._buffers.push(e), this.startLoop(n);
  }
  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(e) {
    if (this._bufferedBytes -= e, e === this._buffers[0].length)
      return this._buffers.shift();
    if (e < this._buffers[0].length) {
      const n = this._buffers[0];
      return this._buffers[0] = new FastBuffer(
        n.buffer,
        n.byteOffset + e,
        n.length - e
      ), new FastBuffer(n.buffer, n.byteOffset, e);
    }
    const r = Buffer.allocUnsafe(e);
    do {
      const n = this._buffers[0], i = r.length - e;
      e >= n.length ? r.set(this._buffers.shift(), i) : (r.set(new Uint8Array(n.buffer, n.byteOffset, e), i), this._buffers[0] = new FastBuffer(
        n.buffer,
        n.byteOffset + e,
        n.length - e
      )), e -= n.length;
    } while (e > 0);
    return r;
  }
  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(e) {
    let r;
    this._loop = !0;
    do
      switch (this._state) {
        case GET_INFO:
          r = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          r = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          r = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          r = this.getData(e);
          break;
        default:
          this._loop = !1;
          return;
      }
    while (this._loop);
    e(r);
  }
  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = !1;
      return;
    }
    const e = this.consume(2);
    if (e[0] & 48)
      return this._loop = !1, error$1(
        RangeError,
        "RSV2 and RSV3 must be clear",
        !0,
        1002,
        "WS_ERR_UNEXPECTED_RSV_2_3"
      );
    const r = (e[0] & 64) === 64;
    if (r && !this._extensions[PerMessageDeflate$3.extensionName])
      return this._loop = !1, error$1(
        RangeError,
        "RSV1 must be clear",
        !0,
        1002,
        "WS_ERR_UNEXPECTED_RSV_1"
      );
    if (this._fin = (e[0] & 128) === 128, this._opcode = e[0] & 15, this._payloadLength = e[1] & 127, this._opcode === 0) {
      if (r)
        return this._loop = !1, error$1(
          RangeError,
          "RSV1 must be clear",
          !0,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
      if (!this._fragmented)
        return this._loop = !1, error$1(
          RangeError,
          "invalid opcode 0",
          !0,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
      this._opcode = this._fragmented;
    } else if (this._opcode === 1 || this._opcode === 2) {
      if (this._fragmented)
        return this._loop = !1, error$1(
          RangeError,
          `invalid opcode ${this._opcode}`,
          !0,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
      this._compressed = r;
    } else if (this._opcode > 7 && this._opcode < 11) {
      if (!this._fin)
        return this._loop = !1, error$1(
          RangeError,
          "FIN must be set",
          !0,
          1002,
          "WS_ERR_EXPECTED_FIN"
        );
      if (r)
        return this._loop = !1, error$1(
          RangeError,
          "RSV1 must be clear",
          !0,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1)
        return this._loop = !1, error$1(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          !0,
          1002,
          "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
        );
    } else
      return this._loop = !1, error$1(
        RangeError,
        `invalid opcode ${this._opcode}`,
        !0,
        1002,
        "WS_ERR_INVALID_OPCODE"
      );
    if (!this._fin && !this._fragmented && (this._fragmented = this._opcode), this._masked = (e[1] & 128) === 128, this._isServer) {
      if (!this._masked)
        return this._loop = !1, error$1(
          RangeError,
          "MASK must be set",
          !0,
          1002,
          "WS_ERR_EXPECTED_MASK"
        );
    } else if (this._masked)
      return this._loop = !1, error$1(
        RangeError,
        "MASK must be clear",
        !0,
        1002,
        "WS_ERR_UNEXPECTED_MASK"
      );
    if (this._payloadLength === 126)
      this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127)
      this._state = GET_PAYLOAD_LENGTH_64;
    else
      return this.haveLength();
  }
  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = !1;
      return;
    }
    return this._payloadLength = this.consume(2).readUInt16BE(0), this.haveLength();
  }
  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = !1;
      return;
    }
    const e = this.consume(8), r = e.readUInt32BE(0);
    return r > Math.pow(2, 53 - 32) - 1 ? (this._loop = !1, error$1(
      RangeError,
      "Unsupported WebSocket frame: payload length > 2^53 - 1",
      !1,
      1009,
      "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
    )) : (this._payloadLength = r * Math.pow(2, 32) + e.readUInt32BE(4), this.haveLength());
  }
  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 8 && (this._totalPayloadLength += this._payloadLength, this._totalPayloadLength > this._maxPayload && this._maxPayload > 0))
      return this._loop = !1, error$1(
        RangeError,
        "Max payload size exceeded",
        !1,
        1009,
        "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
      );
    this._masked ? this._state = GET_MASK : this._state = GET_DATA;
  }
  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = !1;
      return;
    }
    this._mask = this.consume(4), this._state = GET_DATA;
  }
  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(e) {
    let r = EMPTY_BUFFER$2;
    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = !1;
        return;
      }
      r = this.consume(this._payloadLength), this._masked && this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3] && unmask(r, this._mask);
    }
    if (this._opcode > 7)
      return this.controlMessage(r);
    if (this._compressed) {
      this._state = INFLATING, this.decompress(r, e);
      return;
    }
    return r.length && (this._messageLength = this._totalPayloadLength, this._fragments.push(r)), this.dataMessage();
  }
  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(e, r) {
    this._extensions[PerMessageDeflate$3.extensionName].decompress(e, this._fin, (i, o) => {
      if (i)
        return r(i);
      if (o.length) {
        if (this._messageLength += o.length, this._messageLength > this._maxPayload && this._maxPayload > 0)
          return r(
            error$1(
              RangeError,
              "Max payload size exceeded",
              !1,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            )
          );
        this._fragments.push(o);
      }
      const a = this.dataMessage();
      if (a)
        return r(a);
      this.startLoop(r);
    });
  }
  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const e = this._messageLength, r = this._fragments;
      if (this._totalPayloadLength = 0, this._messageLength = 0, this._fragmented = 0, this._fragments = [], this._opcode === 2) {
        let n;
        this._binaryType === "nodebuffer" ? n = concat$4(r, e) : this._binaryType === "arraybuffer" ? n = toArrayBuffer(concat$4(r, e)) : n = r, this.emit("message", n, !0);
      } else {
        const n = concat$4(r, e);
        if (!this._skipUTF8Validation && !isValidUTF8(n))
          return this._loop = !1, error$1(
            Error,
            "invalid UTF-8 sequence",
            !0,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
        this.emit("message", n, !1);
      }
    }
    this._state = GET_INFO;
  }
  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(e) {
    if (this._opcode === 8)
      if (this._loop = !1, e.length === 0)
        this.emit("conclude", 1005, EMPTY_BUFFER$2), this.end();
      else {
        const r = e.readUInt16BE(0);
        if (!isValidStatusCode$1(r))
          return error$1(
            RangeError,
            `invalid status code ${r}`,
            !0,
            1002,
            "WS_ERR_INVALID_CLOSE_CODE"
          );
        const n = new FastBuffer(
          e.buffer,
          e.byteOffset + 2,
          e.length - 2
        );
        if (!this._skipUTF8Validation && !isValidUTF8(n))
          return error$1(
            Error,
            "invalid UTF-8 sequence",
            !0,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
        this.emit("conclude", r, n), this.end();
      }
    else
      this._opcode === 9 ? this.emit("ping", e) : this.emit("pong", e);
    this._state = GET_INFO;
  }
};
var receiver = Receiver$1;
function error$1(t, e, r, n, i) {
  const o = new t(
    r ? `Invalid WebSocket frame: ${e}` : e
  );
  return Error.captureStackTrace(o, error$1), o.code = i, o[kStatusCode$1] = n, o;
}
const { randomFillSync } = crypto$3, PerMessageDeflate$2 = permessageDeflate, { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants, { isValidStatusCode } = validationExports, { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports, kByteLength = Symbol("kByteLength"), maskBuffer = Buffer.alloc(4);
let Sender$1 = class ye {
  /**
   * Creates a Sender instance.
   *
   * @param {(net.Socket|tls.Socket)} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(e, r, n) {
    this._extensions = r || {}, n && (this._generateMask = n, this._maskBuffer = Buffer.alloc(4)), this._socket = e, this._firstFragment = !0, this._compress = !1, this._bufferedBytes = 0, this._deflating = !1, this._queue = [];
  }
  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(e, r) {
    let n, i = !1, o = 2, a = !1;
    r.mask && (n = r.maskBuffer || maskBuffer, r.generateMask ? r.generateMask(n) : randomFillSync(n, 0, 4), a = (n[0] | n[1] | n[2] | n[3]) === 0, o = 6);
    let c;
    typeof e == "string" ? (!r.mask || a) && r[kByteLength] !== void 0 ? c = r[kByteLength] : (e = Buffer.from(e), c = e.length) : (c = e.length, i = r.mask && r.readOnly && !a);
    let l = c;
    c >= 65536 ? (o += 8, l = 127) : c > 125 && (o += 2, l = 126);
    const u = Buffer.allocUnsafe(i ? c + o : o);
    return u[0] = r.fin ? r.opcode | 128 : r.opcode, r.rsv1 && (u[0] |= 64), u[1] = l, l === 126 ? u.writeUInt16BE(c, 2) : l === 127 && (u[2] = u[3] = 0, u.writeUIntBE(c, 4, 6)), r.mask ? (u[1] |= 128, u[o - 4] = n[0], u[o - 3] = n[1], u[o - 2] = n[2], u[o - 1] = n[3], a ? [u, e] : i ? (applyMask(e, n, u, o, c), [u]) : (applyMask(e, n, e, 0, c), [u, e])) : [u, e];
  }
  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(e, r, n, i) {
    let o;
    if (e === void 0)
      o = EMPTY_BUFFER$1;
    else {
      if (typeof e != "number" || !isValidStatusCode(e))
        throw new TypeError("First argument must be a valid error code number");
      if (r === void 0 || !r.length)
        o = Buffer.allocUnsafe(2), o.writeUInt16BE(e, 0);
      else {
        const c = Buffer.byteLength(r);
        if (c > 123)
          throw new RangeError("The message must not be greater than 123 bytes");
        o = Buffer.allocUnsafe(2 + c), o.writeUInt16BE(e, 0), typeof r == "string" ? o.write(r, 2) : o.set(r, 2);
      }
    }
    const a = {
      [kByteLength]: o.length,
      fin: !0,
      generateMask: this._generateMask,
      mask: n,
      maskBuffer: this._maskBuffer,
      opcode: 8,
      readOnly: !1,
      rsv1: !1
    };
    this._deflating ? this.enqueue([this.dispatch, o, !1, a, i]) : this.sendFrame(ye.frame(o, a), i);
  }
  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(e, r, n) {
    let i, o;
    if (typeof e == "string" ? (i = Buffer.byteLength(e), o = !1) : (e = toBuffer$1(e), i = e.length, o = toBuffer$1.readOnly), i > 125)
      throw new RangeError("The data size must not be greater than 125 bytes");
    const a = {
      [kByteLength]: i,
      fin: !0,
      generateMask: this._generateMask,
      mask: r,
      maskBuffer: this._maskBuffer,
      opcode: 9,
      readOnly: o,
      rsv1: !1
    };
    this._deflating ? this.enqueue([this.dispatch, e, !1, a, n]) : this.sendFrame(ye.frame(e, a), n);
  }
  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(e, r, n) {
    let i, o;
    if (typeof e == "string" ? (i = Buffer.byteLength(e), o = !1) : (e = toBuffer$1(e), i = e.length, o = toBuffer$1.readOnly), i > 125)
      throw new RangeError("The data size must not be greater than 125 bytes");
    const a = {
      [kByteLength]: i,
      fin: !0,
      generateMask: this._generateMask,
      mask: r,
      maskBuffer: this._maskBuffer,
      opcode: 10,
      readOnly: o,
      rsv1: !1
    };
    this._deflating ? this.enqueue([this.dispatch, e, !1, a, n]) : this.sendFrame(ye.frame(e, a), n);
  }
  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(e, r, n) {
    const i = this._extensions[PerMessageDeflate$2.extensionName];
    let o = r.binary ? 2 : 1, a = r.compress, c, l;
    if (typeof e == "string" ? (c = Buffer.byteLength(e), l = !1) : (e = toBuffer$1(e), c = e.length, l = toBuffer$1.readOnly), this._firstFragment ? (this._firstFragment = !1, a && i && i.params[i._isServer ? "server_no_context_takeover" : "client_no_context_takeover"] && (a = c >= i._threshold), this._compress = a) : (a = !1, o = 0), r.fin && (this._firstFragment = !0), i) {
      const u = {
        [kByteLength]: c,
        fin: r.fin,
        generateMask: this._generateMask,
        mask: r.mask,
        maskBuffer: this._maskBuffer,
        opcode: o,
        readOnly: l,
        rsv1: a
      };
      this._deflating ? this.enqueue([this.dispatch, e, this._compress, u, n]) : this.dispatch(e, this._compress, u, n);
    } else
      this.sendFrame(
        ye.frame(e, {
          [kByteLength]: c,
          fin: r.fin,
          generateMask: this._generateMask,
          mask: r.mask,
          maskBuffer: this._maskBuffer,
          opcode: o,
          readOnly: l,
          rsv1: !1
        }),
        n
      );
  }
  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(e, r, n, i) {
    if (!r) {
      this.sendFrame(ye.frame(e, n), i);
      return;
    }
    const o = this._extensions[PerMessageDeflate$2.extensionName];
    this._bufferedBytes += n[kByteLength], this._deflating = !0, o.compress(e, n.fin, (a, c) => {
      if (this._socket.destroyed) {
        const l = new Error(
          "The socket was closed while data was being compressed"
        );
        typeof i == "function" && i(l);
        for (let u = 0; u < this._queue.length; u++) {
          const f = this._queue[u], d = f[f.length - 1];
          typeof d == "function" && d(l);
        }
        return;
      }
      this._bufferedBytes -= n[kByteLength], this._deflating = !1, n.readOnly = !1, this.sendFrame(ye.frame(c, n), i), this.dequeue();
    });
  }
  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    for (; !this._deflating && this._queue.length; ) {
      const e = this._queue.shift();
      this._bufferedBytes -= e[3][kByteLength], Reflect.apply(e[0], this, e.slice(1));
    }
  }
  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(e) {
    this._bufferedBytes += e[3][kByteLength], this._queue.push(e);
  }
  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(e, r) {
    e.length === 2 ? (this._socket.cork(), this._socket.write(e[0]), this._socket.write(e[1], r), this._socket.uncork()) : this._socket.write(e[0], r);
  }
};
var sender = Sender$1;
const { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants, kCode = Symbol("kCode"), kData = Symbol("kData"), kError = Symbol("kError"), kMessage = Symbol("kMessage"), kReason = Symbol("kReason"), kTarget = Symbol("kTarget"), kType = Symbol("kType"), kWasClean = Symbol("kWasClean");
let Event$1 = class {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(e) {
    this[kTarget] = null, this[kType] = e;
  }
  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }
  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
};
Object.defineProperty(Event$1.prototype, "target", { enumerable: !0 });
Object.defineProperty(Event$1.prototype, "type", { enumerable: !0 });
class CloseEvent extends Event$1 {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(e, r = {}) {
    super(e), this[kCode] = r.code === void 0 ? 0 : r.code, this[kReason] = r.reason === void 0 ? "" : r.reason, this[kWasClean] = r.wasClean === void 0 ? !1 : r.wasClean;
  }
  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }
  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }
  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}
Object.defineProperty(CloseEvent.prototype, "code", { enumerable: !0 });
Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: !0 });
Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: !0 });
class ErrorEvent extends Event$1 {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(e, r = {}) {
    super(e), this[kError] = r.error === void 0 ? null : r.error, this[kMessage] = r.message === void 0 ? "" : r.message;
  }
  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }
  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}
Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: !0 });
Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: !0 });
let MessageEvent$1 = class extends Event$1 {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(e, r = {}) {
    super(e), this[kData] = r.data === void 0 ? null : r.data;
  }
  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
};
Object.defineProperty(MessageEvent$1.prototype, "data", { enumerable: !0 });
const EventTarget$1 = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(t, e, r = {}) {
    for (const i of this.listeners(t))
      if (!r[kForOnEventAttribute$1] && i[kListener$1] === e && !i[kForOnEventAttribute$1])
        return;
    let n;
    if (t === "message")
      n = function(o, a) {
        const c = new MessageEvent$1("message", {
          data: a ? o : o.toString()
        });
        c[kTarget] = this, callListener(e, this, c);
      };
    else if (t === "close")
      n = function(o, a) {
        const c = new CloseEvent("close", {
          code: o,
          reason: a.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });
        c[kTarget] = this, callListener(e, this, c);
      };
    else if (t === "error")
      n = function(o) {
        const a = new ErrorEvent("error", {
          error: o,
          message: o.message
        });
        a[kTarget] = this, callListener(e, this, a);
      };
    else if (t === "open")
      n = function() {
        const o = new Event$1("open");
        o[kTarget] = this, callListener(e, this, o);
      };
    else
      return;
    n[kForOnEventAttribute$1] = !!r[kForOnEventAttribute$1], n[kListener$1] = e, r.once ? this.once(t, n) : this.on(t, n);
  },
  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(t, e) {
    for (const r of this.listeners(t))
      if (r[kListener$1] === e && !r[kForOnEventAttribute$1]) {
        this.removeListener(t, r);
        break;
      }
  }
};
var eventTarget = {
  CloseEvent,
  ErrorEvent,
  Event: Event$1,
  EventTarget: EventTarget$1,
  MessageEvent: MessageEvent$1
};
function callListener(t, e, r) {
  typeof t == "object" && t.handleEvent ? t.handleEvent.call(t, r) : t.call(e, r);
}
const { tokenChars: tokenChars$1 } = validationExports;
function push(t, e, r) {
  t[e] === void 0 ? t[e] = [r] : t[e].push(r);
}
function parse$2(t) {
  const e = /* @__PURE__ */ Object.create(null);
  let r = /* @__PURE__ */ Object.create(null), n = !1, i = !1, o = !1, a, c, l = -1, u = -1, f = -1, d = 0;
  for (; d < t.length; d++)
    if (u = t.charCodeAt(d), a === void 0)
      if (f === -1 && tokenChars$1[u] === 1)
        l === -1 && (l = d);
      else if (d !== 0 && (u === 32 || u === 9))
        f === -1 && l !== -1 && (f = d);
      else if (u === 59 || u === 44) {
        if (l === -1)
          throw new SyntaxError(`Unexpected character at index ${d}`);
        f === -1 && (f = d);
        const g = t.slice(l, f);
        u === 44 ? (push(e, g, r), r = /* @__PURE__ */ Object.create(null)) : a = g, l = f = -1;
      } else
        throw new SyntaxError(`Unexpected character at index ${d}`);
    else if (c === void 0)
      if (f === -1 && tokenChars$1[u] === 1)
        l === -1 && (l = d);
      else if (u === 32 || u === 9)
        f === -1 && l !== -1 && (f = d);
      else if (u === 59 || u === 44) {
        if (l === -1)
          throw new SyntaxError(`Unexpected character at index ${d}`);
        f === -1 && (f = d), push(r, t.slice(l, f), !0), u === 44 && (push(e, a, r), r = /* @__PURE__ */ Object.create(null), a = void 0), l = f = -1;
      } else if (u === 61 && l !== -1 && f === -1)
        c = t.slice(l, d), l = f = -1;
      else
        throw new SyntaxError(`Unexpected character at index ${d}`);
    else if (i) {
      if (tokenChars$1[u] !== 1)
        throw new SyntaxError(`Unexpected character at index ${d}`);
      l === -1 ? l = d : n || (n = !0), i = !1;
    } else if (o)
      if (tokenChars$1[u] === 1)
        l === -1 && (l = d);
      else if (u === 34 && l !== -1)
        o = !1, f = d;
      else if (u === 92)
        i = !0;
      else
        throw new SyntaxError(`Unexpected character at index ${d}`);
    else if (u === 34 && t.charCodeAt(d - 1) === 61)
      o = !0;
    else if (f === -1 && tokenChars$1[u] === 1)
      l === -1 && (l = d);
    else if (l !== -1 && (u === 32 || u === 9))
      f === -1 && (f = d);
    else if (u === 59 || u === 44) {
      if (l === -1)
        throw new SyntaxError(`Unexpected character at index ${d}`);
      f === -1 && (f = d);
      let g = t.slice(l, f);
      n && (g = g.replace(/\\/g, ""), n = !1), push(r, c, g), u === 44 && (push(e, a, r), r = /* @__PURE__ */ Object.create(null), a = void 0), c = void 0, l = f = -1;
    } else
      throw new SyntaxError(`Unexpected character at index ${d}`);
  if (l === -1 || o || u === 32 || u === 9)
    throw new SyntaxError("Unexpected end of input");
  f === -1 && (f = d);
  const p = t.slice(l, f);
  return a === void 0 ? push(e, p, r) : (c === void 0 ? push(r, p, !0) : n ? push(r, c, p.replace(/\\/g, "")) : push(r, c, p), push(e, a, r)), e;
}
function format$4(t) {
  return Object.keys(t).map((e) => {
    let r = t[e];
    return Array.isArray(r) || (r = [r]), r.map((n) => [e].concat(
      Object.keys(n).map((i) => {
        let o = n[i];
        return Array.isArray(o) || (o = [o]), o.map((a) => a === !0 ? i : `${i}=${a}`).join("; ");
      })
    ).join("; ")).join(", ");
  }).join(", ");
}
var extension$1 = { format: format$4, parse: parse$2 };
const EventEmitter$1 = require$$0$4, https = require$$1$2, http$1 = require$$2, net = require$$3, tls = require$$4, { randomBytes, createHash: createHash$1 } = crypto$3, { URL: URL$2 } = require$$7, PerMessageDeflate$1 = permessageDeflate, Receiver = receiver, Sender = sender, {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID: GUID$1,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket: kWebSocket$1,
  NOOP
} = constants, {
  EventTarget: { addEventListener, removeEventListener }
} = eventTarget, { format: format$3, parse: parse$1 } = extension$1, { toBuffer } = bufferUtilExports, closeTimeout = 30 * 1e3, kAborted = Symbol("kAborted"), protocolVersions = [8, 13], readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"], subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
let WebSocket$1 = class X extends EventEmitter$1 {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(e, r, n) {
    super(), this._binaryType = BINARY_TYPES[0], this._closeCode = 1006, this._closeFrameReceived = !1, this._closeFrameSent = !1, this._closeMessage = EMPTY_BUFFER, this._closeTimer = null, this._extensions = {}, this._paused = !1, this._protocol = "", this._readyState = X.CONNECTING, this._receiver = null, this._sender = null, this._socket = null, e !== null ? (this._bufferedAmount = 0, this._isServer = !1, this._redirects = 0, r === void 0 ? r = [] : Array.isArray(r) || (typeof r == "object" && r !== null ? (n = r, r = []) : r = [r]), initAsClient(this, e, r, n)) : this._isServer = !0;
  }
  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }
  set binaryType(e) {
    BINARY_TYPES.includes(e) && (this._binaryType = e, this._receiver && (this._receiver._binaryType = e));
  }
  /**
   * @type {Number}
   */
  get bufferedAmount() {
    return this._socket ? this._socket._writableState.length + this._sender._bufferedBytes : this._bufferedAmount;
  }
  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }
  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }
  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }
  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }
  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }
  /**
   * Set up the socket and the internal resources.
   *
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(e, r, n) {
    const i = new Receiver({
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: n.maxPayload,
      skipUTF8Validation: n.skipUTF8Validation
    });
    this._sender = new Sender(e, this._extensions, n.generateMask), this._receiver = i, this._socket = e, i[kWebSocket$1] = this, e[kWebSocket$1] = this, i.on("conclude", receiverOnConclude), i.on("drain", receiverOnDrain), i.on("error", receiverOnError), i.on("message", receiverOnMessage), i.on("ping", receiverOnPing), i.on("pong", receiverOnPong), e.setTimeout(0), e.setNoDelay(), r.length > 0 && e.unshift(r), e.on("close", socketOnClose), e.on("data", socketOnData), e.on("end", socketOnEnd), e.on("error", socketOnError$1), this._readyState = X.OPEN, this.emit("open");
  }
  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = X.CLOSED, this.emit("close", this._closeCode, this._closeMessage);
      return;
    }
    this._extensions[PerMessageDeflate$1.extensionName] && this._extensions[PerMessageDeflate$1.extensionName].cleanup(), this._receiver.removeAllListeners(), this._readyState = X.CLOSED, this.emit("close", this._closeCode, this._closeMessage);
  }
  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(e, r) {
    if (this.readyState !== X.CLOSED) {
      if (this.readyState === X.CONNECTING) {
        const n = "WebSocket was closed before the connection was established";
        abortHandshake$1(this, this._req, n);
        return;
      }
      if (this.readyState === X.CLOSING) {
        this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end();
        return;
      }
      this._readyState = X.CLOSING, this._sender.close(e, r, !this._isServer, (n) => {
        n || (this._closeFrameSent = !0, (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end());
      }), this._closeTimer = setTimeout(
        this._socket.destroy.bind(this._socket),
        closeTimeout
      );
    }
  }
  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    this.readyState === X.CONNECTING || this.readyState === X.CLOSED || (this._paused = !0, this._socket.pause());
  }
  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(e, r, n) {
    if (this.readyState === X.CONNECTING)
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    if (typeof e == "function" ? (n = e, e = r = void 0) : typeof r == "function" && (n = r, r = void 0), typeof e == "number" && (e = e.toString()), this.readyState !== X.OPEN) {
      sendAfterClose(this, e, n);
      return;
    }
    r === void 0 && (r = !this._isServer), this._sender.ping(e || EMPTY_BUFFER, r, n);
  }
  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(e, r, n) {
    if (this.readyState === X.CONNECTING)
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    if (typeof e == "function" ? (n = e, e = r = void 0) : typeof r == "function" && (n = r, r = void 0), typeof e == "number" && (e = e.toString()), this.readyState !== X.OPEN) {
      sendAfterClose(this, e, n);
      return;
    }
    r === void 0 && (r = !this._isServer), this._sender.pong(e || EMPTY_BUFFER, r, n);
  }
  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    this.readyState === X.CONNECTING || this.readyState === X.CLOSED || (this._paused = !1, this._receiver._writableState.needDrain || this._socket.resume());
  }
  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(e, r, n) {
    if (this.readyState === X.CONNECTING)
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    if (typeof r == "function" && (n = r, r = {}), typeof e == "number" && (e = e.toString()), this.readyState !== X.OPEN) {
      sendAfterClose(this, e, n);
      return;
    }
    const i = {
      binary: typeof e != "string",
      mask: !this._isServer,
      compress: !0,
      fin: !0,
      ...r
    };
    this._extensions[PerMessageDeflate$1.extensionName] || (i.compress = !1), this._sender.send(e || EMPTY_BUFFER, i, n);
  }
  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState !== X.CLOSED) {
      if (this.readyState === X.CONNECTING) {
        const e = "WebSocket was closed before the connection was established";
        abortHandshake$1(this, this._req, e);
        return;
      }
      this._socket && (this._readyState = X.CLOSING, this._socket.destroy());
    }
  }
};
Object.defineProperty(WebSocket$1, "CONNECTING", {
  enumerable: !0,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$1.prototype, "CONNECTING", {
  enumerable: !0,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$1, "OPEN", {
  enumerable: !0,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$1.prototype, "OPEN", {
  enumerable: !0,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$1, "CLOSING", {
  enumerable: !0,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$1.prototype, "CLOSING", {
  enumerable: !0,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$1, "CLOSED", {
  enumerable: !0,
  value: readyStates.indexOf("CLOSED")
});
Object.defineProperty(WebSocket$1.prototype, "CLOSED", {
  enumerable: !0,
  value: readyStates.indexOf("CLOSED")
});
[
  "binaryType",
  "bufferedAmount",
  "extensions",
  "isPaused",
  "protocol",
  "readyState",
  "url"
].forEach((t) => {
  Object.defineProperty(WebSocket$1.prototype, t, { enumerable: !0 });
});
["open", "error", "close", "message"].forEach((t) => {
  Object.defineProperty(WebSocket$1.prototype, `on${t}`, {
    enumerable: !0,
    get() {
      for (const e of this.listeners(t))
        if (e[kForOnEventAttribute])
          return e[kListener];
      return null;
    },
    set(e) {
      for (const r of this.listeners(t))
        if (r[kForOnEventAttribute]) {
          this.removeListener(t, r);
          break;
        }
      typeof e == "function" && this.addEventListener(t, e, {
        [kForOnEventAttribute]: !0
      });
    }
  });
});
WebSocket$1.prototype.addEventListener = addEventListener;
WebSocket$1.prototype.removeEventListener = removeEventListener;
var websocket = WebSocket$1;
function initAsClient(t, e, r, n) {
  const i = {
    protocolVersion: protocolVersions[1],
    maxPayload: 104857600,
    skipUTF8Validation: !1,
    perMessageDeflate: !0,
    followRedirects: !1,
    maxRedirects: 10,
    ...n,
    createConnection: void 0,
    socketPath: void 0,
    hostname: void 0,
    protocol: void 0,
    timeout: void 0,
    method: "GET",
    host: void 0,
    path: void 0,
    port: void 0
  };
  if (!protocolVersions.includes(i.protocolVersion))
    throw new RangeError(
      `Unsupported protocol version: ${i.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
    );
  let o;
  if (e instanceof URL$2)
    o = e, t._url = e.href;
  else {
    try {
      o = new URL$2(e);
    } catch {
      throw new SyntaxError(`Invalid URL: ${e}`);
    }
    t._url = e;
  }
  const a = o.protocol === "wss:", c = o.protocol === "ws+unix:";
  let l;
  if (o.protocol !== "ws:" && !a && !c ? l = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"` : c && !o.pathname ? l = "The URL's pathname is empty" : o.hash && (l = "The URL contains a fragment identifier"), l) {
    const m = new SyntaxError(l);
    if (t._redirects === 0)
      throw m;
    emitErrorAndClose(t, m);
    return;
  }
  const u = a ? 443 : 80, f = randomBytes(16).toString("base64"), d = a ? https.request : http$1.request, p = /* @__PURE__ */ new Set();
  let g;
  if (i.createConnection = a ? tlsConnect : netConnect, i.defaultPort = i.defaultPort || u, i.port = o.port || u, i.host = o.hostname.startsWith("[") ? o.hostname.slice(1, -1) : o.hostname, i.headers = {
    ...i.headers,
    "Sec-WebSocket-Version": i.protocolVersion,
    "Sec-WebSocket-Key": f,
    Connection: "Upgrade",
    Upgrade: "websocket"
  }, i.path = o.pathname + o.search, i.timeout = i.handshakeTimeout, i.perMessageDeflate && (g = new PerMessageDeflate$1(
    i.perMessageDeflate !== !0 ? i.perMessageDeflate : {},
    !1,
    i.maxPayload
  ), i.headers["Sec-WebSocket-Extensions"] = format$3({
    [PerMessageDeflate$1.extensionName]: g.offer()
  })), r.length) {
    for (const m of r) {
      if (typeof m != "string" || !subprotocolRegex.test(m) || p.has(m))
        throw new SyntaxError(
          "An invalid or duplicated subprotocol was specified"
        );
      p.add(m);
    }
    i.headers["Sec-WebSocket-Protocol"] = r.join(",");
  }
  if (i.origin && (i.protocolVersion < 13 ? i.headers["Sec-WebSocket-Origin"] = i.origin : i.headers.Origin = i.origin), (o.username || o.password) && (i.auth = `${o.username}:${o.password}`), c) {
    const m = i.path.split(":");
    i.socketPath = m[0], i.path = m[1];
  }
  let h;
  if (i.followRedirects) {
    if (t._redirects === 0) {
      t._originalIpc = c, t._originalSecure = a, t._originalHostOrSocketPath = c ? i.socketPath : o.host;
      const m = n && n.headers;
      if (n = { ...n, headers: {} }, m)
        for (const [y, b] of Object.entries(m))
          n.headers[y.toLowerCase()] = b;
    } else if (t.listenerCount("redirect") === 0) {
      const m = c ? t._originalIpc ? i.socketPath === t._originalHostOrSocketPath : !1 : t._originalIpc ? !1 : o.host === t._originalHostOrSocketPath;
      (!m || t._originalSecure && !a) && (delete i.headers.authorization, delete i.headers.cookie, m || delete i.headers.host, i.auth = void 0);
    }
    i.auth && !n.headers.authorization && (n.headers.authorization = "Basic " + Buffer.from(i.auth).toString("base64")), h = t._req = d(i), t._redirects && t.emit("redirect", t.url, h);
  } else
    h = t._req = d(i);
  i.timeout && h.on("timeout", () => {
    abortHandshake$1(t, h, "Opening handshake has timed out");
  }), h.on("error", (m) => {
    h === null || h[kAborted] || (h = t._req = null, emitErrorAndClose(t, m));
  }), h.on("response", (m) => {
    const y = m.headers.location, b = m.statusCode;
    if (y && i.followRedirects && b >= 300 && b < 400) {
      if (++t._redirects > i.maxRedirects) {
        abortHandshake$1(t, h, "Maximum redirects exceeded");
        return;
      }
      h.abort();
      let v;
      try {
        v = new URL$2(y, e);
      } catch {
        const E = new SyntaxError(`Invalid URL: ${y}`);
        emitErrorAndClose(t, E);
        return;
      }
      initAsClient(t, v, r, n);
    } else
      t.emit("unexpected-response", h, m) || abortHandshake$1(
        t,
        h,
        `Unexpected server response: ${m.statusCode}`
      );
  }), h.on("upgrade", (m, y, b) => {
    if (t.emit("upgrade", m), t.readyState !== WebSocket$1.CONNECTING)
      return;
    if (h = t._req = null, m.headers.upgrade.toLowerCase() !== "websocket") {
      abortHandshake$1(t, y, "Invalid Upgrade header");
      return;
    }
    const v = createHash$1("sha1").update(f + GUID$1).digest("base64");
    if (m.headers["sec-websocket-accept"] !== v) {
      abortHandshake$1(t, y, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const _ = m.headers["sec-websocket-protocol"];
    let E;
    if (_ !== void 0 ? p.size ? p.has(_) || (E = "Server sent an invalid subprotocol") : E = "Server sent a subprotocol but none was requested" : p.size && (E = "Server sent no subprotocol"), E) {
      abortHandshake$1(t, y, E);
      return;
    }
    _ && (t._protocol = _);
    const w = m.headers["sec-websocket-extensions"];
    if (w !== void 0) {
      if (!g) {
        abortHandshake$1(t, y, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
        return;
      }
      let S;
      try {
        S = parse$1(w);
      } catch {
        abortHandshake$1(t, y, "Invalid Sec-WebSocket-Extensions header");
        return;
      }
      const x = Object.keys(S);
      if (x.length !== 1 || x[0] !== PerMessageDeflate$1.extensionName) {
        abortHandshake$1(t, y, "Server indicated an extension that was not requested");
        return;
      }
      try {
        g.accept(S[PerMessageDeflate$1.extensionName]);
      } catch {
        abortHandshake$1(t, y, "Invalid Sec-WebSocket-Extensions header");
        return;
      }
      t._extensions[PerMessageDeflate$1.extensionName] = g;
    }
    t.setSocket(y, b, {
      generateMask: i.generateMask,
      maxPayload: i.maxPayload,
      skipUTF8Validation: i.skipUTF8Validation
    });
  }), i.finishRequest ? i.finishRequest(h, t) : h.end();
}
function emitErrorAndClose(t, e) {
  t._readyState = WebSocket$1.CLOSING, t.emit("error", e), t.emitClose();
}
function netConnect(t) {
  return t.path = t.socketPath, net.connect(t);
}
function tlsConnect(t) {
  return t.path = void 0, !t.servername && t.servername !== "" && (t.servername = net.isIP(t.host) ? "" : t.host), tls.connect(t);
}
function abortHandshake$1(t, e, r) {
  t._readyState = WebSocket$1.CLOSING;
  const n = new Error(r);
  Error.captureStackTrace(n, abortHandshake$1), e.setHeader ? (e[kAborted] = !0, e.abort(), e.socket && !e.socket.destroyed && e.socket.destroy(), process.nextTick(emitErrorAndClose, t, n)) : (e.destroy(n), e.once("error", t.emit.bind(t, "error")), e.once("close", t.emitClose.bind(t)));
}
function sendAfterClose(t, e, r) {
  if (e) {
    const n = toBuffer(e).length;
    t._socket ? t._sender._bufferedBytes += n : t._bufferedAmount += n;
  }
  if (r) {
    const n = new Error(
      `WebSocket is not open: readyState ${t.readyState} (${readyStates[t.readyState]})`
    );
    process.nextTick(r, n);
  }
}
function receiverOnConclude(t, e) {
  const r = this[kWebSocket$1];
  r._closeFrameReceived = !0, r._closeMessage = e, r._closeCode = t, r._socket[kWebSocket$1] !== void 0 && (r._socket.removeListener("data", socketOnData), process.nextTick(resume, r._socket), t === 1005 ? r.close() : r.close(t, e));
}
function receiverOnDrain() {
  const t = this[kWebSocket$1];
  t.isPaused || t._socket.resume();
}
function receiverOnError(t) {
  const e = this[kWebSocket$1];
  e._socket[kWebSocket$1] !== void 0 && (e._socket.removeListener("data", socketOnData), process.nextTick(resume, e._socket), e.close(t[kStatusCode])), e.emit("error", t);
}
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}
function receiverOnMessage(t, e) {
  this[kWebSocket$1].emit("message", t, e);
}
function receiverOnPing(t) {
  const e = this[kWebSocket$1];
  e.pong(t, !e._isServer, NOOP), e.emit("ping", t);
}
function receiverOnPong(t) {
  this[kWebSocket$1].emit("pong", t);
}
function resume(t) {
  t.resume();
}
function socketOnClose() {
  const t = this[kWebSocket$1];
  this.removeListener("close", socketOnClose), this.removeListener("data", socketOnData), this.removeListener("end", socketOnEnd), t._readyState = WebSocket$1.CLOSING;
  let e;
  !this._readableState.endEmitted && !t._closeFrameReceived && !t._receiver._writableState.errorEmitted && (e = t._socket.read()) !== null && t._receiver.write(e), t._receiver.end(), this[kWebSocket$1] = void 0, clearTimeout(t._closeTimer), t._receiver._writableState.finished || t._receiver._writableState.errorEmitted ? t.emitClose() : (t._receiver.on("error", receiverOnFinish), t._receiver.on("finish", receiverOnFinish));
}
function socketOnData(t) {
  this[kWebSocket$1]._receiver.write(t) || this.pause();
}
function socketOnEnd() {
  const t = this[kWebSocket$1];
  t._readyState = WebSocket$1.CLOSING, t._receiver.end(), this.end();
}
function socketOnError$1() {
  const t = this[kWebSocket$1];
  this.removeListener("error", socketOnError$1), this.on("error", NOOP), t && (t._readyState = WebSocket$1.CLOSING, this.destroy());
}
const { tokenChars } = validationExports;
function parse(t) {
  const e = /* @__PURE__ */ new Set();
  let r = -1, n = -1, i = 0;
  for (i; i < t.length; i++) {
    const a = t.charCodeAt(i);
    if (n === -1 && tokenChars[a] === 1)
      r === -1 && (r = i);
    else if (i !== 0 && (a === 32 || a === 9))
      n === -1 && r !== -1 && (n = i);
    else if (a === 44) {
      if (r === -1)
        throw new SyntaxError(`Unexpected character at index ${i}`);
      n === -1 && (n = i);
      const c = t.slice(r, n);
      if (e.has(c))
        throw new SyntaxError(`The "${c}" subprotocol is duplicated`);
      e.add(c), r = n = -1;
    } else
      throw new SyntaxError(`Unexpected character at index ${i}`);
  }
  if (r === -1 || n !== -1)
    throw new SyntaxError("Unexpected end of input");
  const o = t.slice(r, i);
  if (e.has(o))
    throw new SyntaxError(`The "${o}" subprotocol is duplicated`);
  return e.add(o), e;
}
var subprotocol$1 = { parse };
const EventEmitter = require$$0$4, http = require$$2, { createHash } = crypto$3, extension = extension$1, PerMessageDeflate = permessageDeflate, subprotocol = subprotocol$1, WebSocket = websocket, { GUID, kWebSocket } = constants, keyRegex = /^[+/0-9A-Za-z]{22}==$/, RUNNING = 0, CLOSING = 1, CLOSED = 2;
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(e, r) {
    if (super(), e = {
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: !1,
      perMessageDeflate: !1,
      handleProtocols: null,
      clientTracking: !0,
      verifyClient: null,
      noServer: !1,
      backlog: null,
      // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...e
    }, e.port == null && !e.server && !e.noServer || e.port != null && (e.server || e.noServer) || e.server && e.noServer)
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options must be specified'
      );
    if (e.port != null ? (this._server = http.createServer((n, i) => {
      const o = http.STATUS_CODES[426];
      i.writeHead(426, {
        "Content-Length": o.length,
        "Content-Type": "text/plain"
      }), i.end(o);
    }), this._server.listen(
      e.port,
      e.host,
      e.backlog,
      r
    )) : e.server && (this._server = e.server), this._server) {
      const n = this.emit.bind(this, "connection");
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, "listening"),
        error: this.emit.bind(this, "error"),
        upgrade: (i, o, a) => {
          this.handleUpgrade(i, o, a, n);
        }
      });
    }
    e.perMessageDeflate === !0 && (e.perMessageDeflate = {}), e.clientTracking && (this.clients = /* @__PURE__ */ new Set(), this._shouldEmitClose = !1), this.options = e, this._state = RUNNING;
  }
  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer)
      throw new Error('The server is operating in "noServer" mode');
    return this._server ? this._server.address() : null;
  }
  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(e) {
    if (this._state === CLOSED) {
      e && this.once("close", () => {
        e(new Error("The server is not running"));
      }), process.nextTick(emitClose, this);
      return;
    }
    if (e && this.once("close", e), this._state !== CLOSING)
      if (this._state = CLOSING, this.options.noServer || this.options.server)
        this._server && (this._removeListeners(), this._removeListeners = this._server = null), this.clients ? this.clients.size ? this._shouldEmitClose = !0 : process.nextTick(emitClose, this) : process.nextTick(emitClose, this);
      else {
        const r = this._server;
        this._removeListeners(), this._removeListeners = this._server = null, r.close(() => {
          emitClose(this);
        });
      }
  }
  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(e) {
    if (this.options.path) {
      const r = e.url.indexOf("?");
      if ((r !== -1 ? e.url.slice(0, r) : e.url) !== this.options.path)
        return !1;
    }
    return !0;
  }
  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(e, r, n, i) {
    r.on("error", socketOnError);
    const o = e.headers["sec-websocket-key"], a = +e.headers["sec-websocket-version"];
    if (e.method !== "GET") {
      abortHandshakeOrEmitwsClientError(this, e, r, 405, "Invalid HTTP method");
      return;
    }
    if (e.headers.upgrade.toLowerCase() !== "websocket") {
      abortHandshakeOrEmitwsClientError(this, e, r, 400, "Invalid Upgrade header");
      return;
    }
    if (!o || !keyRegex.test(o)) {
      abortHandshakeOrEmitwsClientError(this, e, r, 400, "Missing or invalid Sec-WebSocket-Key header");
      return;
    }
    if (a !== 8 && a !== 13) {
      abortHandshakeOrEmitwsClientError(this, e, r, 400, "Missing or invalid Sec-WebSocket-Version header");
      return;
    }
    if (!this.shouldHandle(e)) {
      abortHandshake(r, 400);
      return;
    }
    const c = e.headers["sec-websocket-protocol"];
    let l = /* @__PURE__ */ new Set();
    if (c !== void 0)
      try {
        l = subprotocol.parse(c);
      } catch {
        abortHandshakeOrEmitwsClientError(this, e, r, 400, "Invalid Sec-WebSocket-Protocol header");
        return;
      }
    const u = e.headers["sec-websocket-extensions"], f = {};
    if (this.options.perMessageDeflate && u !== void 0) {
      const d = new PerMessageDeflate(
        this.options.perMessageDeflate,
        !0,
        this.options.maxPayload
      );
      try {
        const p = extension.parse(u);
        p[PerMessageDeflate.extensionName] && (d.accept(p[PerMessageDeflate.extensionName]), f[PerMessageDeflate.extensionName] = d);
      } catch {
        abortHandshakeOrEmitwsClientError(this, e, r, 400, "Invalid or unacceptable Sec-WebSocket-Extensions header");
        return;
      }
    }
    if (this.options.verifyClient) {
      const d = {
        origin: e.headers[`${a === 8 ? "sec-websocket-origin" : "origin"}`],
        secure: !!(e.socket.authorized || e.socket.encrypted),
        req: e
      };
      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(d, (p, g, h, m) => {
          if (!p)
            return abortHandshake(r, g || 401, h, m);
          this.completeUpgrade(
            f,
            o,
            l,
            e,
            r,
            n,
            i
          );
        });
        return;
      }
      if (!this.options.verifyClient(d))
        return abortHandshake(r, 401);
    }
    this.completeUpgrade(f, o, l, e, r, n, i);
  }
  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(e, r, n, i, o, a, c) {
    if (!o.readable || !o.writable)
      return o.destroy();
    if (o[kWebSocket])
      throw new Error(
        "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
      );
    if (this._state > RUNNING)
      return abortHandshake(o, 503);
    const u = [
      "HTTP/1.1 101 Switching Protocols",
      "Upgrade: websocket",
      "Connection: Upgrade",
      `Sec-WebSocket-Accept: ${createHash("sha1").update(r + GUID).digest("base64")}`
    ], f = new this.options.WebSocket(null);
    if (n.size) {
      const d = this.options.handleProtocols ? this.options.handleProtocols(n, i) : n.values().next().value;
      d && (u.push(`Sec-WebSocket-Protocol: ${d}`), f._protocol = d);
    }
    if (e[PerMessageDeflate.extensionName]) {
      const d = e[PerMessageDeflate.extensionName].params, p = extension.format({
        [PerMessageDeflate.extensionName]: [d]
      });
      u.push(`Sec-WebSocket-Extensions: ${p}`), f._extensions = e;
    }
    this.emit("headers", u, i), o.write(u.concat(`\r
`).join(`\r
`)), o.removeListener("error", socketOnError), f.setSocket(o, a, {
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    }), this.clients && (this.clients.add(f), f.on("close", () => {
      this.clients.delete(f), this._shouldEmitClose && !this.clients.size && process.nextTick(emitClose, this);
    })), c(f, i);
  }
}
var websocketServer = WebSocketServer;
function addListeners(t, e) {
  for (const r of Object.keys(e))
    t.on(r, e[r]);
  return function() {
    for (const n of Object.keys(e))
      t.removeListener(n, e[n]);
  };
}
function emitClose(t) {
  t._state = CLOSED, t.emit("close");
}
function socketOnError() {
  this.destroy();
}
function abortHandshake(t, e, r, n) {
  r = r || http.STATUS_CODES[e], n = {
    Connection: "close",
    "Content-Type": "text/html",
    "Content-Length": Buffer.byteLength(r),
    ...n
  }, t.once("finish", t.destroy), t.end(
    `HTTP/1.1 ${e} ${http.STATUS_CODES[e]}\r
` + Object.keys(n).map((i) => `${i}: ${n[i]}`).join(`\r
`) + `\r
\r
` + r
  );
}
function abortHandshakeOrEmitwsClientError(t, e, r, n, i) {
  if (t.listenerCount("wsClientError")) {
    const o = new Error(i);
    Error.captureStackTrace(o, abortHandshakeOrEmitwsClientError), t.emit("wsClientError", o, r, e);
  } else
    abortHandshake(r, n, i);
}
const { URL: URL$1, URLSearchParams: URLSearchParams$1, format: format$2 } = require$$7, defaultBase$1 = "http://localhost";
let URLWithLegacySupport$2 = class extends URL$1 {
  constructor(e = "", r = defaultBase$1) {
    super(e, r), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
  }
  format() {
    return this.toString();
  }
};
var url = {
  URLWithLegacySupport: URLWithLegacySupport$2,
  URLSearchParams: URLSearchParams$1,
  format: format$2,
  defaultBase: defaultBase$1
};
const { URLWithLegacySupport: URLWithLegacySupport$1, format: format$1 } = url;
var relative$1 = (t, e = {}, r = {}, n) => {
  let i = e.protocol ? e.protocol.replace(":", "") : "http";
  i = (r[i] || n || i) + ":";
  let o;
  try {
    o = new URLWithLegacySupport$1(t);
  } catch {
    o = {};
  }
  const a = Object.assign({}, e, {
    protocol: i || o.protocol,
    host: e.host || o.host
  });
  return new URLWithLegacySupport$1(t, format$1(a)).toString();
};
const {
  URLWithLegacySupport,
  format,
  URLSearchParams,
  defaultBase
} = url, relative = relative$1;
var isoUrl = {
  URL: URLWithLegacySupport,
  URLSearchParams,
  format,
  relative,
  defaultBase
};
const map$3 = { http: "ws", https: "wss" }, def = "ws", wsurl = (t, e) => isoUrl.relative(t, e, map$3, def);
function connect$2(t, e) {
  const r = typeof window > "u" ? "" : window.location;
  e = e ?? {};
  const n = wsurl(t, r.toString()), i = new websocket(n, e.websocket);
  return duplex(i, e);
}
function isElectron$1() {
  return !!(typeof window < "u" && typeof window.process == "object" && window.process.type === "renderer" || typeof process < "u" && typeof process.versions == "object" && process.versions.electron || typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Electron") >= 0);
}
var isElectron_1 = isElectron$1;
const isEnvWithDom = typeof window == "object" && typeof document == "object" && document.nodeType === 9, isElectron = isElectron_1(), isBrowser = isEnvWithDom && !isElectron, isElectronMain = isElectron && !isEnvWithDom, isElectronRenderer = isElectron && isEnvWithDom, isNode$2 = typeof globalThis.process < "u" && typeof globalThis.process.release < "u" && globalThis.process.release.name === "node" && !isElectron, isWebWorker = typeof importScripts == "function" && typeof self$1 < "u" && typeof WorkerGlobalScope < "u" && self$1 instanceof WorkerGlobalScope;
typeof globalThis.process < "u" && typeof globalThis.process.env < "u" && globalThis.process.env["NODE" + (() => "_")() + "ENV"];
const isReactNative = typeof navigator < "u" && navigator.product === "ReactNative", DNS4 = base$1("dns4"), DNS6 = base$1("dns6"), DNSADDR = base$1("dnsaddr"), DNS = or$1(base$1("dns"), DNSADDR, DNS4, DNS6), IP = or$1(base$1("ip4"), base$1("ip6")), TCP = or$1(and$1(IP, base$1("tcp")), and$1(DNS, base$1("tcp"))), _WebSockets = or$1(and$1(TCP, base$1("ws")), and$1(DNS, base$1("ws"))), WebSockets$1 = or$1(and$1(_WebSockets, base$1("p2p")), _WebSockets), _WebSocketsSecure = or$1(and$1(TCP, base$1("wss")), and$1(DNS, base$1("wss")), and$1(TCP, base$1("tls"), base$1("ws")), and$1(DNS, base$1("tls"), base$1("ws"))), WebSocketsSecure = or$1(and$1(_WebSocketsSecure, base$1("p2p")), _WebSocketsSecure);
function makeMatchesFunction(t) {
  function e(r) {
    let n;
    try {
      n = multiaddr$1(r);
    } catch {
      return !1;
    }
    const i = t(n.protoNames());
    return i === null ? !1 : i === !0 || i === !1 ? i : i.length === 0;
  }
  return e;
}
function and$1(...t) {
  function e(r) {
    if (r.length < t.length)
      return null;
    let n = r;
    return t.some((i) => (n = typeof i == "function" ? i().partialMatch(r) : i.partialMatch(r), Array.isArray(n) && (r = n), n === null)), n;
  }
  return {
    toString: function() {
      return "{ " + t.join(" ") + " }";
    },
    input: t,
    matches: makeMatchesFunction(e),
    partialMatch: e
  };
}
function or$1(...t) {
  function e(n) {
    let i = null;
    return t.some((o) => {
      const a = typeof o == "function" ? o().partialMatch(n) : o.partialMatch(n);
      return a != null ? (i = a, !0) : !1;
    }), i;
  }
  return {
    toString: function() {
      return "{ " + t.join(" ") + " }";
    },
    input: t,
    matches: makeMatchesFunction(e),
    partialMatch: e
  };
}
function base$1(t) {
  const e = t;
  function r(i) {
    let o;
    try {
      o = multiaddr$1(i);
    } catch {
      return !1;
    }
    const a = o.protoNames();
    return a.length === 1 && a[0] === e;
  }
  function n(i) {
    return i.length === 0 ? null : i[0] === e ? i.slice(1) : null;
  }
  return {
    toString: function() {
      return e;
    },
    matches: r,
    partialMatch: n
  };
}
const CODE_P2P = 421, CODE_CIRCUIT = 290, CLOSE_TIMEOUT = 500;
function all(t) {
  return t.filter((e) => {
    if (e.protoCodes().includes(CODE_CIRCUIT))
      return !1;
    const r = e.decapsulateCode(CODE_P2P);
    return WebSockets$1.matches(r) || WebSocketsSecure.matches(r);
  });
}
function wss(t) {
  return t.filter((e) => {
    if (e.protoCodes().includes(CODE_CIRCUIT))
      return !1;
    const r = e.decapsulateCode(CODE_P2P);
    return WebSocketsSecure.matches(r);
  });
}
const log$9 = logger$1("libp2p:ip-port-to-multiaddr"), Errors = {
  ERR_INVALID_IP_PARAMETER: "ERR_INVALID_IP_PARAMETER",
  ERR_INVALID_PORT_PARAMETER: "ERR_INVALID_PORT_PARAMETER",
  ERR_INVALID_IP: "ERR_INVALID_IP"
};
function ipPortToMultiaddr(t, e) {
  if (typeof t != "string")
    throw new CodeError$2(`invalid ip provided: ${t}`, Errors.ERR_INVALID_IP_PARAMETER);
  if (typeof e == "string" && (e = parseInt(e)), isNaN(e))
    throw new CodeError$2(`invalid port provided: ${e}`, Errors.ERR_INVALID_PORT_PARAMETER);
  if (isIPv4(t))
    return multiaddr$1(`/ip4/${t}/tcp/${e}`);
  if (isIPv6(t))
    return multiaddr$1(`/ip6/${t}/tcp/${e}`);
  const r = `invalid ip:port for creating a multiaddr: ${t}:${e}`;
  throw log$9.error(r), new CodeError$2(r, Errors.ERR_INVALID_IP);
}
class Server extends EventEmitter$4 {
  constructor(r, n) {
    super();
    $(this, "server");
    $(this, "wsServer");
    n = n ?? {}, this.server = r, this.wsServer = new websocketServer({
      server: r,
      perMessageDeflate: !1,
      verifyClient: n.verifyClient
    }), this.wsServer.on("connection", this.onWsServerConnection.bind(this));
  }
  async listen(r) {
    return new Promise((n, i) => {
      this.wsServer.once("error", (o) => {
        i(o);
      }), this.wsServer.once("listening", () => {
        n(this);
      }), this.server.listen(typeof r == "number" ? r : r.port);
    });
  }
  async close() {
    await new Promise((r, n) => {
      this.server.close((i) => {
        if (i != null) {
          n(i);
          return;
        }
        r();
      });
    });
  }
  address() {
    return this.server.address();
  }
  onWsServerConnection(r, n) {
    const i = this.wsServer.address();
    if (typeof i == "string") {
      this.emit("error", new Error("Cannot listen on unix sockets"));
      return;
    }
    if (n.socket.remoteAddress == null || n.socket.remotePort == null) {
      this.emit("error", new Error("Remote connection did not have address and/or port"));
      return;
    }
    const o = {
      ...duplex(r, {
        remoteAddress: n.socket.remoteAddress,
        remotePort: n.socket.remotePort
      }),
      localAddress: i.address,
      localPort: i.port
    };
    this.emit("connection", o, n);
  }
}
function createServer(t) {
  t = t ?? {};
  const e = t.server ?? (t.key != null && t.cert != null ? require$$1$2.createServer(t) : require$$2.createServer()), r = new Server(e);
  t.onConnection != null && r.on("connection", t.onConnection);
  function n(i, o) {
    return i.on(o, (...a) => {
      r.emit(o, ...a);
    });
  }
  return n(e, "listening"), n(e, "request"), n(e, "close"), r;
}
const log$8 = logger$1("libp2p:websockets:socket");
function socketToMaConn(t, e, r) {
  r = r ?? {};
  const n = {
    async sink(i) {
      (r == null ? void 0 : r.signal) != null && (i = abortableSource(i, r.signal));
      try {
        await t.sink(i);
      } catch (o) {
        o.type !== "aborted" && log$8.error(o);
      }
    },
    source: r.signal != null ? abortableSource(t.source, r.signal) : t.source,
    remoteAddr: e,
    timeline: { open: Date.now() },
    async close(i = {}) {
      const o = Date.now();
      i.signal = i.signal ?? AbortSignal.timeout(CLOSE_TIMEOUT);
      const a = () => {
        const { host: c, port: l } = n.remoteAddr.toOptions();
        log$8("timeout closing stream to %s:%s after %dms, destroying it manually", c, l, Date.now() - o), this.abort(new CodeError$2("Socket close timeout", "ERR_SOCKET_CLOSE_TIMEOUT"));
      };
      i.signal.addEventListener("abort", a);
      try {
        await t.close();
      } catch (c) {
        this.abort(c);
      } finally {
        i.signal.removeEventListener("abort", a), n.timeline.close = Date.now();
      }
    },
    abort(i) {
      const { host: o, port: a } = n.remoteAddr.toOptions();
      log$8("timeout closing stream to %s:%s due to error", o, a, i), t.destroy(), n.timeline.close = Date.now();
    }
  };
  return t.socket.addEventListener("close", () => {
    n.timeline.close == null && (n.timeline.close = Date.now());
  }, { once: !0 }), n;
}
const log$7 = logger$1("libp2p:websockets:listener");
class WebSocketListener extends EventEmitter$2 {
  constructor(r) {
    super();
    $(this, "connections");
    $(this, "listeningMultiaddr");
    $(this, "server");
    this.connections = /* @__PURE__ */ new Set();
    const n = this;
    this.server = createServer({
      ...r,
      onConnection: (i) => {
        const o = socketToMaConn(i, ipPortToMultiaddr(i.remoteAddress ?? "", i.remotePort ?? 0));
        log$7("new inbound connection %s", o.remoteAddr), this.connections.add(i), i.socket.on("close", function() {
          n.connections.delete(i);
        });
        try {
          r.upgrader.upgradeInbound(o).then((a) => {
            log$7("inbound connection %s upgraded", o.remoteAddr), (r == null ? void 0 : r.handler) != null && (r == null || r.handler(a)), n.dispatchEvent(new CustomEvent("connection", {
              detail: a
            }));
          }).catch(async (a) => {
            log$7.error("inbound connection failed to upgrade", a), await o.close().catch((c) => {
              log$7.error("inbound connection failed to close after upgrade failed", c);
            });
          });
        } catch (a) {
          log$7.error("inbound connection failed to upgrade", a), o.close().catch((c) => {
            log$7.error("inbound connection failed to close after upgrade failed", c);
          });
        }
      }
    }), this.server.on("listening", () => {
      this.dispatchEvent(new CustomEvent("listening"));
    }), this.server.on("error", (i) => {
      this.dispatchEvent(new CustomEvent("error", {
        detail: i
      }));
    }), this.server.on("close", () => {
      this.dispatchEvent(new CustomEvent("close"));
    });
  }
  async close() {
    await Promise.all(Array.from(this.connections).map(async (r) => {
      await r.close();
    })), this.server.address() != null && await this.server.close();
  }
  async listen(r) {
    this.listeningMultiaddr = r, await this.server.listen(r.toOptions());
  }
  getAddrs() {
    const r = [], n = this.server.address();
    if (n == null)
      throw new Error("Listener is not ready yet");
    if (typeof n == "string")
      throw new Error("Wrong address type received - expected AddressInfo, got string - are you trying to listen on a unix socket?");
    if (this.listeningMultiaddr == null)
      throw new Error("Listener is not ready yet");
    const i = this.listeningMultiaddr.getPeerId(), o = this.listeningMultiaddr.protos();
    if (o.some((a) => a.code === getProtocol$1("ip4").code)) {
      const a = o.some((l) => l.code === getProtocol$1("ws").code) ? "/ws" : "/wss";
      let c = this.listeningMultiaddr.decapsulate("tcp");
      if (c = c.encapsulate(`/tcp/${n.port}${a}`), i != null && (c = c.encapsulate(`/p2p/${i}`)), c.toString().includes("0.0.0.0")) {
        const l = require$$0.networkInterfaces();
        Object.values(l).forEach((u) => {
          u != null && u.forEach((f) => {
            f.family === "IPv4" && r.push(multiaddr$1(c.toString().replace("0.0.0.0", f.address)));
          });
        });
      } else
        r.push(c);
    }
    return r;
  }
}
function createListener(t) {
  return new WebSocketListener(t);
}
const log$6 = logger$1("libp2p:websockets");
var ln, fn;
class WebSockets {
  constructor(e) {
    $(this, "init");
    $(this, ln, "@libp2p/websockets");
    $(this, fn, !0);
    this.init = e;
  }
  async dial(e, r) {
    log$6("dialing %s", e), r = r ?? {};
    const n = await this._connect(e, r), i = socketToMaConn(n, e);
    log$6("new outbound connection %s", i.remoteAddr);
    const o = await r.upgrader.upgradeOutbound(i);
    return log$6("outbound connection %s upgraded", i.remoteAddr), o;
  }
  async _connect(e, r) {
    var l, u;
    if (((l = r == null ? void 0 : r.signal) == null ? void 0 : l.aborted) === !0)
      throw new AbortError$6();
    const n = e.toOptions();
    log$6("dialing %s:%s", n.host, n.port);
    const i = pDefer(), o = connect$2(multiaddrToUri(e), this.init);
    if (o.socket.addEventListener("error", () => {
      const f = new CodeError$2(`Could not connect to ${e.toString()}`, "ERR_CONNECTION_FAILED");
      log$6.error("connection error:", f), i.reject(f);
    }), r.signal == null)
      return await Promise.race([o.connected(), i.promise]), log$6("connected %s", e), o;
    let a;
    const c = new Promise((f, d) => {
      var p, g;
      if (a = () => {
        d(new AbortError$6()), o.close().catch((h) => {
          log$6.error("error closing raw socket", h);
        });
      }, ((p = r == null ? void 0 : r.signal) == null ? void 0 : p.aborted) === !0) {
        a();
        return;
      }
      (g = r == null ? void 0 : r.signal) == null || g.addEventListener("abort", a);
    });
    try {
      await Promise.race([c, i.promise, o.connected()]);
    } finally {
      a != null && ((u = r == null ? void 0 : r.signal) == null || u.removeEventListener("abort", a));
    }
    return log$6("connected %s", e), o;
  }
  /**
   * Creates a Websockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(e) {
    return createListener({ ...this.init, ...e });
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.
   * By default, in a browser environment only DNS+WSS multiaddr is accepted,
   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
   */
  filter(e) {
    var r, n;
    return e = Array.isArray(e) ? e : [e], ((r = this.init) == null ? void 0 : r.filter) != null ? (n = this.init) == null ? void 0 : n.filter(e) : isBrowser || isWebWorker ? wss(e) : all(e);
  }
}
ln = Symbol.toStringTag, fn = symbol$2;
function webSockets(t = {}) {
  return () => new WebSockets(t);
}
const isV4 = isIPv4, isV6 = isIPv6, toBytes = function(t) {
  let e = 0;
  if (t = t.toString().trim(), isV4(t)) {
    const r = new Uint8Array(e + 4);
    return t.split(/\./g).forEach((n) => {
      r[e++] = parseInt(n, 10) & 255;
    }), r;
  }
  if (isV6(t)) {
    const r = t.split(":", 8);
    let n;
    for (n = 0; n < r.length; n++) {
      const o = isV4(r[n]);
      let a;
      o && (a = toBytes(r[n]), r[n] = toString$2(a.slice(0, 2), "base16")), a != null && ++n < 8 && r.splice(n, 0, toString$2(a.slice(2, 4), "base16"));
    }
    if (r[0] === "")
      for (; r.length < 8; )
        r.unshift("0");
    else if (r[r.length - 1] === "")
      for (; r.length < 8; )
        r.push("0");
    else if (r.length < 8) {
      for (n = 0; n < r.length && r[n] !== ""; n++)
        ;
      const o = [n, 1];
      for (n = 9 - r.length; n > 0; n--)
        o.push("0");
      r.splice.apply(r, o);
    }
    const i = new Uint8Array(e + 16);
    for (n = 0; n < r.length; n++) {
      const o = parseInt(r[n], 16);
      i[e++] = o >> 8 & 255, i[e++] = o & 255;
    }
    return i;
  }
  throw new Error("invalid ip address");
}, toString = function(t, e = 0, r) {
  e = ~~e, r = r ?? t.length - e;
  const n = new DataView(t.buffer);
  if (r === 4) {
    const i = [];
    for (let o = 0; o < r; o++)
      i.push(t[e + o]);
    return i.join(".");
  }
  if (r === 16) {
    const i = [];
    for (let o = 0; o < r; o += 2)
      i.push(n.getUint16(e + o).toString(16));
    return i.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
}, V = -1, names = {}, codes = {}, table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V, "dns", !0],
  [54, V, "dns4", !0],
  [55, V, "dns6", !0],
  [56, V, "dnsaddr", !0],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", !1, !0],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V, "memory"]
];
table.forEach((t) => {
  const e = createProtocol(...t);
  codes[e.code] = e, names[e.name] = e;
});
function createProtocol(t, e, r, n, i) {
  return {
    code: t,
    size: e,
    name: r,
    resolvable: Boolean(n),
    path: Boolean(i)
  };
}
function getProtocol(t) {
  if (typeof t == "number") {
    if (codes[t] != null)
      return codes[t];
    throw new Error(`no protocol with code: ${t}`);
  } else if (typeof t == "string") {
    if (names[t] != null)
      return names[t];
    throw new Error(`no protocol with name: ${t}`);
  }
  throw new Error(`invalid protocol id type: ${typeof t}`);
}
var encode_1 = encode$1, MSB$1 = 128, REST$1 = 127, MSBALL = ~REST$1, INT = Math.pow(2, 31);
function encode$1(t, e, r) {
  if (Number.MAX_SAFE_INTEGER && t > Number.MAX_SAFE_INTEGER)
    throw encode$1.bytes = 0, new RangeError("Could not encode varint");
  e = e || [], r = r || 0;
  for (var n = r; t >= INT; )
    e[r++] = t & 255 | MSB$1, t /= 128;
  for (; t & MSBALL; )
    e[r++] = t & 255 | MSB$1, t >>>= 7;
  return e[r] = t | 0, encode$1.bytes = r - n + 1, e;
}
var decode$1 = read, MSB = 128, REST = 127;
function read(t, n) {
  var r = 0, n = n || 0, i = 0, o = n, a, c = t.length;
  do {
    if (o >= c || i > 49)
      throw read.bytes = 0, new RangeError("Could not decode varint");
    a = t[o++], r += i < 28 ? (a & REST) << i : (a & REST) * Math.pow(2, i), i += 7;
  } while (a >= MSB);
  return read.bytes = o - n, r;
}
var N1 = Math.pow(2, 7), N2 = Math.pow(2, 14), N3 = Math.pow(2, 21), N4 = Math.pow(2, 28), N5 = Math.pow(2, 35), N6 = Math.pow(2, 42), N7 = Math.pow(2, 49), N8 = Math.pow(2, 56), N9 = Math.pow(2, 63), length = function(t) {
  return t < N1 ? 1 : t < N2 ? 2 : t < N3 ? 3 : t < N4 ? 4 : t < N5 ? 5 : t < N6 ? 6 : t < N7 ? 7 : t < N8 ? 8 : t < N9 ? 9 : 10;
}, varint = {
  encode: encode_1,
  decode: decode$1,
  encodingLength: length
};
function convertToString(t, e) {
  switch (getProtocol(t).code) {
    case 4:
    case 41:
      return bytes2ip(e);
    case 42:
      return bytes2str(e);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(e).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return bytes2str(e);
    case 421:
      return bytes2mh(e);
    case 444:
      return bytes2onion(e);
    case 445:
      return bytes2onion(e);
    case 466:
      return bytes2mb(e);
    default:
      return toString$2(e, "base16");
  }
}
function convertToBytes(t, e) {
  switch (getProtocol(t).code) {
    case 4:
      return ip2bytes(e);
    case 41:
      return ip2bytes(e);
    case 42:
      return str2bytes(e);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(e, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return str2bytes(e);
    case 421:
      return mh2bytes(e);
    case 444:
      return onion2bytes(e);
    case 445:
      return onion32bytes(e);
    case 466:
      return mb2bytes(e);
    default:
      return fromString$1(e, "base16");
  }
}
const decoders = Object.values(bases).map((t) => t.decoder), anybaseDecoder = function() {
  let t = decoders[0].or(decoders[1]);
  return decoders.slice(2).forEach((e) => t = t.or(e)), t;
}();
function ip2bytes(t) {
  if (!isIP(t))
    throw new Error("invalid ip address");
  return toBytes(t);
}
function bytes2ip(t) {
  const e = toString(t, 0, t.length);
  if (e == null)
    throw new Error("ipBuff is required");
  if (!isIP(e))
    throw new Error("invalid ip address");
  return e;
}
function port2bytes(t) {
  const e = new ArrayBuffer(2);
  return new DataView(e).setUint16(0, t), new Uint8Array(e);
}
function bytes2port(t) {
  return new DataView(t.buffer).getUint16(t.byteOffset);
}
function str2bytes(t) {
  const e = fromString$1(t), r = Uint8Array.from(varint.encode(e.length));
  return concat$7([r, e], r.length + e.length);
}
function bytes2str(t) {
  const e = varint.decode(t);
  if (t = t.slice(varint.decode.bytes), t.length !== e)
    throw new Error("inconsistent lengths");
  return toString$2(t);
}
function mh2bytes(t) {
  let e;
  t[0] === "Q" || t[0] === "1" ? e = decode$5(base58btc.decode(`z${t}`)).bytes : e = CID.parse(t).multihash.bytes;
  const r = Uint8Array.from(varint.encode(e.length));
  return concat$7([r, e], r.length + e.length);
}
function mb2bytes(t) {
  const e = anybaseDecoder.decode(t), r = Uint8Array.from(varint.encode(e.length));
  return concat$7([r, e], r.length + e.length);
}
function bytes2mb(t) {
  const e = varint.decode(t), r = t.slice(varint.decode.bytes);
  if (r.length !== e)
    throw new Error("inconsistent lengths");
  return "u" + toString$2(r, "base64url");
}
function bytes2mh(t) {
  const e = varint.decode(t), r = t.slice(varint.decode.bytes);
  if (r.length !== e)
    throw new Error("inconsistent lengths");
  return toString$2(r, "base58btc");
}
function onion2bytes(t) {
  const e = t.split(":");
  if (e.length !== 2)
    throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
  if (e[0].length !== 16)
    throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
  const r = base32.decode("b" + e[0]), n = parseInt(e[1], 10);
  if (n < 1 || n > 65536)
    throw new Error("Port number is not in range(1, 65536)");
  const i = port2bytes(n);
  return concat$7([r, i], r.length + i.length);
}
function onion32bytes(t) {
  const e = t.split(":");
  if (e.length !== 2)
    throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
  if (e[0].length !== 56)
    throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
  const r = base32.decode(`b${e[0]}`), n = parseInt(e[1], 10);
  if (n < 1 || n > 65536)
    throw new Error("Port number is not in range(1, 65536)");
  const i = port2bytes(n);
  return concat$7([r, i], r.length + i.length);
}
function bytes2onion(t) {
  const e = t.slice(0, t.length - 2), r = t.slice(t.length - 2), n = toString$2(e, "base32"), i = bytes2port(r);
  return `${n}:${i}`;
}
function stringToStringTuples(t) {
  const e = [], r = t.split("/").slice(1);
  if (r.length === 1 && r[0] === "")
    return [];
  for (let n = 0; n < r.length; n++) {
    const i = r[n], o = getProtocol(i);
    if (o.size === 0) {
      e.push([i]);
      continue;
    }
    if (n++, n >= r.length)
      throw ParseError("invalid address: " + t);
    if (o.path === !0) {
      e.push([
        i,
        // should we need to check each path part to see if it's a proto?
        // This would allow for other protocols to be added after a unix path,
        // however it would have issues if the path had a protocol name in the path
        cleanPath(r.slice(n).join("/"))
      ]);
      break;
    }
    e.push([i, r[n]]);
  }
  return e;
}
function stringTuplesToString(t) {
  const e = [];
  return t.map((r) => {
    const n = protoFromTuple(r);
    return e.push(n.name), r.length > 1 && r[1] != null && e.push(r[1]), null;
  }), cleanPath(e.join("/"));
}
function stringTuplesToTuples(t) {
  return t.map((e) => {
    Array.isArray(e) || (e = [e]);
    const r = protoFromTuple(e);
    return e.length > 1 ? [r.code, convertToBytes(r.code, e[1])] : [r.code];
  });
}
function tuplesToStringTuples(t) {
  return t.map((e) => {
    const r = protoFromTuple(e);
    return e[1] != null ? [r.code, convertToString(r.code, e[1])] : [r.code];
  });
}
function tuplesToBytes(t) {
  return fromBytes(concat$7(t.map((e) => {
    const r = protoFromTuple(e);
    let n = Uint8Array.from(varint.encode(r.code));
    return e.length > 1 && e[1] != null && (n = concat$7([n, e[1]])), n;
  })));
}
function sizeForAddr(t, e) {
  return t.size > 0 ? t.size / 8 : t.size === 0 ? 0 : varint.decode(e) + (varint.decode.bytes ?? 0);
}
function bytesToTuples(t) {
  const e = [];
  let r = 0;
  for (; r < t.length; ) {
    const n = varint.decode(t, r), i = varint.decode.bytes ?? 0, o = getProtocol(n), a = sizeForAddr(o, t.slice(r + i));
    if (a === 0) {
      e.push([n]), r += i;
      continue;
    }
    const c = t.slice(r + i, r + i + a);
    if (r += a + i, r > t.length)
      throw ParseError("Invalid address Uint8Array: " + toString$2(t, "base16"));
    e.push([n, c]);
  }
  return e;
}
function bytesToString(t) {
  const e = bytesToTuples(t), r = tuplesToStringTuples(e);
  return stringTuplesToString(r);
}
function stringToBytes(t) {
  t = cleanPath(t);
  const e = stringToStringTuples(t), r = stringTuplesToTuples(e);
  return tuplesToBytes(r);
}
function fromString(t) {
  return stringToBytes(t);
}
function fromBytes(t) {
  const e = validateBytes(t);
  if (e != null)
    throw e;
  return Uint8Array.from(t);
}
function validateBytes(t) {
  try {
    bytesToTuples(t);
  } catch (e) {
    return e;
  }
}
function cleanPath(t) {
  return "/" + t.trim().split("/").filter((e) => e).join("/");
}
function ParseError(t) {
  return new Error("Error parsing address: " + t);
}
function protoFromTuple(t) {
  return getProtocol(t[0]);
}
var __classPrivateFieldGet = globalThis && globalThis.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, __classPrivateFieldSet = globalThis && globalThis.__classPrivateFieldSet || function(t, e, r, n, i) {
  if (n === "m")
    throw new TypeError("Private method is not writable");
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? i.call(t, r) : i ? i.value = r : e.set(t, r), r;
}, _DefaultMultiaddr_string, _DefaultMultiaddr_tuples, _DefaultMultiaddr_stringTuples, _a;
const inspect = Symbol.for("nodejs.util.inspect.custom"), DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
], resolvers = /* @__PURE__ */ new Map(), symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
function isMultiaddr(t) {
  return Boolean(t == null ? void 0 : t[symbol]);
}
class DefaultMultiaddr {
  constructor(e) {
    if (_DefaultMultiaddr_string.set(this, void 0), _DefaultMultiaddr_tuples.set(this, void 0), _DefaultMultiaddr_stringTuples.set(this, void 0), this[_a] = !0, e == null && (e = ""), e instanceof Uint8Array)
      this.bytes = fromBytes(e);
    else if (typeof e == "string") {
      if (e.length > 0 && e.charAt(0) !== "/")
        throw new Error(`multiaddr "${e}" must start with a "/"`);
      this.bytes = fromString(e);
    } else if (isMultiaddr(e))
      this.bytes = fromBytes(e.bytes);
    else
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
  }
  toString() {
    return __classPrivateFieldGet(this, _DefaultMultiaddr_string, "f") == null && __classPrivateFieldSet(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f"), __classPrivateFieldGet(this, _DefaultMultiaddr_string, "f");
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let e, r, n, i, o = "";
    const a = getProtocol("tcp"), c = getProtocol("udp"), l = getProtocol("ip4"), u = getProtocol("ip6"), f = getProtocol("dns6"), d = getProtocol("ip6zone");
    for (const [g, h] of this.stringTuples())
      g === d.code && (o = `%${h ?? ""}`), DNS_CODES.includes(g) && (r = a.name, i = 443, n = `${h ?? ""}${o}`, e = g === f.code ? 6 : 4), (g === a.code || g === c.code) && (r = getProtocol(g).name, i = parseInt(h ?? "")), (g === l.code || g === u.code) && (r = getProtocol(g).name, n = `${h ?? ""}${o}`, e = g === u.code ? 6 : 4);
    if (e == null || r == null || n == null || i == null)
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    return {
      family: e,
      host: n,
      transport: r,
      port: i
    };
  }
  protos() {
    return this.protoCodes().map((e) => Object.assign({}, getProtocol(e)));
  }
  protoCodes() {
    const e = [], r = this.bytes;
    let n = 0;
    for (; n < r.length; ) {
      const i = varint.decode(r, n), o = varint.decode.bytes ?? 0, a = getProtocol(i), c = sizeForAddr(a, r.slice(n + o));
      n += c + o, e.push(i);
    }
    return e;
  }
  protoNames() {
    return this.protos().map((e) => e.name);
  }
  tuples() {
    return __classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f") == null && __classPrivateFieldSet(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f"), __classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f");
  }
  stringTuples() {
    return __classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f") == null && __classPrivateFieldSet(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f"), __classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f");
  }
  encapsulate(e) {
    return e = new DefaultMultiaddr(e), new DefaultMultiaddr(this.toString() + e.toString());
  }
  decapsulate(e) {
    const r = e.toString(), n = this.toString(), i = n.lastIndexOf(r);
    if (i < 0)
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);
    return new DefaultMultiaddr(n.slice(0, i));
  }
  decapsulateCode(e) {
    const r = this.tuples();
    for (let n = r.length - 1; n >= 0; n--)
      if (r[n][0] === e)
        return new DefaultMultiaddr(tuplesToBytes(r.slice(0, n)));
    return this;
  }
  getPeerId() {
    try {
      const r = this.stringTuples().filter((n) => n[0] === names.ipfs.code).pop();
      if ((r == null ? void 0 : r[1]) != null) {
        const n = r[1];
        return n[0] === "Q" || n[0] === "1" ? toString$2(base58btc.decode(`z${n}`), "base58btc") : toString$2(CID.parse(n).multihash.bytes, "base58btc");
      }
      return null;
    } catch {
      return null;
    }
  }
  getPath() {
    let e = null;
    try {
      e = this.stringTuples().filter((r) => getProtocol(r[0]).path === !0)[0][1], e == null && (e = null);
    } catch {
      e = null;
    }
    return e;
  }
  equals(e) {
    return equals$5(this.bytes, e.bytes);
  }
  async resolve(e) {
    const r = this.protos().find((o) => o.resolvable);
    if (r == null)
      return [this];
    const n = resolvers.get(r.name);
    if (n == null)
      throw errCode(new Error(`no available resolver for ${r.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    return (await n(this, e)).map((o) => new DefaultMultiaddr(o));
  }
  nodeAddress() {
    const e = this.toOptions();
    if (e.transport !== "tcp" && e.transport !== "udp")
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    return {
      family: e.family,
      address: e.host,
      port: e.port
    };
  }
  isThinWaistAddress(e) {
    const r = (e ?? this).protos();
    return !(r.length !== 2 || r[0].code !== 4 && r[0].code !== 41 || r[1].code !== 6 && r[1].code !== 273);
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(_DefaultMultiaddr_string = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_tuples = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_stringTuples = /* @__PURE__ */ new WeakMap(), _a = symbol, inspect)]() {
    return `Multiaddr(${bytesToString(this.bytes)})`;
  }
}
function multiaddr(t) {
  return new DefaultMultiaddr(t);
}
async function* map$2(t, e) {
  for await (const r of t)
    yield e(r);
}
function logger(t) {
  return {
    error: DebugLogger(`fluence:${t}:error`),
    trace: DebugLogger(`fluence:${t}:trace`),
    debug: DebugLogger(`fluence:${t}:debug`)
  };
}
function marineLogger(t) {
  const e = `fluence:marine:${t}`;
  return {
    warn: DebugLogger(`${e}:warn`),
    error: DebugLogger(`${e}:error`),
    debug: DebugLogger(`${e}:debug`),
    trace: DebugLogger(`${e}:trace`),
    info: DebugLogger(`${e}:info`)
  };
}
var cjs = {}, Observable$3 = {}, Subscriber = {}, isFunction$1 = {};
Object.defineProperty(isFunction$1, "__esModule", { value: !0 });
isFunction$1.isFunction = void 0;
function isFunction(t) {
  return typeof t == "function";
}
isFunction$1.isFunction = isFunction;
var Subscription$2 = {}, UnsubscriptionError = {}, createErrorClass$1 = {};
Object.defineProperty(createErrorClass$1, "__esModule", { value: !0 });
createErrorClass$1.createErrorClass = void 0;
function createErrorClass(t) {
  var e = function(n) {
    Error.call(n), n.stack = new Error().stack;
  }, r = t(e);
  return r.prototype = Object.create(Error.prototype), r.prototype.constructor = r, r;
}
createErrorClass$1.createErrorClass = createErrorClass;
Object.defineProperty(UnsubscriptionError, "__esModule", { value: !0 });
UnsubscriptionError.UnsubscriptionError = void 0;
var createErrorClass_1$5 = createErrorClass$1;
UnsubscriptionError.UnsubscriptionError = createErrorClass_1$5.createErrorClass(function(t) {
  return function(r) {
    t(this), this.message = r ? r.length + ` errors occurred during unsubscription:
` + r.map(function(n, i) {
      return i + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = r;
  };
});
var arrRemove$1 = {};
Object.defineProperty(arrRemove$1, "__esModule", { value: !0 });
arrRemove$1.arrRemove = void 0;
function arrRemove(t, e) {
  if (t) {
    var r = t.indexOf(e);
    0 <= r && t.splice(r, 1);
  }
}
arrRemove$1.arrRemove = arrRemove;
var __values$8 = commonjsGlobal && commonjsGlobal.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, __read$h = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$g = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(Subscription$2, "__esModule", { value: !0 });
Subscription$2.isSubscription = Subscription$2.EMPTY_SUBSCRIPTION = Subscription$2.Subscription = void 0;
var isFunction_1$p = isFunction$1, UnsubscriptionError_1 = UnsubscriptionError, arrRemove_1$7 = arrRemove$1, Subscription$1 = function() {
  function t(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return t.prototype.unsubscribe = function() {
    var e, r, n, i, o;
    if (!this.closed) {
      this.closed = !0;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var c = __values$8(a), l = c.next(); !l.done; l = c.next()) {
              var u = l.value;
              u.remove(this);
            }
          } catch (m) {
            e = { error: m };
          } finally {
            try {
              l && !l.done && (r = c.return) && r.call(c);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          a.remove(this);
      var f = this.initialTeardown;
      if (isFunction_1$p.isFunction(f))
        try {
          f();
        } catch (m) {
          o = m instanceof UnsubscriptionError_1.UnsubscriptionError ? m.errors : [m];
        }
      var d = this._finalizers;
      if (d) {
        this._finalizers = null;
        try {
          for (var p = __values$8(d), g = p.next(); !g.done; g = p.next()) {
            var h = g.value;
            try {
              execFinalizer(h);
            } catch (m) {
              o = o ?? [], m instanceof UnsubscriptionError_1.UnsubscriptionError ? o = __spreadArray$g(__spreadArray$g([], __read$h(o)), __read$h(m.errors)) : o.push(m);
            }
          }
        } catch (m) {
          n = { error: m };
        } finally {
          try {
            g && !g.done && (i = p.return) && i.call(p);
          } finally {
            if (n)
              throw n.error;
          }
        }
      }
      if (o)
        throw new UnsubscriptionError_1.UnsubscriptionError(o);
    }
  }, t.prototype.add = function(e) {
    var r;
    if (e && e !== this)
      if (this.closed)
        execFinalizer(e);
      else {
        if (e instanceof t) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (r = this._finalizers) !== null && r !== void 0 ? r : []).push(e);
      }
  }, t.prototype._hasParent = function(e) {
    var r = this._parentage;
    return r === e || Array.isArray(r) && r.includes(e);
  }, t.prototype._addParent = function(e) {
    var r = this._parentage;
    this._parentage = Array.isArray(r) ? (r.push(e), r) : r ? [r, e] : e;
  }, t.prototype._removeParent = function(e) {
    var r = this._parentage;
    r === e ? this._parentage = null : Array.isArray(r) && arrRemove_1$7.arrRemove(r, e);
  }, t.prototype.remove = function(e) {
    var r = this._finalizers;
    r && arrRemove_1$7.arrRemove(r, e), e instanceof t && e._removeParent(this);
  }, t.EMPTY = function() {
    var e = new t();
    return e.closed = !0, e;
  }(), t;
}();
Subscription$2.Subscription = Subscription$1;
Subscription$2.EMPTY_SUBSCRIPTION = Subscription$1.EMPTY;
function isSubscription(t) {
  return t instanceof Subscription$1 || t && "closed" in t && isFunction_1$p.isFunction(t.remove) && isFunction_1$p.isFunction(t.add) && isFunction_1$p.isFunction(t.unsubscribe);
}
Subscription$2.isSubscription = isSubscription;
function execFinalizer(t) {
  isFunction_1$p.isFunction(t) ? t() : t.unsubscribe();
}
var config = {};
Object.defineProperty(config, "__esModule", { value: !0 });
config.config = void 0;
config.config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
};
var reportUnhandledError$1 = {}, timeoutProvider = {};
(function(t) {
  var e = commonjsGlobal && commonjsGlobal.__read || function(n, i) {
    var o = typeof Symbol == "function" && n[Symbol.iterator];
    if (!o)
      return n;
    var a = o.call(n), c, l = [], u;
    try {
      for (; (i === void 0 || i-- > 0) && !(c = a.next()).done; )
        l.push(c.value);
    } catch (f) {
      u = { error: f };
    } finally {
      try {
        c && !c.done && (o = a.return) && o.call(a);
      } finally {
        if (u)
          throw u.error;
      }
    }
    return l;
  }, r = commonjsGlobal && commonjsGlobal.__spreadArray || function(n, i) {
    for (var o = 0, a = i.length, c = n.length; o < a; o++, c++)
      n[c] = i[o];
    return n;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.timeoutProvider = void 0, t.timeoutProvider = {
    setTimeout: function(n, i) {
      for (var o = [], a = 2; a < arguments.length; a++)
        o[a - 2] = arguments[a];
      var c = t.timeoutProvider.delegate;
      return c != null && c.setTimeout ? c.setTimeout.apply(c, r([n, i], e(o))) : setTimeout.apply(void 0, r([n, i], e(o)));
    },
    clearTimeout: function(n) {
      var i = t.timeoutProvider.delegate;
      return ((i == null ? void 0 : i.clearTimeout) || clearTimeout)(n);
    },
    delegate: void 0
  };
})(timeoutProvider);
Object.defineProperty(reportUnhandledError$1, "__esModule", { value: !0 });
reportUnhandledError$1.reportUnhandledError = void 0;
var config_1$2 = config, timeoutProvider_1 = timeoutProvider;
function reportUnhandledError(t) {
  timeoutProvider_1.timeoutProvider.setTimeout(function() {
    var e = config_1$2.config.onUnhandledError;
    if (e)
      e(t);
    else
      throw t;
  });
}
reportUnhandledError$1.reportUnhandledError = reportUnhandledError;
var noop$1 = {};
Object.defineProperty(noop$1, "__esModule", { value: !0 });
noop$1.noop = void 0;
function noop() {
}
noop$1.noop = noop;
var NotificationFactories = {};
Object.defineProperty(NotificationFactories, "__esModule", { value: !0 });
NotificationFactories.createNotification = NotificationFactories.nextNotification = NotificationFactories.errorNotification = NotificationFactories.COMPLETE_NOTIFICATION = void 0;
NotificationFactories.COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(t) {
  return createNotification("E", void 0, t);
}
NotificationFactories.errorNotification = errorNotification;
function nextNotification(t) {
  return createNotification("N", t, void 0);
}
NotificationFactories.nextNotification = nextNotification;
function createNotification(t, e, r) {
  return {
    kind: t,
    value: e,
    error: r
  };
}
NotificationFactories.createNotification = createNotification;
var errorContext$1 = {};
Object.defineProperty(errorContext$1, "__esModule", { value: !0 });
errorContext$1.captureError = errorContext$1.errorContext = void 0;
var config_1$1 = config, context = null;
function errorContext(t) {
  if (config_1$1.config.useDeprecatedSynchronousErrorHandling) {
    var e = !context;
    if (e && (context = { errorThrown: !1, error: null }), t(), e) {
      var r = context, n = r.errorThrown, i = r.error;
      if (context = null, n)
        throw i;
    }
  } else
    t();
}
errorContext$1.errorContext = errorContext;
function captureError(t) {
  config_1$1.config.useDeprecatedSynchronousErrorHandling && context && (context.errorThrown = !0, context.error = t);
}
errorContext$1.captureError = captureError;
(function(t) {
  var e = commonjsGlobal && commonjsGlobal.__extends || function() {
    var v = function(_, E) {
      return v = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(w, S) {
        w.__proto__ = S;
      } || function(w, S) {
        for (var x in S)
          Object.prototype.hasOwnProperty.call(S, x) && (w[x] = S[x]);
      }, v(_, E);
    };
    return function(_, E) {
      if (typeof E != "function" && E !== null)
        throw new TypeError("Class extends value " + String(E) + " is not a constructor or null");
      v(_, E);
      function w() {
        this.constructor = _;
      }
      _.prototype = E === null ? Object.create(E) : (w.prototype = E.prototype, new w());
    };
  }();
  Object.defineProperty(t, "__esModule", { value: !0 }), t.EMPTY_OBSERVER = t.SafeSubscriber = t.Subscriber = void 0;
  var r = isFunction$1, n = Subscription$2, i = config, o = reportUnhandledError$1, a = noop$1, c = NotificationFactories, l = timeoutProvider, u = errorContext$1, f = function(v) {
    e(_, v);
    function _(E) {
      var w = v.call(this) || this;
      return w.isStopped = !1, E ? (w.destination = E, n.isSubscription(E) && E.add(w)) : w.destination = t.EMPTY_OBSERVER, w;
    }
    return _.create = function(E, w, S) {
      return new h(E, w, S);
    }, _.prototype.next = function(E) {
      this.isStopped ? b(c.nextNotification(E), this) : this._next(E);
    }, _.prototype.error = function(E) {
      this.isStopped ? b(c.errorNotification(E), this) : (this.isStopped = !0, this._error(E));
    }, _.prototype.complete = function() {
      this.isStopped ? b(c.COMPLETE_NOTIFICATION, this) : (this.isStopped = !0, this._complete());
    }, _.prototype.unsubscribe = function() {
      this.closed || (this.isStopped = !0, v.prototype.unsubscribe.call(this), this.destination = null);
    }, _.prototype._next = function(E) {
      this.destination.next(E);
    }, _.prototype._error = function(E) {
      try {
        this.destination.error(E);
      } finally {
        this.unsubscribe();
      }
    }, _.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    }, _;
  }(n.Subscription);
  t.Subscriber = f;
  var d = Function.prototype.bind;
  function p(v, _) {
    return d.call(v, _);
  }
  var g = function() {
    function v(_) {
      this.partialObserver = _;
    }
    return v.prototype.next = function(_) {
      var E = this.partialObserver;
      if (E.next)
        try {
          E.next(_);
        } catch (w) {
          m(w);
        }
    }, v.prototype.error = function(_) {
      var E = this.partialObserver;
      if (E.error)
        try {
          E.error(_);
        } catch (w) {
          m(w);
        }
      else
        m(_);
    }, v.prototype.complete = function() {
      var _ = this.partialObserver;
      if (_.complete)
        try {
          _.complete();
        } catch (E) {
          m(E);
        }
    }, v;
  }(), h = function(v) {
    e(_, v);
    function _(E, w, S) {
      var x = v.call(this) || this, I;
      if (r.isFunction(E) || !E)
        I = {
          next: E ?? void 0,
          error: w ?? void 0,
          complete: S ?? void 0
        };
      else {
        var C;
        x && i.config.useDeprecatedNextContext ? (C = Object.create(E), C.unsubscribe = function() {
          return x.unsubscribe();
        }, I = {
          next: E.next && p(E.next, C),
          error: E.error && p(E.error, C),
          complete: E.complete && p(E.complete, C)
        }) : I = E;
      }
      return x.destination = new g(I), x;
    }
    return _;
  }(f);
  t.SafeSubscriber = h;
  function m(v) {
    i.config.useDeprecatedSynchronousErrorHandling ? u.captureError(v) : o.reportUnhandledError(v);
  }
  function y(v) {
    throw v;
  }
  function b(v, _) {
    var E = i.config.onStoppedNotification;
    E && l.timeoutProvider.setTimeout(function() {
      return E(v, _);
    });
  }
  t.EMPTY_OBSERVER = {
    closed: !0,
    next: a.noop,
    error: y,
    complete: a.noop
  };
})(Subscriber);
var observable = {};
Object.defineProperty(observable, "__esModule", { value: !0 });
observable.observable = void 0;
observable.observable = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
var pipe$1 = {}, identity$1 = {};
Object.defineProperty(identity$1, "__esModule", { value: !0 });
identity$1.identity = void 0;
function identity(t) {
  return t;
}
identity$1.identity = identity;
Object.defineProperty(pipe$1, "__esModule", { value: !0 });
pipe$1.pipeFromArray = pipe$1.pipe = void 0;
var identity_1$d = identity$1;
function pipe() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return pipeFromArray(t);
}
pipe$1.pipe = pipe;
function pipeFromArray(t) {
  return t.length === 0 ? identity_1$d.identity : t.length === 1 ? t[0] : function(r) {
    return t.reduce(function(n, i) {
      return i(n);
    }, r);
  };
}
pipe$1.pipeFromArray = pipeFromArray;
Object.defineProperty(Observable$3, "__esModule", { value: !0 });
Observable$3.Observable = void 0;
var Subscriber_1$3 = Subscriber, Subscription_1$9 = Subscription$2, observable_1$2 = observable, pipe_1$2 = pipe$1, config_1 = config, isFunction_1$o = isFunction$1, errorContext_1$1 = errorContext$1, Observable$2 = function() {
  function t(e) {
    e && (this._subscribe = e);
  }
  return t.prototype.lift = function(e) {
    var r = new t();
    return r.source = this, r.operator = e, r;
  }, t.prototype.subscribe = function(e, r, n) {
    var i = this, o = isSubscriber(e) ? e : new Subscriber_1$3.SafeSubscriber(e, r, n);
    return errorContext_1$1.errorContext(function() {
      var a = i, c = a.operator, l = a.source;
      o.add(c ? c.call(o, l) : l ? i._subscribe(o) : i._trySubscribe(o));
    }), o;
  }, t.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (r) {
      e.error(r);
    }
  }, t.prototype.forEach = function(e, r) {
    var n = this;
    return r = getPromiseCtor(r), new r(function(i, o) {
      var a = new Subscriber_1$3.SafeSubscriber({
        next: function(c) {
          try {
            e(c);
          } catch (l) {
            o(l), a.unsubscribe();
          }
        },
        error: o,
        complete: i
      });
      n.subscribe(a);
    });
  }, t.prototype._subscribe = function(e) {
    var r;
    return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(e);
  }, t.prototype[observable_1$2.observable] = function() {
    return this;
  }, t.prototype.pipe = function() {
    for (var e = [], r = 0; r < arguments.length; r++)
      e[r] = arguments[r];
    return pipe_1$2.pipeFromArray(e)(this);
  }, t.prototype.toPromise = function(e) {
    var r = this;
    return e = getPromiseCtor(e), new e(function(n, i) {
      var o;
      r.subscribe(function(a) {
        return o = a;
      }, function(a) {
        return i(a);
      }, function() {
        return n(o);
      });
    });
  }, t.create = function(e) {
    return new t(e);
  }, t;
}();
Observable$3.Observable = Observable$2;
function getPromiseCtor(t) {
  var e;
  return (e = t ?? config_1.config.Promise) !== null && e !== void 0 ? e : Promise;
}
function isObserver(t) {
  return t && isFunction_1$o.isFunction(t.next) && isFunction_1$o.isFunction(t.error) && isFunction_1$o.isFunction(t.complete);
}
function isSubscriber(t) {
  return t && t instanceof Subscriber_1$3.Subscriber || isObserver(t) && Subscription_1$9.isSubscription(t);
}
var ConnectableObservable$1 = {}, refCount$1 = {}, lift = {};
Object.defineProperty(lift, "__esModule", { value: !0 });
lift.operate = lift.hasLift = void 0;
var isFunction_1$n = isFunction$1;
function hasLift(t) {
  return isFunction_1$n.isFunction(t == null ? void 0 : t.lift);
}
lift.hasLift = hasLift;
function operate(t) {
  return function(e) {
    if (hasLift(e))
      return e.lift(function(r) {
        try {
          return t(r, this);
        } catch (n) {
          this.error(n);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
lift.operate = operate;
var OperatorSubscriber$1 = {}, __extends$f = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(OperatorSubscriber$1, "__esModule", { value: !0 });
OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber$1.createOperatorSubscriber = void 0;
var Subscriber_1$2 = Subscriber;
function createOperatorSubscriber(t, e, r, n, i) {
  return new OperatorSubscriber(t, e, r, n, i);
}
OperatorSubscriber$1.createOperatorSubscriber = createOperatorSubscriber;
var OperatorSubscriber = function(t) {
  __extends$f(e, t);
  function e(r, n, i, o, a, c) {
    var l = t.call(this, r) || this;
    return l.onFinalize = a, l.shouldUnsubscribe = c, l._next = n ? function(u) {
      try {
        n(u);
      } catch (f) {
        r.error(f);
      }
    } : t.prototype._next, l._error = o ? function(u) {
      try {
        o(u);
      } catch (f) {
        r.error(f);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._error, l._complete = i ? function() {
      try {
        i();
      } catch (u) {
        r.error(u);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._complete, l;
  }
  return e.prototype.unsubscribe = function() {
    var r;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var n = this.closed;
      t.prototype.unsubscribe.call(this), !n && ((r = this.onFinalize) === null || r === void 0 || r.call(this));
    }
  }, e;
}(Subscriber_1$2.Subscriber);
OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber;
Object.defineProperty(refCount$1, "__esModule", { value: !0 });
refCount$1.refCount = void 0;
var lift_1$15 = lift, OperatorSubscriber_1$V = OperatorSubscriber$1;
function refCount() {
  return lift_1$15.operate(function(t, e) {
    var r = null;
    t._refCount++;
    var n = OperatorSubscriber_1$V.createOperatorSubscriber(e, void 0, void 0, void 0, function() {
      if (!t || t._refCount <= 0 || 0 < --t._refCount) {
        r = null;
        return;
      }
      var i = t._connection, o = r;
      r = null, i && (!o || i === o) && i.unsubscribe(), e.unsubscribe();
    });
    t.subscribe(n), n.closed || (r = t.connect());
  });
}
refCount$1.refCount = refCount;
var __extends$e = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(ConnectableObservable$1, "__esModule", { value: !0 });
ConnectableObservable$1.ConnectableObservable = void 0;
var Observable_1$m = Observable$3, Subscription_1$8 = Subscription$2, refCount_1 = refCount$1, OperatorSubscriber_1$U = OperatorSubscriber$1, lift_1$14 = lift, ConnectableObservable = function(t) {
  __extends$e(e, t);
  function e(r, n) {
    var i = t.call(this) || this;
    return i.source = r, i.subjectFactory = n, i._subject = null, i._refCount = 0, i._connection = null, lift_1$14.hasLift(r) && (i.lift = r.lift), i;
  }
  return e.prototype._subscribe = function(r) {
    return this.getSubject().subscribe(r);
  }, e.prototype.getSubject = function() {
    var r = this._subject;
    return (!r || r.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, e.prototype._teardown = function() {
    this._refCount = 0;
    var r = this._connection;
    this._subject = this._connection = null, r == null || r.unsubscribe();
  }, e.prototype.connect = function() {
    var r = this, n = this._connection;
    if (!n) {
      n = this._connection = new Subscription_1$8.Subscription();
      var i = this.getSubject();
      n.add(this.source.subscribe(OperatorSubscriber_1$U.createOperatorSubscriber(i, void 0, function() {
        r._teardown(), i.complete();
      }, function(o) {
        r._teardown(), i.error(o);
      }, function() {
        return r._teardown();
      }))), n.closed && (this._connection = null, n = Subscription_1$8.Subscription.EMPTY);
    }
    return n;
  }, e.prototype.refCount = function() {
    return refCount_1.refCount()(this);
  }, e;
}(Observable_1$m.Observable);
ConnectableObservable$1.ConnectableObservable = ConnectableObservable;
var animationFrames$1 = {}, performanceTimestampProvider = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.performanceTimestampProvider = void 0, t.performanceTimestampProvider = {
    now: function() {
      return (t.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: void 0
  };
})(performanceTimestampProvider);
var animationFrameProvider = {};
(function(t) {
  var e = commonjsGlobal && commonjsGlobal.__read || function(i, o) {
    var a = typeof Symbol == "function" && i[Symbol.iterator];
    if (!a)
      return i;
    var c = a.call(i), l, u = [], f;
    try {
      for (; (o === void 0 || o-- > 0) && !(l = c.next()).done; )
        u.push(l.value);
    } catch (d) {
      f = { error: d };
    } finally {
      try {
        l && !l.done && (a = c.return) && a.call(c);
      } finally {
        if (f)
          throw f.error;
      }
    }
    return u;
  }, r = commonjsGlobal && commonjsGlobal.__spreadArray || function(i, o) {
    for (var a = 0, c = o.length, l = i.length; a < c; a++, l++)
      i[l] = o[a];
    return i;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.animationFrameProvider = void 0;
  var n = Subscription$2;
  t.animationFrameProvider = {
    schedule: function(i) {
      var o = requestAnimationFrame, a = cancelAnimationFrame, c = t.animationFrameProvider.delegate;
      c && (o = c.requestAnimationFrame, a = c.cancelAnimationFrame);
      var l = o(function(u) {
        a = void 0, i(u);
      });
      return new n.Subscription(function() {
        return a == null ? void 0 : a(l);
      });
    },
    requestAnimationFrame: function() {
      for (var i = [], o = 0; o < arguments.length; o++)
        i[o] = arguments[o];
      var a = t.animationFrameProvider.delegate;
      return ((a == null ? void 0 : a.requestAnimationFrame) || requestAnimationFrame).apply(void 0, r([], e(i)));
    },
    cancelAnimationFrame: function() {
      for (var i = [], o = 0; o < arguments.length; o++)
        i[o] = arguments[o];
      var a = t.animationFrameProvider.delegate;
      return ((a == null ? void 0 : a.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, r([], e(i)));
    },
    delegate: void 0
  };
})(animationFrameProvider);
Object.defineProperty(animationFrames$1, "__esModule", { value: !0 });
animationFrames$1.animationFrames = void 0;
var Observable_1$l = Observable$3, Subscription_1$7 = Subscription$2, performanceTimestampProvider_1 = performanceTimestampProvider, animationFrameProvider_1$1 = animationFrameProvider;
function animationFrames(t) {
  return t ? animationFramesFactory(t) : DEFAULT_ANIMATION_FRAMES;
}
animationFrames$1.animationFrames = animationFrames;
function animationFramesFactory(t) {
  var e = animationFrameProvider_1$1.animationFrameProvider.schedule;
  return new Observable_1$l.Observable(function(r) {
    var n = new Subscription_1$7.Subscription(), i = t || performanceTimestampProvider_1.performanceTimestampProvider, o = i.now(), a = function(c) {
      var l = i.now();
      r.next({
        timestamp: t ? l : c,
        elapsed: l - o
      }), r.closed || n.add(e(a));
    };
    return n.add(e(a)), n;
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory(), Subject$2 = {}, ObjectUnsubscribedError = {};
Object.defineProperty(ObjectUnsubscribedError, "__esModule", { value: !0 });
ObjectUnsubscribedError.ObjectUnsubscribedError = void 0;
var createErrorClass_1$4 = createErrorClass$1;
ObjectUnsubscribedError.ObjectUnsubscribedError = createErrorClass_1$4.createErrorClass(function(t) {
  return function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
});
var __extends$d = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), __values$7 = commonjsGlobal && commonjsGlobal.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(Subject$2, "__esModule", { value: !0 });
Subject$2.AnonymousSubject = Subject$2.Subject = void 0;
var Observable_1$k = Observable$3, Subscription_1$6 = Subscription$2, ObjectUnsubscribedError_1 = ObjectUnsubscribedError, arrRemove_1$6 = arrRemove$1, errorContext_1 = errorContext$1, Subject$1 = function(t) {
  __extends$d(e, t);
  function e() {
    var r = t.call(this) || this;
    return r.closed = !1, r.currentObservers = null, r.observers = [], r.isStopped = !1, r.hasError = !1, r.thrownError = null, r;
  }
  return e.prototype.lift = function(r) {
    var n = new AnonymousSubject(this, this);
    return n.operator = r, n;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
  }, e.prototype.next = function(r) {
    var n = this;
    errorContext_1.errorContext(function() {
      var i, o;
      if (n._throwIfClosed(), !n.isStopped) {
        n.currentObservers || (n.currentObservers = Array.from(n.observers));
        try {
          for (var a = __values$7(n.currentObservers), c = a.next(); !c.done; c = a.next()) {
            var l = c.value;
            l.next(r);
          }
        } catch (u) {
          i = { error: u };
        } finally {
          try {
            c && !c.done && (o = a.return) && o.call(a);
          } finally {
            if (i)
              throw i.error;
          }
        }
      }
    });
  }, e.prototype.error = function(r) {
    var n = this;
    errorContext_1.errorContext(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.hasError = n.isStopped = !0, n.thrownError = r;
        for (var i = n.observers; i.length; )
          i.shift().error(r);
      }
    });
  }, e.prototype.complete = function() {
    var r = this;
    errorContext_1.errorContext(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.isStopped = !0;
        for (var n = r.observers; n.length; )
          n.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var r;
      return ((r = this.observers) === null || r === void 0 ? void 0 : r.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(r) {
    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, r);
  }, e.prototype._subscribe = function(r) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(r), this._innerSubscribe(r);
  }, e.prototype._innerSubscribe = function(r) {
    var n = this, i = this, o = i.hasError, a = i.isStopped, c = i.observers;
    return o || a ? Subscription_1$6.EMPTY_SUBSCRIPTION : (this.currentObservers = null, c.push(r), new Subscription_1$6.Subscription(function() {
      n.currentObservers = null, arrRemove_1$6.arrRemove(c, r);
    }));
  }, e.prototype._checkFinalizedStatuses = function(r) {
    var n = this, i = n.hasError, o = n.thrownError, a = n.isStopped;
    i ? r.error(o) : a && r.complete();
  }, e.prototype.asObservable = function() {
    var r = new Observable_1$k.Observable();
    return r.source = this, r;
  }, e.create = function(r, n) {
    return new AnonymousSubject(r, n);
  }, e;
}(Observable_1$k.Observable);
Subject$2.Subject = Subject$1;
var AnonymousSubject = function(t) {
  __extends$d(e, t);
  function e(r, n) {
    var i = t.call(this) || this;
    return i.destination = r, i.source = n, i;
  }
  return e.prototype.next = function(r) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || i === void 0 || i.call(n, r);
  }, e.prototype.error = function(r) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || i === void 0 || i.call(n, r);
  }, e.prototype.complete = function() {
    var r, n;
    (n = (r = this.destination) === null || r === void 0 ? void 0 : r.complete) === null || n === void 0 || n.call(r);
  }, e.prototype._subscribe = function(r) {
    var n, i;
    return (i = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(r)) !== null && i !== void 0 ? i : Subscription_1$6.EMPTY_SUBSCRIPTION;
  }, e;
}(Subject$1);
Subject$2.AnonymousSubject = AnonymousSubject;
var BehaviorSubject$1 = {}, __extends$c = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(BehaviorSubject$1, "__esModule", { value: !0 });
BehaviorSubject$1.BehaviorSubject = void 0;
var Subject_1$e = Subject$2, BehaviorSubject = function(t) {
  __extends$c(e, t);
  function e(r) {
    var n = t.call(this) || this;
    return n._value = r, n;
  }
  return Object.defineProperty(e.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._subscribe = function(r) {
    var n = t.prototype._subscribe.call(this, r);
    return !n.closed && r.next(this._value), n;
  }, e.prototype.getValue = function() {
    var r = this, n = r.hasError, i = r.thrownError, o = r._value;
    if (n)
      throw i;
    return this._throwIfClosed(), o;
  }, e.prototype.next = function(r) {
    t.prototype.next.call(this, this._value = r);
  }, e;
}(Subject_1$e.Subject);
BehaviorSubject$1.BehaviorSubject = BehaviorSubject;
var ReplaySubject$1 = {}, dateTimestampProvider = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.dateTimestampProvider = void 0, t.dateTimestampProvider = {
    now: function() {
      return (t.dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };
})(dateTimestampProvider);
var __extends$b = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(ReplaySubject$1, "__esModule", { value: !0 });
ReplaySubject$1.ReplaySubject = void 0;
var Subject_1$d = Subject$2, dateTimestampProvider_1$2 = dateTimestampProvider, ReplaySubject = function(t) {
  __extends$b(e, t);
  function e(r, n, i) {
    r === void 0 && (r = 1 / 0), n === void 0 && (n = 1 / 0), i === void 0 && (i = dateTimestampProvider_1$2.dateTimestampProvider);
    var o = t.call(this) || this;
    return o._bufferSize = r, o._windowTime = n, o._timestampProvider = i, o._buffer = [], o._infiniteTimeWindow = !0, o._infiniteTimeWindow = n === 1 / 0, o._bufferSize = Math.max(1, r), o._windowTime = Math.max(1, n), o;
  }
  return e.prototype.next = function(r) {
    var n = this, i = n.isStopped, o = n._buffer, a = n._infiniteTimeWindow, c = n._timestampProvider, l = n._windowTime;
    i || (o.push(r), !a && o.push(c.now() + l)), this._trimBuffer(), t.prototype.next.call(this, r);
  }, e.prototype._subscribe = function(r) {
    this._throwIfClosed(), this._trimBuffer();
    for (var n = this._innerSubscribe(r), i = this, o = i._infiniteTimeWindow, a = i._buffer, c = a.slice(), l = 0; l < c.length && !r.closed; l += o ? 1 : 2)
      r.next(c[l]);
    return this._checkFinalizedStatuses(r), n;
  }, e.prototype._trimBuffer = function() {
    var r = this, n = r._bufferSize, i = r._timestampProvider, o = r._buffer, a = r._infiniteTimeWindow, c = (a ? 1 : 2) * n;
    if (n < 1 / 0 && c < o.length && o.splice(0, o.length - c), !a) {
      for (var l = i.now(), u = 0, f = 1; f < o.length && o[f] <= l; f += 2)
        u = f;
      u && o.splice(0, u + 1);
    }
  }, e;
}(Subject_1$d.Subject);
ReplaySubject$1.ReplaySubject = ReplaySubject;
var AsyncSubject$1 = {}, __extends$a = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(AsyncSubject$1, "__esModule", { value: !0 });
AsyncSubject$1.AsyncSubject = void 0;
var Subject_1$c = Subject$2, AsyncSubject = function(t) {
  __extends$a(e, t);
  function e() {
    var r = t !== null && t.apply(this, arguments) || this;
    return r._value = null, r._hasValue = !1, r._isComplete = !1, r;
  }
  return e.prototype._checkFinalizedStatuses = function(r) {
    var n = this, i = n.hasError, o = n._hasValue, a = n._value, c = n.thrownError, l = n.isStopped, u = n._isComplete;
    i ? r.error(c) : (l || u) && (o && r.next(a), r.complete());
  }, e.prototype.next = function(r) {
    this.isStopped || (this._value = r, this._hasValue = !0);
  }, e.prototype.complete = function() {
    var r = this, n = r._hasValue, i = r._value, o = r._isComplete;
    o || (this._isComplete = !0, n && t.prototype.next.call(this, i), t.prototype.complete.call(this));
  }, e;
}(Subject_1$c.Subject);
AsyncSubject$1.AsyncSubject = AsyncSubject;
var asap = {}, AsapAction$1 = {}, AsyncAction$1 = {}, Action$1 = {}, __extends$9 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(Action$1, "__esModule", { value: !0 });
Action$1.Action = void 0;
var Subscription_1$5 = Subscription$2, Action = function(t) {
  __extends$9(e, t);
  function e(r, n) {
    return t.call(this) || this;
  }
  return e.prototype.schedule = function(r, n) {
    return this;
  }, e;
}(Subscription_1$5.Subscription);
Action$1.Action = Action;
var intervalProvider = {};
(function(t) {
  var e = commonjsGlobal && commonjsGlobal.__read || function(n, i) {
    var o = typeof Symbol == "function" && n[Symbol.iterator];
    if (!o)
      return n;
    var a = o.call(n), c, l = [], u;
    try {
      for (; (i === void 0 || i-- > 0) && !(c = a.next()).done; )
        l.push(c.value);
    } catch (f) {
      u = { error: f };
    } finally {
      try {
        c && !c.done && (o = a.return) && o.call(a);
      } finally {
        if (u)
          throw u.error;
      }
    }
    return l;
  }, r = commonjsGlobal && commonjsGlobal.__spreadArray || function(n, i) {
    for (var o = 0, a = i.length, c = n.length; o < a; o++, c++)
      n[c] = i[o];
    return n;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.intervalProvider = void 0, t.intervalProvider = {
    setInterval: function(n, i) {
      for (var o = [], a = 2; a < arguments.length; a++)
        o[a - 2] = arguments[a];
      var c = t.intervalProvider.delegate;
      return c != null && c.setInterval ? c.setInterval.apply(c, r([n, i], e(o))) : setInterval.apply(void 0, r([n, i], e(o)));
    },
    clearInterval: function(n) {
      var i = t.intervalProvider.delegate;
      return ((i == null ? void 0 : i.clearInterval) || clearInterval)(n);
    },
    delegate: void 0
  };
})(intervalProvider);
var __extends$8 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(AsyncAction$1, "__esModule", { value: !0 });
AsyncAction$1.AsyncAction = void 0;
var Action_1 = Action$1, intervalProvider_1 = intervalProvider, arrRemove_1$5 = arrRemove$1, AsyncAction = function(t) {
  __extends$8(e, t);
  function e(r, n) {
    var i = t.call(this, r, n) || this;
    return i.scheduler = r, i.work = n, i.pending = !1, i;
  }
  return e.prototype.schedule = function(r, n) {
    if (n === void 0 && (n = 0), this.closed)
      return this;
    this.state = r;
    var i = this.id, o = this.scheduler;
    return i != null && (this.id = this.recycleAsyncId(o, i, n)), this.pending = !0, this.delay = n, this.id = this.id || this.requestAsyncId(o, this.id, n), this;
  }, e.prototype.requestAsyncId = function(r, n, i) {
    return i === void 0 && (i = 0), intervalProvider_1.intervalProvider.setInterval(r.flush.bind(r, this), i);
  }, e.prototype.recycleAsyncId = function(r, n, i) {
    if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1)
      return n;
    intervalProvider_1.intervalProvider.clearInterval(n);
  }, e.prototype.execute = function(r, n) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var i = this._execute(r, n);
    if (i)
      return i;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(r, n) {
    var i = !1, o;
    try {
      this.work(r);
    } catch (a) {
      i = !0, o = a || new Error("Scheduled action threw falsy error");
    }
    if (i)
      return this.unsubscribe(), o;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var r = this, n = r.id, i = r.scheduler, o = i.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, arrRemove_1$5.arrRemove(o, this), n != null && (this.id = this.recycleAsyncId(i, n, null)), this.delay = null, t.prototype.unsubscribe.call(this);
    }
  }, e;
}(Action_1.Action);
AsyncAction$1.AsyncAction = AsyncAction;
var immediateProvider = {}, Immediate = {};
Object.defineProperty(Immediate, "__esModule", { value: !0 });
Immediate.TestTools = Immediate.Immediate = void 0;
var nextHandle = 1, resolved, activeHandles = {};
function findAndClearHandle(t) {
  return t in activeHandles ? (delete activeHandles[t], !0) : !1;
}
Immediate.Immediate = {
  setImmediate: function(t) {
    var e = nextHandle++;
    return activeHandles[e] = !0, resolved || (resolved = Promise.resolve()), resolved.then(function() {
      return findAndClearHandle(e) && t();
    }), e;
  },
  clearImmediate: function(t) {
    findAndClearHandle(t);
  }
};
Immediate.TestTools = {
  pending: function() {
    return Object.keys(activeHandles).length;
  }
};
(function(t) {
  var e = commonjsGlobal && commonjsGlobal.__read || function(a, c) {
    var l = typeof Symbol == "function" && a[Symbol.iterator];
    if (!l)
      return a;
    var u = l.call(a), f, d = [], p;
    try {
      for (; (c === void 0 || c-- > 0) && !(f = u.next()).done; )
        d.push(f.value);
    } catch (g) {
      p = { error: g };
    } finally {
      try {
        f && !f.done && (l = u.return) && l.call(u);
      } finally {
        if (p)
          throw p.error;
      }
    }
    return d;
  }, r = commonjsGlobal && commonjsGlobal.__spreadArray || function(a, c) {
    for (var l = 0, u = c.length, f = a.length; l < u; l++, f++)
      a[f] = c[l];
    return a;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.immediateProvider = void 0;
  var n = Immediate, i = n.Immediate.setImmediate, o = n.Immediate.clearImmediate;
  t.immediateProvider = {
    setImmediate: function() {
      for (var a = [], c = 0; c < arguments.length; c++)
        a[c] = arguments[c];
      var l = t.immediateProvider.delegate;
      return ((l == null ? void 0 : l.setImmediate) || i).apply(void 0, r([], e(a)));
    },
    clearImmediate: function(a) {
      var c = t.immediateProvider.delegate;
      return ((c == null ? void 0 : c.clearImmediate) || o)(a);
    },
    delegate: void 0
  };
})(immediateProvider);
var __extends$7 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(AsapAction$1, "__esModule", { value: !0 });
AsapAction$1.AsapAction = void 0;
var AsyncAction_1$3 = AsyncAction$1, immediateProvider_1 = immediateProvider, AsapAction = function(t) {
  __extends$7(e, t);
  function e(r, n) {
    var i = t.call(this, r, n) || this;
    return i.scheduler = r, i.work = n, i;
  }
  return e.prototype.requestAsyncId = function(r, n, i) {
    return i === void 0 && (i = 0), i !== null && i > 0 ? t.prototype.requestAsyncId.call(this, r, n, i) : (r.actions.push(this), r._scheduled || (r._scheduled = immediateProvider_1.immediateProvider.setImmediate(r.flush.bind(r, void 0))));
  }, e.prototype.recycleAsyncId = function(r, n, i) {
    if (i === void 0 && (i = 0), i != null && i > 0 || i == null && this.delay > 0)
      return t.prototype.recycleAsyncId.call(this, r, n, i);
    r.actions.some(function(o) {
      return o.id === n;
    }) || (immediateProvider_1.immediateProvider.clearImmediate(n), r._scheduled = void 0);
  }, e;
}(AsyncAction_1$3.AsyncAction);
AsapAction$1.AsapAction = AsapAction;
var AsapScheduler$1 = {}, AsyncScheduler$1 = {}, Scheduler$1 = {};
Object.defineProperty(Scheduler$1, "__esModule", { value: !0 });
Scheduler$1.Scheduler = void 0;
var dateTimestampProvider_1$1 = dateTimestampProvider, Scheduler = function() {
  function t(e, r) {
    r === void 0 && (r = t.now), this.schedulerActionCtor = e, this.now = r;
  }
  return t.prototype.schedule = function(e, r, n) {
    return r === void 0 && (r = 0), new this.schedulerActionCtor(this, e).schedule(n, r);
  }, t.now = dateTimestampProvider_1$1.dateTimestampProvider.now, t;
}();
Scheduler$1.Scheduler = Scheduler;
var __extends$6 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(AsyncScheduler$1, "__esModule", { value: !0 });
AsyncScheduler$1.AsyncScheduler = void 0;
var Scheduler_1 = Scheduler$1, AsyncScheduler = function(t) {
  __extends$6(e, t);
  function e(r, n) {
    n === void 0 && (n = Scheduler_1.Scheduler.now);
    var i = t.call(this, r, n) || this;
    return i.actions = [], i._active = !1, i._scheduled = void 0, i;
  }
  return e.prototype.flush = function(r) {
    var n = this.actions;
    if (this._active) {
      n.push(r);
      return;
    }
    var i;
    this._active = !0;
    do
      if (i = r.execute(r.state, r.delay))
        break;
    while (r = n.shift());
    if (this._active = !1, i) {
      for (; r = n.shift(); )
        r.unsubscribe();
      throw i;
    }
  }, e;
}(Scheduler_1.Scheduler);
AsyncScheduler$1.AsyncScheduler = AsyncScheduler;
var __extends$5 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(AsapScheduler$1, "__esModule", { value: !0 });
AsapScheduler$1.AsapScheduler = void 0;
var AsyncScheduler_1$3 = AsyncScheduler$1, AsapScheduler = function(t) {
  __extends$5(e, t);
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  return e.prototype.flush = function(r) {
    this._active = !0;
    var n = this._scheduled;
    this._scheduled = void 0;
    var i = this.actions, o;
    r = r || i.shift();
    do
      if (o = r.execute(r.state, r.delay))
        break;
    while ((r = i[0]) && r.id === n && i.shift());
    if (this._active = !1, o) {
      for (; (r = i[0]) && r.id === n && i.shift(); )
        r.unsubscribe();
      throw o;
    }
  }, e;
}(AsyncScheduler_1$3.AsyncScheduler);
AsapScheduler$1.AsapScheduler = AsapScheduler;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.asap = t.asapScheduler = void 0;
  var e = AsapAction$1, r = AsapScheduler$1;
  t.asapScheduler = new r.AsapScheduler(e.AsapAction), t.asap = t.asapScheduler;
})(asap);
var async = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.async = t.asyncScheduler = void 0;
  var e = AsyncAction$1, r = AsyncScheduler$1;
  t.asyncScheduler = new r.AsyncScheduler(e.AsyncAction), t.async = t.asyncScheduler;
})(async);
var queue = {}, QueueAction$1 = {}, __extends$4 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(QueueAction$1, "__esModule", { value: !0 });
QueueAction$1.QueueAction = void 0;
var AsyncAction_1$2 = AsyncAction$1, QueueAction = function(t) {
  __extends$4(e, t);
  function e(r, n) {
    var i = t.call(this, r, n) || this;
    return i.scheduler = r, i.work = n, i;
  }
  return e.prototype.schedule = function(r, n) {
    return n === void 0 && (n = 0), n > 0 ? t.prototype.schedule.call(this, r, n) : (this.delay = n, this.state = r, this.scheduler.flush(this), this);
  }, e.prototype.execute = function(r, n) {
    return n > 0 || this.closed ? t.prototype.execute.call(this, r, n) : this._execute(r, n);
  }, e.prototype.requestAsyncId = function(r, n, i) {
    return i === void 0 && (i = 0), i != null && i > 0 || i == null && this.delay > 0 ? t.prototype.requestAsyncId.call(this, r, n, i) : r.flush(this);
  }, e;
}(AsyncAction_1$2.AsyncAction);
QueueAction$1.QueueAction = QueueAction;
var QueueScheduler$1 = {}, __extends$3 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(QueueScheduler$1, "__esModule", { value: !0 });
QueueScheduler$1.QueueScheduler = void 0;
var AsyncScheduler_1$2 = AsyncScheduler$1, QueueScheduler = function(t) {
  __extends$3(e, t);
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  return e;
}(AsyncScheduler_1$2.AsyncScheduler);
QueueScheduler$1.QueueScheduler = QueueScheduler;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.queue = t.queueScheduler = void 0;
  var e = QueueAction$1, r = QueueScheduler$1;
  t.queueScheduler = new r.QueueScheduler(e.QueueAction), t.queue = t.queueScheduler;
})(queue);
var animationFrame = {}, AnimationFrameAction$1 = {}, __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(AnimationFrameAction$1, "__esModule", { value: !0 });
AnimationFrameAction$1.AnimationFrameAction = void 0;
var AsyncAction_1$1 = AsyncAction$1, animationFrameProvider_1 = animationFrameProvider, AnimationFrameAction = function(t) {
  __extends$2(e, t);
  function e(r, n) {
    var i = t.call(this, r, n) || this;
    return i.scheduler = r, i.work = n, i;
  }
  return e.prototype.requestAsyncId = function(r, n, i) {
    return i === void 0 && (i = 0), i !== null && i > 0 ? t.prototype.requestAsyncId.call(this, r, n, i) : (r.actions.push(this), r._scheduled || (r._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
      return r.flush(void 0);
    })));
  }, e.prototype.recycleAsyncId = function(r, n, i) {
    if (i === void 0 && (i = 0), i != null && i > 0 || i == null && this.delay > 0)
      return t.prototype.recycleAsyncId.call(this, r, n, i);
    r.actions.some(function(o) {
      return o.id === n;
    }) || (animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(n), r._scheduled = void 0);
  }, e;
}(AsyncAction_1$1.AsyncAction);
AnimationFrameAction$1.AnimationFrameAction = AnimationFrameAction;
var AnimationFrameScheduler$1 = {}, __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(AnimationFrameScheduler$1, "__esModule", { value: !0 });
AnimationFrameScheduler$1.AnimationFrameScheduler = void 0;
var AsyncScheduler_1$1 = AsyncScheduler$1, AnimationFrameScheduler = function(t) {
  __extends$1(e, t);
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  return e.prototype.flush = function(r) {
    this._active = !0;
    var n = this._scheduled;
    this._scheduled = void 0;
    var i = this.actions, o;
    r = r || i.shift();
    do
      if (o = r.execute(r.state, r.delay))
        break;
    while ((r = i[0]) && r.id === n && i.shift());
    if (this._active = !1, o) {
      for (; (r = i[0]) && r.id === n && i.shift(); )
        r.unsubscribe();
      throw o;
    }
  }, e;
}(AsyncScheduler_1$1.AsyncScheduler);
AnimationFrameScheduler$1.AnimationFrameScheduler = AnimationFrameScheduler;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.animationFrame = t.animationFrameScheduler = void 0;
  var e = AnimationFrameAction$1, r = AnimationFrameScheduler$1;
  t.animationFrameScheduler = new r.AnimationFrameScheduler(e.AnimationFrameAction), t.animationFrame = t.animationFrameScheduler;
})(animationFrame);
var VirtualTimeScheduler$1 = {}, __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
Object.defineProperty(VirtualTimeScheduler$1, "__esModule", { value: !0 });
VirtualTimeScheduler$1.VirtualAction = VirtualTimeScheduler$1.VirtualTimeScheduler = void 0;
var AsyncAction_1 = AsyncAction$1, Subscription_1$4 = Subscription$2, AsyncScheduler_1 = AsyncScheduler$1, VirtualTimeScheduler = function(t) {
  __extends(e, t);
  function e(r, n) {
    r === void 0 && (r = VirtualAction), n === void 0 && (n = 1 / 0);
    var i = t.call(this, r, function() {
      return i.frame;
    }) || this;
    return i.maxFrames = n, i.frame = 0, i.index = -1, i;
  }
  return e.prototype.flush = function() {
    for (var r = this, n = r.actions, i = r.maxFrames, o, a; (a = n[0]) && a.delay <= i && (n.shift(), this.frame = a.delay, !(o = a.execute(a.state, a.delay))); )
      ;
    if (o) {
      for (; a = n.shift(); )
        a.unsubscribe();
      throw o;
    }
  }, e.frameTimeFactor = 10, e;
}(AsyncScheduler_1.AsyncScheduler);
VirtualTimeScheduler$1.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = function(t) {
  __extends(e, t);
  function e(r, n, i) {
    i === void 0 && (i = r.index += 1);
    var o = t.call(this, r, n) || this;
    return o.scheduler = r, o.work = n, o.index = i, o.active = !0, o.index = r.index = i, o;
  }
  return e.prototype.schedule = function(r, n) {
    if (n === void 0 && (n = 0), Number.isFinite(n)) {
      if (!this.id)
        return t.prototype.schedule.call(this, r, n);
      this.active = !1;
      var i = new e(this.scheduler, this.work);
      return this.add(i), i.schedule(r, n);
    } else
      return Subscription_1$4.Subscription.EMPTY;
  }, e.prototype.requestAsyncId = function(r, n, i) {
    i === void 0 && (i = 0), this.delay = r.frame + i;
    var o = r.actions;
    return o.push(this), o.sort(e.sortActions), !0;
  }, e.prototype.recycleAsyncId = function(r, n, i) {
  }, e.prototype._execute = function(r, n) {
    if (this.active === !0)
      return t.prototype._execute.call(this, r, n);
  }, e.sortActions = function(r, n) {
    return r.delay === n.delay ? r.index === n.index ? 0 : r.index > n.index ? 1 : -1 : r.delay > n.delay ? 1 : -1;
  }, e;
}(AsyncAction_1.AsyncAction);
VirtualTimeScheduler$1.VirtualAction = VirtualAction;
var Notification = {}, empty = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.empty = t.EMPTY = void 0;
  var e = Observable$3;
  t.EMPTY = new e.Observable(function(i) {
    return i.complete();
  });
  function r(i) {
    return i ? n(i) : t.EMPTY;
  }
  t.empty = r;
  function n(i) {
    return new e.Observable(function(o) {
      return i.schedule(function() {
        return o.complete();
      });
    });
  }
})(empty);
var of$1 = {}, args = {}, isScheduler$1 = {};
Object.defineProperty(isScheduler$1, "__esModule", { value: !0 });
isScheduler$1.isScheduler = void 0;
var isFunction_1$m = isFunction$1;
function isScheduler(t) {
  return t && isFunction_1$m.isFunction(t.schedule);
}
isScheduler$1.isScheduler = isScheduler;
Object.defineProperty(args, "__esModule", { value: !0 });
args.popNumber = args.popScheduler = args.popResultSelector = void 0;
var isFunction_1$l = isFunction$1, isScheduler_1$3 = isScheduler$1;
function last$2(t) {
  return t[t.length - 1];
}
function popResultSelector(t) {
  return isFunction_1$l.isFunction(last$2(t)) ? t.pop() : void 0;
}
args.popResultSelector = popResultSelector;
function popScheduler(t) {
  return isScheduler_1$3.isScheduler(last$2(t)) ? t.pop() : void 0;
}
args.popScheduler = popScheduler;
function popNumber(t, e) {
  return typeof last$2(t) == "number" ? t.pop() : e;
}
args.popNumber = popNumber;
var from$1 = {}, scheduled$1 = {}, scheduleObservable$1 = {}, innerFrom$1 = {}, isArrayLike = {};
Object.defineProperty(isArrayLike, "__esModule", { value: !0 });
isArrayLike.isArrayLike = void 0;
isArrayLike.isArrayLike = function(t) {
  return t && typeof t.length == "number" && typeof t != "function";
};
var isPromise$1 = {};
Object.defineProperty(isPromise$1, "__esModule", { value: !0 });
isPromise$1.isPromise = void 0;
var isFunction_1$k = isFunction$1;
function isPromise(t) {
  return isFunction_1$k.isFunction(t == null ? void 0 : t.then);
}
isPromise$1.isPromise = isPromise;
var isInteropObservable$1 = {};
Object.defineProperty(isInteropObservable$1, "__esModule", { value: !0 });
isInteropObservable$1.isInteropObservable = void 0;
var observable_1$1 = observable, isFunction_1$j = isFunction$1;
function isInteropObservable(t) {
  return isFunction_1$j.isFunction(t[observable_1$1.observable]);
}
isInteropObservable$1.isInteropObservable = isInteropObservable;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: !0 });
isAsyncIterable$1.isAsyncIterable = void 0;
var isFunction_1$i = isFunction$1;
function isAsyncIterable(t) {
  return Symbol.asyncIterator && isFunction_1$i.isFunction(t == null ? void 0 : t[Symbol.asyncIterator]);
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var throwUnobservableError = {};
Object.defineProperty(throwUnobservableError, "__esModule", { value: !0 });
throwUnobservableError.createInvalidObservableTypeError = void 0;
function createInvalidObservableTypeError(t) {
  return new TypeError("You provided " + (t !== null && typeof t == "object" ? "an invalid object" : "'" + t + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
throwUnobservableError.createInvalidObservableTypeError = createInvalidObservableTypeError;
var isIterable$1 = {}, iterator = {};
Object.defineProperty(iterator, "__esModule", { value: !0 });
iterator.iterator = iterator.getSymbolIterator = void 0;
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
iterator.getSymbolIterator = getSymbolIterator;
iterator.iterator = getSymbolIterator();
Object.defineProperty(isIterable$1, "__esModule", { value: !0 });
isIterable$1.isIterable = void 0;
var iterator_1$1 = iterator, isFunction_1$h = isFunction$1;
function isIterable(t) {
  return isFunction_1$h.isFunction(t == null ? void 0 : t[iterator_1$1.iterator]);
}
isIterable$1.isIterable = isIterable;
var isReadableStreamLike$1 = {}, __generator$3 = commonjsGlobal && commonjsGlobal.__generator || function(t, e) {
  var r = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, n, i, o, a;
  return a = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function c(u) {
    return function(f) {
      return l([u, f]);
    };
  }
  function l(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done)
          return o;
        switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
          case 0:
          case 1:
            o = u;
            break;
          case 4:
            return r.label++, { value: u[1], done: !1 };
          case 5:
            r.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (o = r.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < o[1]) {
              r.label = o[1], o = u;
              break;
            }
            if (o && r.label < o[2]) {
              r.label = o[2], r.ops.push(u);
              break;
            }
            o[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = e.call(t, r);
      } catch (f) {
        u = [6, f], i = 0;
      } finally {
        n = o = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}, __await = commonjsGlobal && commonjsGlobal.__await || function(t) {
  return this instanceof __await ? (this.v = t, this) : new __await(t);
}, __asyncGenerator = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(t, e, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []), i, o = [];
  return i = {}, a("next"), a("throw"), a("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function a(p) {
    n[p] && (i[p] = function(g) {
      return new Promise(function(h, m) {
        o.push([p, g, h, m]) > 1 || c(p, g);
      });
    });
  }
  function c(p, g) {
    try {
      l(n[p](g));
    } catch (h) {
      d(o[0][3], h);
    }
  }
  function l(p) {
    p.value instanceof __await ? Promise.resolve(p.value.v).then(u, f) : d(o[0][2], p);
  }
  function u(p) {
    c("next", p);
  }
  function f(p) {
    c("throw", p);
  }
  function d(p, g) {
    p(g), o.shift(), o.length && c(o[0][0], o[0][1]);
  }
};
Object.defineProperty(isReadableStreamLike$1, "__esModule", { value: !0 });
isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = void 0;
var isFunction_1$g = isFunction$1;
function readableStreamLikeToAsyncGenerator(t) {
  return __asyncGenerator(this, arguments, function() {
    var r, n, i, o;
    return __generator$3(this, function(a) {
      switch (a.label) {
        case 0:
          r = t.getReader(), a.label = 1;
        case 1:
          a.trys.push([1, , 9, 10]), a.label = 2;
        case 2:
          return [4, __await(r.read())];
        case 3:
          return n = a.sent(), i = n.value, o = n.done, o ? [4, __await(void 0)] : [3, 5];
        case 4:
          return [2, a.sent()];
        case 5:
          return [4, __await(i)];
        case 6:
          return [4, a.sent()];
        case 7:
          return a.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return r.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
function isReadableStreamLike(t) {
  return isFunction_1$g.isFunction(t == null ? void 0 : t.getReader);
}
isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike;
var __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function(t, e, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(a) {
      a(o);
    });
  }
  return new (r || (r = Promise))(function(o, a) {
    function c(f) {
      try {
        u(n.next(f));
      } catch (d) {
        a(d);
      }
    }
    function l(f) {
      try {
        u(n.throw(f));
      } catch (d) {
        a(d);
      }
    }
    function u(f) {
      f.done ? o(f.value) : i(f.value).then(c, l);
    }
    u((n = n.apply(t, e || [])).next());
  });
}, __generator$2 = commonjsGlobal && commonjsGlobal.__generator || function(t, e) {
  var r = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, n, i, o, a;
  return a = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function c(u) {
    return function(f) {
      return l([u, f]);
    };
  }
  function l(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done)
          return o;
        switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
          case 0:
          case 1:
            o = u;
            break;
          case 4:
            return r.label++, { value: u[1], done: !1 };
          case 5:
            r.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (o = r.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < o[1]) {
              r.label = o[1], o = u;
              break;
            }
            if (o && r.label < o[2]) {
              r.label = o[2], r.ops.push(u);
              break;
            }
            o[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = e.call(t, r);
      } catch (f) {
        u = [6, f], i = 0;
      } finally {
        n = o = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}, __asyncValues = commonjsGlobal && commonjsGlobal.__asyncValues || function(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof __values$6 == "function" ? __values$6(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(o) {
    r[o] = t[o] && function(a) {
      return new Promise(function(c, l) {
        a = t[o](a), i(c, l, a.done, a.value);
      });
    };
  }
  function i(o, a, c, l) {
    Promise.resolve(l).then(function(u) {
      o({ value: u, done: c });
    }, a);
  }
}, __values$6 = commonjsGlobal && commonjsGlobal.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(innerFrom$1, "__esModule", { value: !0 });
innerFrom$1.fromReadableStreamLike = innerFrom$1.fromAsyncIterable = innerFrom$1.fromIterable = innerFrom$1.fromPromise = innerFrom$1.fromArrayLike = innerFrom$1.fromInteropObservable = innerFrom$1.innerFrom = void 0;
var isArrayLike_1$2 = isArrayLike, isPromise_1$1 = isPromise$1, Observable_1$j = Observable$3, isInteropObservable_1$1 = isInteropObservable$1, isAsyncIterable_1$1 = isAsyncIterable$1, throwUnobservableError_1$1 = throwUnobservableError, isIterable_1$1 = isIterable$1, isReadableStreamLike_1$2 = isReadableStreamLike$1, isFunction_1$f = isFunction$1, reportUnhandledError_1 = reportUnhandledError$1, observable_1 = observable;
function innerFrom(t) {
  if (t instanceof Observable_1$j.Observable)
    return t;
  if (t != null) {
    if (isInteropObservable_1$1.isInteropObservable(t))
      return fromInteropObservable(t);
    if (isArrayLike_1$2.isArrayLike(t))
      return fromArrayLike(t);
    if (isPromise_1$1.isPromise(t))
      return fromPromise(t);
    if (isAsyncIterable_1$1.isAsyncIterable(t))
      return fromAsyncIterable(t);
    if (isIterable_1$1.isIterable(t))
      return fromIterable(t);
    if (isReadableStreamLike_1$2.isReadableStreamLike(t))
      return fromReadableStreamLike(t);
  }
  throw throwUnobservableError_1$1.createInvalidObservableTypeError(t);
}
innerFrom$1.innerFrom = innerFrom;
function fromInteropObservable(t) {
  return new Observable_1$j.Observable(function(e) {
    var r = t[observable_1.observable]();
    if (isFunction_1$f.isFunction(r.subscribe))
      return r.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
innerFrom$1.fromInteropObservable = fromInteropObservable;
function fromArrayLike(t) {
  return new Observable_1$j.Observable(function(e) {
    for (var r = 0; r < t.length && !e.closed; r++)
      e.next(t[r]);
    e.complete();
  });
}
innerFrom$1.fromArrayLike = fromArrayLike;
function fromPromise(t) {
  return new Observable_1$j.Observable(function(e) {
    t.then(function(r) {
      e.closed || (e.next(r), e.complete());
    }, function(r) {
      return e.error(r);
    }).then(null, reportUnhandledError_1.reportUnhandledError);
  });
}
innerFrom$1.fromPromise = fromPromise;
function fromIterable(t) {
  return new Observable_1$j.Observable(function(e) {
    var r, n;
    try {
      for (var i = __values$6(t), o = i.next(); !o.done; o = i.next()) {
        var a = o.value;
        if (e.next(a), e.closed)
          return;
      }
    } catch (c) {
      r = { error: c };
    } finally {
      try {
        o && !o.done && (n = i.return) && n.call(i);
      } finally {
        if (r)
          throw r.error;
      }
    }
    e.complete();
  });
}
innerFrom$1.fromIterable = fromIterable;
function fromAsyncIterable(t) {
  return new Observable_1$j.Observable(function(e) {
    process$1(t, e).catch(function(r) {
      return e.error(r);
    });
  });
}
innerFrom$1.fromAsyncIterable = fromAsyncIterable;
function fromReadableStreamLike(t) {
  return fromAsyncIterable(isReadableStreamLike_1$2.readableStreamLikeToAsyncGenerator(t));
}
innerFrom$1.fromReadableStreamLike = fromReadableStreamLike;
function process$1(t, e) {
  var r, n, i, o;
  return __awaiter$2(this, void 0, void 0, function() {
    var a, c;
    return __generator$2(this, function(l) {
      switch (l.label) {
        case 0:
          l.trys.push([0, 5, 6, 11]), r = __asyncValues(t), l.label = 1;
        case 1:
          return [4, r.next()];
        case 2:
          if (n = l.sent(), !!n.done)
            return [3, 4];
          if (a = n.value, e.next(a), e.closed)
            return [2];
          l.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return c = l.sent(), i = { error: c }, [3, 11];
        case 6:
          return l.trys.push([6, , 9, 10]), n && !n.done && (o = r.return) ? [4, o.call(r)] : [3, 8];
        case 7:
          l.sent(), l.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (i)
            throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
var observeOn$1 = {}, executeSchedule$1 = {};
Object.defineProperty(executeSchedule$1, "__esModule", { value: !0 });
executeSchedule$1.executeSchedule = void 0;
function executeSchedule(t, e, r, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = !1);
  var o = e.schedule(function() {
    r(), i ? t.add(this.schedule(null, n)) : this.unsubscribe();
  }, n);
  if (t.add(o), !i)
    return o;
}
executeSchedule$1.executeSchedule = executeSchedule;
Object.defineProperty(observeOn$1, "__esModule", { value: !0 });
observeOn$1.observeOn = void 0;
var executeSchedule_1$6 = executeSchedule$1, lift_1$13 = lift, OperatorSubscriber_1$T = OperatorSubscriber$1;
function observeOn(t, e) {
  return e === void 0 && (e = 0), lift_1$13.operate(function(r, n) {
    r.subscribe(OperatorSubscriber_1$T.createOperatorSubscriber(n, function(i) {
      return executeSchedule_1$6.executeSchedule(n, t, function() {
        return n.next(i);
      }, e);
    }, function() {
      return executeSchedule_1$6.executeSchedule(n, t, function() {
        return n.complete();
      }, e);
    }, function(i) {
      return executeSchedule_1$6.executeSchedule(n, t, function() {
        return n.error(i);
      }, e);
    }));
  });
}
observeOn$1.observeOn = observeOn;
var subscribeOn$1 = {};
Object.defineProperty(subscribeOn$1, "__esModule", { value: !0 });
subscribeOn$1.subscribeOn = void 0;
var lift_1$12 = lift;
function subscribeOn(t, e) {
  return e === void 0 && (e = 0), lift_1$12.operate(function(r, n) {
    n.add(t.schedule(function() {
      return r.subscribe(n);
    }, e));
  });
}
subscribeOn$1.subscribeOn = subscribeOn;
Object.defineProperty(scheduleObservable$1, "__esModule", { value: !0 });
scheduleObservable$1.scheduleObservable = void 0;
var innerFrom_1$t = innerFrom$1, observeOn_1$2 = observeOn$1, subscribeOn_1$2 = subscribeOn$1;
function scheduleObservable(t, e) {
  return innerFrom_1$t.innerFrom(t).pipe(subscribeOn_1$2.subscribeOn(e), observeOn_1$2.observeOn(e));
}
scheduleObservable$1.scheduleObservable = scheduleObservable;
var schedulePromise$1 = {};
Object.defineProperty(schedulePromise$1, "__esModule", { value: !0 });
schedulePromise$1.schedulePromise = void 0;
var innerFrom_1$s = innerFrom$1, observeOn_1$1 = observeOn$1, subscribeOn_1$1 = subscribeOn$1;
function schedulePromise(t, e) {
  return innerFrom_1$s.innerFrom(t).pipe(subscribeOn_1$1.subscribeOn(e), observeOn_1$1.observeOn(e));
}
schedulePromise$1.schedulePromise = schedulePromise;
var scheduleArray$1 = {};
Object.defineProperty(scheduleArray$1, "__esModule", { value: !0 });
scheduleArray$1.scheduleArray = void 0;
var Observable_1$i = Observable$3;
function scheduleArray(t, e) {
  return new Observable_1$i.Observable(function(r) {
    var n = 0;
    return e.schedule(function() {
      n === t.length ? r.complete() : (r.next(t[n++]), r.closed || this.schedule());
    });
  });
}
scheduleArray$1.scheduleArray = scheduleArray;
var scheduleIterable$1 = {};
Object.defineProperty(scheduleIterable$1, "__esModule", { value: !0 });
scheduleIterable$1.scheduleIterable = void 0;
var Observable_1$h = Observable$3, iterator_1 = iterator, isFunction_1$e = isFunction$1, executeSchedule_1$5 = executeSchedule$1;
function scheduleIterable(t, e) {
  return new Observable_1$h.Observable(function(r) {
    var n;
    return executeSchedule_1$5.executeSchedule(r, e, function() {
      n = t[iterator_1.iterator](), executeSchedule_1$5.executeSchedule(r, e, function() {
        var i, o, a;
        try {
          i = n.next(), o = i.value, a = i.done;
        } catch (c) {
          r.error(c);
          return;
        }
        a ? r.complete() : r.next(o);
      }, 0, !0);
    }), function() {
      return isFunction_1$e.isFunction(n == null ? void 0 : n.return) && n.return();
    };
  });
}
scheduleIterable$1.scheduleIterable = scheduleIterable;
var scheduleAsyncIterable$1 = {};
Object.defineProperty(scheduleAsyncIterable$1, "__esModule", { value: !0 });
scheduleAsyncIterable$1.scheduleAsyncIterable = void 0;
var Observable_1$g = Observable$3, executeSchedule_1$4 = executeSchedule$1;
function scheduleAsyncIterable(t, e) {
  if (!t)
    throw new Error("Iterable cannot be null");
  return new Observable_1$g.Observable(function(r) {
    executeSchedule_1$4.executeSchedule(r, e, function() {
      var n = t[Symbol.asyncIterator]();
      executeSchedule_1$4.executeSchedule(r, e, function() {
        n.next().then(function(i) {
          i.done ? r.complete() : r.next(i.value);
        });
      }, 0, !0);
    });
  });
}
scheduleAsyncIterable$1.scheduleAsyncIterable = scheduleAsyncIterable;
var scheduleReadableStreamLike$1 = {};
Object.defineProperty(scheduleReadableStreamLike$1, "__esModule", { value: !0 });
scheduleReadableStreamLike$1.scheduleReadableStreamLike = void 0;
var scheduleAsyncIterable_1$1 = scheduleAsyncIterable$1, isReadableStreamLike_1$1 = isReadableStreamLike$1;
function scheduleReadableStreamLike(t, e) {
  return scheduleAsyncIterable_1$1.scheduleAsyncIterable(isReadableStreamLike_1$1.readableStreamLikeToAsyncGenerator(t), e);
}
scheduleReadableStreamLike$1.scheduleReadableStreamLike = scheduleReadableStreamLike;
Object.defineProperty(scheduled$1, "__esModule", { value: !0 });
scheduled$1.scheduled = void 0;
var scheduleObservable_1 = scheduleObservable$1, schedulePromise_1 = schedulePromise$1, scheduleArray_1 = scheduleArray$1, scheduleIterable_1$1 = scheduleIterable$1, scheduleAsyncIterable_1 = scheduleAsyncIterable$1, isInteropObservable_1 = isInteropObservable$1, isPromise_1 = isPromise$1, isArrayLike_1$1 = isArrayLike, isIterable_1 = isIterable$1, isAsyncIterable_1 = isAsyncIterable$1, throwUnobservableError_1 = throwUnobservableError, isReadableStreamLike_1 = isReadableStreamLike$1, scheduleReadableStreamLike_1 = scheduleReadableStreamLike$1;
function scheduled(t, e) {
  if (t != null) {
    if (isInteropObservable_1.isInteropObservable(t))
      return scheduleObservable_1.scheduleObservable(t, e);
    if (isArrayLike_1$1.isArrayLike(t))
      return scheduleArray_1.scheduleArray(t, e);
    if (isPromise_1.isPromise(t))
      return schedulePromise_1.schedulePromise(t, e);
    if (isAsyncIterable_1.isAsyncIterable(t))
      return scheduleAsyncIterable_1.scheduleAsyncIterable(t, e);
    if (isIterable_1.isIterable(t))
      return scheduleIterable_1$1.scheduleIterable(t, e);
    if (isReadableStreamLike_1.isReadableStreamLike(t))
      return scheduleReadableStreamLike_1.scheduleReadableStreamLike(t, e);
  }
  throw throwUnobservableError_1.createInvalidObservableTypeError(t);
}
scheduled$1.scheduled = scheduled;
Object.defineProperty(from$1, "__esModule", { value: !0 });
from$1.from = void 0;
var scheduled_1 = scheduled$1, innerFrom_1$r = innerFrom$1;
function from(t, e) {
  return e ? scheduled_1.scheduled(t, e) : innerFrom_1$r.innerFrom(t);
}
from$1.from = from;
Object.defineProperty(of$1, "__esModule", { value: !0 });
of$1.of = void 0;
var args_1$c = args, from_1$8 = from$1;
function of() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1$c.popScheduler(t);
  return from_1$8.from(t, r);
}
of$1.of = of;
var throwError$1 = {};
Object.defineProperty(throwError$1, "__esModule", { value: !0 });
throwError$1.throwError = void 0;
var Observable_1$f = Observable$3, isFunction_1$d = isFunction$1;
function throwError(t, e) {
  var r = isFunction_1$d.isFunction(t) ? t : function() {
    return t;
  }, n = function(i) {
    return i.error(r());
  };
  return new Observable_1$f.Observable(e ? function(i) {
    return e.schedule(n, 0, i);
  } : n);
}
throwError$1.throwError = throwError;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.observeNotification = t.Notification = t.NotificationKind = void 0;
  var e = empty, r = of$1, n = throwError$1, i = isFunction$1;
  (function(c) {
    c.NEXT = "N", c.ERROR = "E", c.COMPLETE = "C";
  })(t.NotificationKind || (t.NotificationKind = {}));
  var o = function() {
    function c(l, u, f) {
      this.kind = l, this.value = u, this.error = f, this.hasValue = l === "N";
    }
    return c.prototype.observe = function(l) {
      return a(this, l);
    }, c.prototype.do = function(l, u, f) {
      var d = this, p = d.kind, g = d.value, h = d.error;
      return p === "N" ? l == null ? void 0 : l(g) : p === "E" ? u == null ? void 0 : u(h) : f == null ? void 0 : f();
    }, c.prototype.accept = function(l, u, f) {
      var d;
      return i.isFunction((d = l) === null || d === void 0 ? void 0 : d.next) ? this.observe(l) : this.do(l, u, f);
    }, c.prototype.toObservable = function() {
      var l = this, u = l.kind, f = l.value, d = l.error, p = u === "N" ? r.of(f) : u === "E" ? n.throwError(function() {
        return d;
      }) : u === "C" ? e.EMPTY : 0;
      if (!p)
        throw new TypeError("Unexpected notification kind " + u);
      return p;
    }, c.createNext = function(l) {
      return new c("N", l);
    }, c.createError = function(l) {
      return new c("E", void 0, l);
    }, c.createComplete = function() {
      return c.completeNotification;
    }, c.completeNotification = new c("C"), c;
  }();
  t.Notification = o;
  function a(c, l) {
    var u, f, d, p = c, g = p.kind, h = p.value, m = p.error;
    if (typeof g != "string")
      throw new TypeError('Invalid notification, missing "kind"');
    g === "N" ? (u = l.next) === null || u === void 0 || u.call(l, h) : g === "E" ? (f = l.error) === null || f === void 0 || f.call(l, m) : (d = l.complete) === null || d === void 0 || d.call(l);
  }
  t.observeNotification = a;
})(Notification);
var isObservable$2 = {};
Object.defineProperty(isObservable$2, "__esModule", { value: !0 });
isObservable$2.isObservable = void 0;
var Observable_1$e = Observable$3, isFunction_1$c = isFunction$1;
function isObservable$1(t) {
  return !!t && (t instanceof Observable_1$e.Observable || isFunction_1$c.isFunction(t.lift) && isFunction_1$c.isFunction(t.subscribe));
}
isObservable$2.isObservable = isObservable$1;
var lastValueFrom$1 = {}, EmptyError = {};
Object.defineProperty(EmptyError, "__esModule", { value: !0 });
EmptyError.EmptyError = void 0;
var createErrorClass_1$3 = createErrorClass$1;
EmptyError.EmptyError = createErrorClass_1$3.createErrorClass(function(t) {
  return function() {
    t(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
Object.defineProperty(lastValueFrom$1, "__esModule", { value: !0 });
lastValueFrom$1.lastValueFrom = void 0;
var EmptyError_1$5 = EmptyError;
function lastValueFrom(t, e) {
  var r = typeof e == "object";
  return new Promise(function(n, i) {
    var o = !1, a;
    t.subscribe({
      next: function(c) {
        a = c, o = !0;
      },
      error: i,
      complete: function() {
        o ? n(a) : r ? n(e.defaultValue) : i(new EmptyError_1$5.EmptyError());
      }
    });
  });
}
lastValueFrom$1.lastValueFrom = lastValueFrom;
var firstValueFrom$1 = {};
Object.defineProperty(firstValueFrom$1, "__esModule", { value: !0 });
firstValueFrom$1.firstValueFrom = void 0;
var EmptyError_1$4 = EmptyError, Subscriber_1$1 = Subscriber;
function firstValueFrom(t, e) {
  var r = typeof e == "object";
  return new Promise(function(n, i) {
    var o = new Subscriber_1$1.SafeSubscriber({
      next: function(a) {
        n(a), o.unsubscribe();
      },
      error: i,
      complete: function() {
        r ? n(e.defaultValue) : i(new EmptyError_1$4.EmptyError());
      }
    });
    t.subscribe(o);
  });
}
firstValueFrom$1.firstValueFrom = firstValueFrom;
var ArgumentOutOfRangeError = {};
Object.defineProperty(ArgumentOutOfRangeError, "__esModule", { value: !0 });
ArgumentOutOfRangeError.ArgumentOutOfRangeError = void 0;
var createErrorClass_1$2 = createErrorClass$1;
ArgumentOutOfRangeError.ArgumentOutOfRangeError = createErrorClass_1$2.createErrorClass(function(t) {
  return function() {
    t(this), this.name = "ArgumentOutOfRangeError", this.message = "argument out of range";
  };
});
var NotFoundError = {};
Object.defineProperty(NotFoundError, "__esModule", { value: !0 });
NotFoundError.NotFoundError = void 0;
var createErrorClass_1$1 = createErrorClass$1;
NotFoundError.NotFoundError = createErrorClass_1$1.createErrorClass(function(t) {
  return function(r) {
    t(this), this.name = "NotFoundError", this.message = r;
  };
});
var SequenceError = {};
Object.defineProperty(SequenceError, "__esModule", { value: !0 });
SequenceError.SequenceError = void 0;
var createErrorClass_1 = createErrorClass$1;
SequenceError.SequenceError = createErrorClass_1.createErrorClass(function(t) {
  return function(r) {
    t(this), this.name = "SequenceError", this.message = r;
  };
});
var timeout = {}, isDate = {};
Object.defineProperty(isDate, "__esModule", { value: !0 });
isDate.isValidDate = void 0;
function isValidDate(t) {
  return t instanceof Date && !isNaN(t);
}
isDate.isValidDate = isValidDate;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.timeout = t.TimeoutError = void 0;
  var e = async, r = isDate, n = lift, i = innerFrom$1, o = createErrorClass$1, a = OperatorSubscriber$1, c = executeSchedule$1;
  t.TimeoutError = o.createErrorClass(function(f) {
    return function(p) {
      p === void 0 && (p = null), f(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this.info = p;
    };
  });
  function l(f, d) {
    var p = r.isValidDate(f) ? { first: f } : typeof f == "number" ? { each: f } : f, g = p.first, h = p.each, m = p.with, y = m === void 0 ? u : m, b = p.scheduler, v = b === void 0 ? d ?? e.asyncScheduler : b, _ = p.meta, E = _ === void 0 ? null : _;
    if (g == null && h == null)
      throw new TypeError("No timeout provided.");
    return n.operate(function(w, S) {
      var x, I, C = null, M = 0, O = function(B) {
        I = c.executeSchedule(S, v, function() {
          try {
            x.unsubscribe(), i.innerFrom(y({
              meta: E,
              lastValue: C,
              seen: M
            })).subscribe(S);
          } catch (k) {
            S.error(k);
          }
        }, B);
      };
      x = w.subscribe(a.createOperatorSubscriber(S, function(B) {
        I == null || I.unsubscribe(), M++, S.next(C = B), h > 0 && O(h);
      }, void 0, void 0, function() {
        I != null && I.closed || I == null || I.unsubscribe(), C = null;
      })), !M && O(g != null ? typeof g == "number" ? g : +g - v.now() : h);
    });
  }
  t.timeout = l;
  function u(f) {
    throw new t.TimeoutError(f);
  }
})(timeout);
var bindCallback$1 = {}, bindCallbackInternals$1 = {}, mapOneOrManyArgs$1 = {}, map$1 = {};
Object.defineProperty(map$1, "__esModule", { value: !0 });
map$1.map = void 0;
var lift_1$11 = lift, OperatorSubscriber_1$S = OperatorSubscriber$1;
function map(t, e) {
  return lift_1$11.operate(function(r, n) {
    var i = 0;
    r.subscribe(OperatorSubscriber_1$S.createOperatorSubscriber(n, function(o) {
      n.next(t.call(e, o, i++));
    }));
  });
}
map$1.map = map;
var __read$g = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$f = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(mapOneOrManyArgs$1, "__esModule", { value: !0 });
mapOneOrManyArgs$1.mapOneOrManyArgs = void 0;
var map_1$5 = map$1, isArray$2 = Array.isArray;
function callOrApply(t, e) {
  return isArray$2(e) ? t.apply(void 0, __spreadArray$f([], __read$g(e))) : t(e);
}
function mapOneOrManyArgs(t) {
  return map_1$5.map(function(e) {
    return callOrApply(t, e);
  });
}
mapOneOrManyArgs$1.mapOneOrManyArgs = mapOneOrManyArgs;
var __read$f = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$e = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(bindCallbackInternals$1, "__esModule", { value: !0 });
bindCallbackInternals$1.bindCallbackInternals = void 0;
var isScheduler_1$2 = isScheduler$1, Observable_1$d = Observable$3, subscribeOn_1 = subscribeOn$1, mapOneOrManyArgs_1$6 = mapOneOrManyArgs$1, observeOn_1 = observeOn$1, AsyncSubject_1$1 = AsyncSubject$1;
function bindCallbackInternals(t, e, r, n) {
  if (r)
    if (isScheduler_1$2.isScheduler(r))
      n = r;
    else
      return function() {
        for (var i = [], o = 0; o < arguments.length; o++)
          i[o] = arguments[o];
        return bindCallbackInternals(t, e, n).apply(this, i).pipe(mapOneOrManyArgs_1$6.mapOneOrManyArgs(r));
      };
  return n ? function() {
    for (var i = [], o = 0; o < arguments.length; o++)
      i[o] = arguments[o];
    return bindCallbackInternals(t, e).apply(this, i).pipe(subscribeOn_1.subscribeOn(n), observeOn_1.observeOn(n));
  } : function() {
    for (var i = this, o = [], a = 0; a < arguments.length; a++)
      o[a] = arguments[a];
    var c = new AsyncSubject_1$1.AsyncSubject(), l = !0;
    return new Observable_1$d.Observable(function(u) {
      var f = c.subscribe(u);
      if (l) {
        l = !1;
        var d = !1, p = !1;
        e.apply(i, __spreadArray$e(__spreadArray$e([], __read$f(o)), [
          function() {
            for (var g = [], h = 0; h < arguments.length; h++)
              g[h] = arguments[h];
            if (t) {
              var m = g.shift();
              if (m != null) {
                c.error(m);
                return;
              }
            }
            c.next(1 < g.length ? g : g[0]), p = !0, d && c.complete();
          }
        ])), p && c.complete(), d = !0;
      }
      return f;
    });
  };
}
bindCallbackInternals$1.bindCallbackInternals = bindCallbackInternals;
Object.defineProperty(bindCallback$1, "__esModule", { value: !0 });
bindCallback$1.bindCallback = void 0;
var bindCallbackInternals_1$1 = bindCallbackInternals$1;
function bindCallback(t, e, r) {
  return bindCallbackInternals_1$1.bindCallbackInternals(!1, t, e, r);
}
bindCallback$1.bindCallback = bindCallback;
var bindNodeCallback$1 = {};
Object.defineProperty(bindNodeCallback$1, "__esModule", { value: !0 });
bindNodeCallback$1.bindNodeCallback = void 0;
var bindCallbackInternals_1 = bindCallbackInternals$1;
function bindNodeCallback(t, e, r) {
  return bindCallbackInternals_1.bindCallbackInternals(!0, t, e, r);
}
bindNodeCallback$1.bindNodeCallback = bindNodeCallback;
var combineLatest$3 = {}, argsArgArrayOrObject$1 = {};
Object.defineProperty(argsArgArrayOrObject$1, "__esModule", { value: !0 });
argsArgArrayOrObject$1.argsArgArrayOrObject = void 0;
var isArray$1 = Array.isArray, getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(t) {
  if (t.length === 1) {
    var e = t[0];
    if (isArray$1(e))
      return { args: e, keys: null };
    if (isPOJO(e)) {
      var r = getKeys(e);
      return {
        args: r.map(function(n) {
          return e[n];
        }),
        keys: r
      };
    }
  }
  return { args: t, keys: null };
}
argsArgArrayOrObject$1.argsArgArrayOrObject = argsArgArrayOrObject;
function isPOJO(t) {
  return t && typeof t == "object" && getPrototypeOf(t) === objectProto;
}
var createObject$1 = {};
Object.defineProperty(createObject$1, "__esModule", { value: !0 });
createObject$1.createObject = void 0;
function createObject(t, e) {
  return t.reduce(function(r, n, i) {
    return r[n] = e[i], r;
  }, {});
}
createObject$1.createObject = createObject;
Object.defineProperty(combineLatest$3, "__esModule", { value: !0 });
combineLatest$3.combineLatestInit = combineLatest$3.combineLatest = void 0;
var Observable_1$c = Observable$3, argsArgArrayOrObject_1$1 = argsArgArrayOrObject$1, from_1$7 = from$1, identity_1$c = identity$1, mapOneOrManyArgs_1$5 = mapOneOrManyArgs$1, args_1$b = args, createObject_1$1 = createObject$1, OperatorSubscriber_1$R = OperatorSubscriber$1, executeSchedule_1$3 = executeSchedule$1;
function combineLatest$2() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1$b.popScheduler(t), n = args_1$b.popResultSelector(t), i = argsArgArrayOrObject_1$1.argsArgArrayOrObject(t), o = i.args, a = i.keys;
  if (o.length === 0)
    return from_1$7.from([], r);
  var c = new Observable_1$c.Observable(combineLatestInit(o, r, a ? function(l) {
    return createObject_1$1.createObject(a, l);
  } : identity_1$c.identity));
  return n ? c.pipe(mapOneOrManyArgs_1$5.mapOneOrManyArgs(n)) : c;
}
combineLatest$3.combineLatest = combineLatest$2;
function combineLatestInit(t, e, r) {
  return r === void 0 && (r = identity_1$c.identity), function(n) {
    maybeSchedule(e, function() {
      for (var i = t.length, o = new Array(i), a = i, c = i, l = function(f) {
        maybeSchedule(e, function() {
          var d = from_1$7.from(t[f], e), p = !1;
          d.subscribe(OperatorSubscriber_1$R.createOperatorSubscriber(n, function(g) {
            o[f] = g, p || (p = !0, c--), c || n.next(r(o.slice()));
          }, function() {
            --a || n.complete();
          }));
        }, n);
      }, u = 0; u < i; u++)
        l(u);
    }, n);
  };
}
combineLatest$3.combineLatestInit = combineLatestInit;
function maybeSchedule(t, e, r) {
  t ? executeSchedule_1$3.executeSchedule(r, t, e) : e();
}
var concat$3 = {}, concatAll$1 = {}, mergeAll$1 = {}, mergeMap$1 = {}, mergeInternals$1 = {};
Object.defineProperty(mergeInternals$1, "__esModule", { value: !0 });
mergeInternals$1.mergeInternals = void 0;
var innerFrom_1$q = innerFrom$1, executeSchedule_1$2 = executeSchedule$1, OperatorSubscriber_1$Q = OperatorSubscriber$1;
function mergeInternals(t, e, r, n, i, o, a, c) {
  var l = [], u = 0, f = 0, d = !1, p = function() {
    d && !l.length && !u && e.complete();
  }, g = function(m) {
    return u < n ? h(m) : l.push(m);
  }, h = function(m) {
    o && e.next(m), u++;
    var y = !1;
    innerFrom_1$q.innerFrom(r(m, f++)).subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(e, function(b) {
      i == null || i(b), o ? g(b) : e.next(b);
    }, function() {
      y = !0;
    }, void 0, function() {
      if (y)
        try {
          u--;
          for (var b = function() {
            var v = l.shift();
            a ? executeSchedule_1$2.executeSchedule(e, a, function() {
              return h(v);
            }) : h(v);
          }; l.length && u < n; )
            b();
          p();
        } catch (v) {
          e.error(v);
        }
    }));
  };
  return t.subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(e, g, function() {
    d = !0, p();
  })), function() {
    c == null || c();
  };
}
mergeInternals$1.mergeInternals = mergeInternals;
Object.defineProperty(mergeMap$1, "__esModule", { value: !0 });
mergeMap$1.mergeMap = void 0;
var map_1$4 = map$1, innerFrom_1$p = innerFrom$1, lift_1$10 = lift, mergeInternals_1$2 = mergeInternals$1, isFunction_1$b = isFunction$1;
function mergeMap(t, e, r) {
  return r === void 0 && (r = 1 / 0), isFunction_1$b.isFunction(e) ? mergeMap(function(n, i) {
    return map_1$4.map(function(o, a) {
      return e(n, o, i, a);
    })(innerFrom_1$p.innerFrom(t(n, i)));
  }, r) : (typeof e == "number" && (r = e), lift_1$10.operate(function(n, i) {
    return mergeInternals_1$2.mergeInternals(n, i, t, r);
  }));
}
mergeMap$1.mergeMap = mergeMap;
Object.defineProperty(mergeAll$1, "__esModule", { value: !0 });
mergeAll$1.mergeAll = void 0;
var mergeMap_1$6 = mergeMap$1, identity_1$b = identity$1;
function mergeAll(t) {
  return t === void 0 && (t = 1 / 0), mergeMap_1$6.mergeMap(identity_1$b.identity, t);
}
mergeAll$1.mergeAll = mergeAll;
Object.defineProperty(concatAll$1, "__esModule", { value: !0 });
concatAll$1.concatAll = void 0;
var mergeAll_1$2 = mergeAll$1;
function concatAll() {
  return mergeAll_1$2.mergeAll(1);
}
concatAll$1.concatAll = concatAll;
Object.defineProperty(concat$3, "__esModule", { value: !0 });
concat$3.concat = void 0;
var concatAll_1$1 = concatAll$1, args_1$a = args, from_1$6 = from$1;
function concat$2() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return concatAll_1$1.concatAll()(from_1$6.from(t, args_1$a.popScheduler(t)));
}
concat$3.concat = concat$2;
var connectable$1 = {}, defer$1 = {};
Object.defineProperty(defer$1, "__esModule", { value: !0 });
defer$1.defer = void 0;
var Observable_1$b = Observable$3, innerFrom_1$o = innerFrom$1;
function defer(t) {
  return new Observable_1$b.Observable(function(e) {
    innerFrom_1$o.innerFrom(t()).subscribe(e);
  });
}
defer$1.defer = defer;
Object.defineProperty(connectable$1, "__esModule", { value: !0 });
connectable$1.connectable = void 0;
var Subject_1$b = Subject$2, Observable_1$a = Observable$3, defer_1$2 = defer$1, DEFAULT_CONFIG$1 = {
  connector: function() {
    return new Subject_1$b.Subject();
  },
  resetOnDisconnect: !0
};
function connectable(t, e) {
  e === void 0 && (e = DEFAULT_CONFIG$1);
  var r = null, n = e.connector, i = e.resetOnDisconnect, o = i === void 0 ? !0 : i, a = n(), c = new Observable_1$a.Observable(function(l) {
    return a.subscribe(l);
  });
  return c.connect = function() {
    return (!r || r.closed) && (r = defer_1$2.defer(function() {
      return t;
    }).subscribe(a), o && r.add(function() {
      return a = n();
    })), r;
  }, c;
}
connectable$1.connectable = connectable;
var forkJoin$1 = {};
Object.defineProperty(forkJoin$1, "__esModule", { value: !0 });
forkJoin$1.forkJoin = void 0;
var Observable_1$9 = Observable$3, argsArgArrayOrObject_1 = argsArgArrayOrObject$1, innerFrom_1$n = innerFrom$1, args_1$9 = args, OperatorSubscriber_1$P = OperatorSubscriber$1, mapOneOrManyArgs_1$4 = mapOneOrManyArgs$1, createObject_1 = createObject$1;
function forkJoin() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1$9.popResultSelector(t), n = argsArgArrayOrObject_1.argsArgArrayOrObject(t), i = n.args, o = n.keys, a = new Observable_1$9.Observable(function(c) {
    var l = i.length;
    if (!l) {
      c.complete();
      return;
    }
    for (var u = new Array(l), f = l, d = l, p = function(h) {
      var m = !1;
      innerFrom_1$n.innerFrom(i[h]).subscribe(OperatorSubscriber_1$P.createOperatorSubscriber(c, function(y) {
        m || (m = !0, d--), u[h] = y;
      }, function() {
        return f--;
      }, void 0, function() {
        (!f || !m) && (d || c.next(o ? createObject_1.createObject(o, u) : u), c.complete());
      }));
    }, g = 0; g < l; g++)
      p(g);
  });
  return r ? a.pipe(mapOneOrManyArgs_1$4.mapOneOrManyArgs(r)) : a;
}
forkJoin$1.forkJoin = forkJoin;
var fromEvent$1 = {}, __read$e = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
};
Object.defineProperty(fromEvent$1, "__esModule", { value: !0 });
fromEvent$1.fromEvent = void 0;
var innerFrom_1$m = innerFrom$1, Observable_1$8 = Observable$3, mergeMap_1$5 = mergeMap$1, isArrayLike_1 = isArrayLike, isFunction_1$a = isFunction$1, mapOneOrManyArgs_1$3 = mapOneOrManyArgs$1, nodeEventEmitterMethods = ["addListener", "removeListener"], eventTargetMethods = ["addEventListener", "removeEventListener"], jqueryMethods = ["on", "off"];
function fromEvent(t, e, r, n) {
  if (isFunction_1$a.isFunction(r) && (n = r, r = void 0), n)
    return fromEvent(t, e, r).pipe(mapOneOrManyArgs_1$3.mapOneOrManyArgs(n));
  var i = __read$e(isEventTarget(t) ? eventTargetMethods.map(function(c) {
    return function(l) {
      return t[c](e, l, r);
    };
  }) : isNodeStyleEventEmitter(t) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(t, e)) : isJQueryStyleEventEmitter(t) ? jqueryMethods.map(toCommonHandlerRegistry(t, e)) : [], 2), o = i[0], a = i[1];
  if (!o && isArrayLike_1.isArrayLike(t))
    return mergeMap_1$5.mergeMap(function(c) {
      return fromEvent(c, e, r);
    })(innerFrom_1$m.innerFrom(t));
  if (!o)
    throw new TypeError("Invalid event target");
  return new Observable_1$8.Observable(function(c) {
    var l = function() {
      for (var u = [], f = 0; f < arguments.length; f++)
        u[f] = arguments[f];
      return c.next(1 < u.length ? u : u[0]);
    };
    return o(l), function() {
      return a(l);
    };
  });
}
fromEvent$1.fromEvent = fromEvent;
function toCommonHandlerRegistry(t, e) {
  return function(r) {
    return function(n) {
      return t[r](e, n);
    };
  };
}
function isNodeStyleEventEmitter(t) {
  return isFunction_1$a.isFunction(t.addListener) && isFunction_1$a.isFunction(t.removeListener);
}
function isJQueryStyleEventEmitter(t) {
  return isFunction_1$a.isFunction(t.on) && isFunction_1$a.isFunction(t.off);
}
function isEventTarget(t) {
  return isFunction_1$a.isFunction(t.addEventListener) && isFunction_1$a.isFunction(t.removeEventListener);
}
var fromEventPattern$1 = {};
Object.defineProperty(fromEventPattern$1, "__esModule", { value: !0 });
fromEventPattern$1.fromEventPattern = void 0;
var Observable_1$7 = Observable$3, isFunction_1$9 = isFunction$1, mapOneOrManyArgs_1$2 = mapOneOrManyArgs$1;
function fromEventPattern(t, e, r) {
  return r ? fromEventPattern(t, e).pipe(mapOneOrManyArgs_1$2.mapOneOrManyArgs(r)) : new Observable_1$7.Observable(function(n) {
    var i = function() {
      for (var a = [], c = 0; c < arguments.length; c++)
        a[c] = arguments[c];
      return n.next(a.length === 1 ? a[0] : a);
    }, o = t(i);
    return isFunction_1$9.isFunction(e) ? function() {
      return e(i, o);
    } : void 0;
  });
}
fromEventPattern$1.fromEventPattern = fromEventPattern;
var generate$1 = {}, __generator$1 = commonjsGlobal && commonjsGlobal.__generator || function(t, e) {
  var r = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, n, i, o, a;
  return a = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function c(u) {
    return function(f) {
      return l([u, f]);
    };
  }
  function l(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done)
          return o;
        switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
          case 0:
          case 1:
            o = u;
            break;
          case 4:
            return r.label++, { value: u[1], done: !1 };
          case 5:
            r.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (o = r.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < o[1]) {
              r.label = o[1], o = u;
              break;
            }
            if (o && r.label < o[2]) {
              r.label = o[2], r.ops.push(u);
              break;
            }
            o[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = e.call(t, r);
      } catch (f) {
        u = [6, f], i = 0;
      } finally {
        n = o = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
};
Object.defineProperty(generate$1, "__esModule", { value: !0 });
generate$1.generate = void 0;
var identity_1$a = identity$1, isScheduler_1$1 = isScheduler$1, defer_1$1 = defer$1, scheduleIterable_1 = scheduleIterable$1;
function generate(t, e, r, n, i) {
  var o, a, c, l;
  arguments.length === 1 ? (o = t, l = o.initialState, e = o.condition, r = o.iterate, a = o.resultSelector, c = a === void 0 ? identity_1$a.identity : a, i = o.scheduler) : (l = t, !n || isScheduler_1$1.isScheduler(n) ? (c = identity_1$a.identity, i = n) : c = n);
  function u() {
    var f;
    return __generator$1(this, function(d) {
      switch (d.label) {
        case 0:
          f = l, d.label = 1;
        case 1:
          return !e || e(f) ? [4, c(f)] : [3, 4];
        case 2:
          d.sent(), d.label = 3;
        case 3:
          return f = r(f), [3, 1];
        case 4:
          return [2];
      }
    });
  }
  return defer_1$1.defer(i ? function() {
    return scheduleIterable_1.scheduleIterable(u(), i);
  } : u);
}
generate$1.generate = generate;
var iif$1 = {};
Object.defineProperty(iif$1, "__esModule", { value: !0 });
iif$1.iif = void 0;
var defer_1 = defer$1;
function iif(t, e, r) {
  return defer_1.defer(function() {
    return t() ? e : r;
  });
}
iif$1.iif = iif;
var interval$1 = {}, timer$1 = {};
Object.defineProperty(timer$1, "__esModule", { value: !0 });
timer$1.timer = void 0;
var Observable_1$6 = Observable$3, async_1$a = async, isScheduler_1 = isScheduler$1, isDate_1$1 = isDate;
function timer(t, e, r) {
  t === void 0 && (t = 0), r === void 0 && (r = async_1$a.async);
  var n = -1;
  return e != null && (isScheduler_1.isScheduler(e) ? r = e : n = e), new Observable_1$6.Observable(function(i) {
    var o = isDate_1$1.isValidDate(t) ? +t - r.now() : t;
    o < 0 && (o = 0);
    var a = 0;
    return r.schedule(function() {
      i.closed || (i.next(a++), 0 <= n ? this.schedule(void 0, n) : i.complete());
    }, o);
  });
}
timer$1.timer = timer;
Object.defineProperty(interval$1, "__esModule", { value: !0 });
interval$1.interval = void 0;
var async_1$9 = async, timer_1$5 = timer$1;
function interval(t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = async_1$9.asyncScheduler), t < 0 && (t = 0), timer_1$5.timer(t, t, e);
}
interval$1.interval = interval;
var merge$3 = {};
Object.defineProperty(merge$3, "__esModule", { value: !0 });
merge$3.merge = void 0;
var mergeAll_1$1 = mergeAll$1, innerFrom_1$l = innerFrom$1, empty_1$7 = empty, args_1$8 = args, from_1$5 = from$1;
function merge$2() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1$8.popScheduler(t), n = args_1$8.popNumber(t, 1 / 0), i = t;
  return i.length ? i.length === 1 ? innerFrom_1$l.innerFrom(i[0]) : mergeAll_1$1.mergeAll(n)(from_1$5.from(i, r)) : empty_1$7.EMPTY;
}
merge$3.merge = merge$2;
var never = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.never = t.NEVER = void 0;
  var e = Observable$3, r = noop$1;
  t.NEVER = new e.Observable(r.noop);
  function n() {
    return t.NEVER;
  }
  t.never = n;
})(never);
var onErrorResumeNext$3 = {}, onErrorResumeNext$2 = {}, argsOrArgArray$1 = {};
Object.defineProperty(argsOrArgArray$1, "__esModule", { value: !0 });
argsOrArgArray$1.argsOrArgArray = void 0;
var isArray = Array.isArray;
function argsOrArgArray(t) {
  return t.length === 1 && isArray(t[0]) ? t[0] : t;
}
argsOrArgArray$1.argsOrArgArray = argsOrArgArray;
var __read$d = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$d = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(onErrorResumeNext$2, "__esModule", { value: !0 });
onErrorResumeNext$2.onErrorResumeNext = void 0;
var lift_1$$ = lift, innerFrom_1$k = innerFrom$1, argsOrArgArray_1$5 = argsOrArgArray$1, OperatorSubscriber_1$O = OperatorSubscriber$1, noop_1$c = noop$1;
function onErrorResumeNext$1() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = argsOrArgArray_1$5.argsOrArgArray(t);
  return lift_1$$.operate(function(n, i) {
    var o = __spreadArray$d([n], __read$d(r)), a = function() {
      if (!i.closed)
        if (o.length > 0) {
          var c = void 0;
          try {
            c = innerFrom_1$k.innerFrom(o.shift());
          } catch {
            a();
            return;
          }
          var l = OperatorSubscriber_1$O.createOperatorSubscriber(i, void 0, noop_1$c.noop, noop_1$c.noop);
          c.subscribe(l), l.add(a);
        } else
          i.complete();
    };
    a();
  });
}
onErrorResumeNext$2.onErrorResumeNext = onErrorResumeNext$1;
Object.defineProperty(onErrorResumeNext$3, "__esModule", { value: !0 });
onErrorResumeNext$3.onErrorResumeNext = void 0;
var empty_1$6 = empty, onErrorResumeNext_1 = onErrorResumeNext$2, argsOrArgArray_1$4 = argsOrArgArray$1;
function onErrorResumeNext() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return onErrorResumeNext_1.onErrorResumeNext(argsOrArgArray_1$4.argsOrArgArray(t))(empty_1$6.EMPTY);
}
onErrorResumeNext$3.onErrorResumeNext = onErrorResumeNext;
var pairs$1 = {};
Object.defineProperty(pairs$1, "__esModule", { value: !0 });
pairs$1.pairs = void 0;
var from_1$4 = from$1;
function pairs(t, e) {
  return from_1$4.from(Object.entries(t), e);
}
pairs$1.pairs = pairs;
var partition$1 = {}, not$1 = {};
Object.defineProperty(not$1, "__esModule", { value: !0 });
not$1.not = void 0;
function not(t, e) {
  return function(r, n) {
    return !t.call(e, r, n);
  };
}
not$1.not = not;
var filter$1 = {};
Object.defineProperty(filter$1, "__esModule", { value: !0 });
filter$1.filter = void 0;
var lift_1$_ = lift, OperatorSubscriber_1$N = OperatorSubscriber$1;
function filter(t, e) {
  return lift_1$_.operate(function(r, n) {
    var i = 0;
    r.subscribe(OperatorSubscriber_1$N.createOperatorSubscriber(n, function(o) {
      return t.call(e, o, i++) && n.next(o);
    }));
  });
}
filter$1.filter = filter;
Object.defineProperty(partition$1, "__esModule", { value: !0 });
partition$1.partition = void 0;
var not_1 = not$1, filter_1$4 = filter$1, innerFrom_1$j = innerFrom$1;
function partition(t, e, r) {
  return [filter_1$4.filter(e, r)(innerFrom_1$j.innerFrom(t)), filter_1$4.filter(not_1.not(e, r))(innerFrom_1$j.innerFrom(t))];
}
partition$1.partition = partition;
var race$1 = {};
Object.defineProperty(race$1, "__esModule", { value: !0 });
race$1.raceInit = race$1.race = void 0;
var Observable_1$5 = Observable$3, innerFrom_1$i = innerFrom$1, argsOrArgArray_1$3 = argsOrArgArray$1, OperatorSubscriber_1$M = OperatorSubscriber$1;
function race() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return t = argsOrArgArray_1$3.argsOrArgArray(t), t.length === 1 ? innerFrom_1$i.innerFrom(t[0]) : new Observable_1$5.Observable(raceInit(t));
}
race$1.race = race;
function raceInit(t) {
  return function(e) {
    for (var r = [], n = function(o) {
      r.push(innerFrom_1$i.innerFrom(t[o]).subscribe(OperatorSubscriber_1$M.createOperatorSubscriber(e, function(a) {
        if (r) {
          for (var c = 0; c < r.length; c++)
            c !== o && r[c].unsubscribe();
          r = null;
        }
        e.next(a);
      })));
    }, i = 0; r && !e.closed && i < t.length; i++)
      n(i);
  };
}
race$1.raceInit = raceInit;
var range$1 = {};
Object.defineProperty(range$1, "__esModule", { value: !0 });
range$1.range = void 0;
var Observable_1$4 = Observable$3, empty_1$5 = empty;
function range(t, e, r) {
  if (e == null && (e = t, t = 0), e <= 0)
    return empty_1$5.EMPTY;
  var n = e + t;
  return new Observable_1$4.Observable(r ? function(i) {
    var o = t;
    return r.schedule(function() {
      o < n ? (i.next(o++), this.schedule()) : i.complete();
    });
  } : function(i) {
    for (var o = t; o < n && !i.closed; )
      i.next(o++);
    i.complete();
  });
}
range$1.range = range;
var using$1 = {};
Object.defineProperty(using$1, "__esModule", { value: !0 });
using$1.using = void 0;
var Observable_1$3 = Observable$3, innerFrom_1$h = innerFrom$1, empty_1$4 = empty;
function using(t, e) {
  return new Observable_1$3.Observable(function(r) {
    var n = t(), i = e(n), o = i ? innerFrom_1$h.innerFrom(i) : empty_1$4.EMPTY;
    return o.subscribe(r), function() {
      n && n.unsubscribe();
    };
  });
}
using$1.using = using;
var zip$3 = {}, __read$c = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$c = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(zip$3, "__esModule", { value: !0 });
zip$3.zip = void 0;
var Observable_1$2 = Observable$3, innerFrom_1$g = innerFrom$1, argsOrArgArray_1$2 = argsOrArgArray$1, empty_1$3 = empty, OperatorSubscriber_1$L = OperatorSubscriber$1, args_1$7 = args;
function zip$2() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1$7.popResultSelector(t), n = argsOrArgArray_1$2.argsOrArgArray(t);
  return n.length ? new Observable_1$2.Observable(function(i) {
    var o = n.map(function() {
      return [];
    }), a = n.map(function() {
      return !1;
    });
    i.add(function() {
      o = a = null;
    });
    for (var c = function(u) {
      innerFrom_1$g.innerFrom(n[u]).subscribe(OperatorSubscriber_1$L.createOperatorSubscriber(i, function(f) {
        if (o[u].push(f), o.every(function(p) {
          return p.length;
        })) {
          var d = o.map(function(p) {
            return p.shift();
          });
          i.next(r ? r.apply(void 0, __spreadArray$c([], __read$c(d))) : d), o.some(function(p, g) {
            return !p.length && a[g];
          }) && i.complete();
        }
      }, function() {
        a[u] = !0, !o[u].length && i.complete();
      }));
    }, l = 0; !i.closed && l < n.length; l++)
      c(l);
    return function() {
      o = a = null;
    };
  }) : empty_1$3.EMPTY;
}
zip$3.zip = zip$2;
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: !0 });
var audit$1 = {};
Object.defineProperty(audit$1, "__esModule", { value: !0 });
audit$1.audit = void 0;
var lift_1$Z = lift, innerFrom_1$f = innerFrom$1, OperatorSubscriber_1$K = OperatorSubscriber$1;
function audit(t) {
  return lift_1$Z.operate(function(e, r) {
    var n = !1, i = null, o = null, a = !1, c = function() {
      if (o == null || o.unsubscribe(), o = null, n) {
        n = !1;
        var u = i;
        i = null, r.next(u);
      }
      a && r.complete();
    }, l = function() {
      o = null, a && r.complete();
    };
    e.subscribe(OperatorSubscriber_1$K.createOperatorSubscriber(r, function(u) {
      n = !0, i = u, o || innerFrom_1$f.innerFrom(t(u)).subscribe(o = OperatorSubscriber_1$K.createOperatorSubscriber(r, c, l));
    }, function() {
      a = !0, (!n || !o || o.closed) && r.complete();
    }));
  });
}
audit$1.audit = audit;
var auditTime$1 = {};
Object.defineProperty(auditTime$1, "__esModule", { value: !0 });
auditTime$1.auditTime = void 0;
var async_1$8 = async, audit_1 = audit$1, timer_1$4 = timer$1;
function auditTime(t, e) {
  return e === void 0 && (e = async_1$8.asyncScheduler), audit_1.audit(function() {
    return timer_1$4.timer(t, e);
  });
}
auditTime$1.auditTime = auditTime;
var buffer$1 = {};
Object.defineProperty(buffer$1, "__esModule", { value: !0 });
buffer$1.buffer = void 0;
var lift_1$Y = lift, noop_1$b = noop$1, OperatorSubscriber_1$J = OperatorSubscriber$1;
function buffer(t) {
  return lift_1$Y.operate(function(e, r) {
    var n = [];
    return e.subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(r, function(i) {
      return n.push(i);
    }, function() {
      r.next(n), r.complete();
    })), t.subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(r, function() {
      var i = n;
      n = [], r.next(i);
    }, noop_1$b.noop)), function() {
      n = null;
    };
  });
}
buffer$1.buffer = buffer;
var bufferCount$1 = {}, __values$5 = commonjsGlobal && commonjsGlobal.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferCount$1, "__esModule", { value: !0 });
bufferCount$1.bufferCount = void 0;
var lift_1$X = lift, OperatorSubscriber_1$I = OperatorSubscriber$1, arrRemove_1$4 = arrRemove$1;
function bufferCount(t, e) {
  return e === void 0 && (e = null), e = e ?? t, lift_1$X.operate(function(r, n) {
    var i = [], o = 0;
    r.subscribe(OperatorSubscriber_1$I.createOperatorSubscriber(n, function(a) {
      var c, l, u, f, d = null;
      o++ % e === 0 && i.push([]);
      try {
        for (var p = __values$5(i), g = p.next(); !g.done; g = p.next()) {
          var h = g.value;
          h.push(a), t <= h.length && (d = d ?? [], d.push(h));
        }
      } catch (b) {
        c = { error: b };
      } finally {
        try {
          g && !g.done && (l = p.return) && l.call(p);
        } finally {
          if (c)
            throw c.error;
        }
      }
      if (d)
        try {
          for (var m = __values$5(d), y = m.next(); !y.done; y = m.next()) {
            var h = y.value;
            arrRemove_1$4.arrRemove(i, h), n.next(h);
          }
        } catch (b) {
          u = { error: b };
        } finally {
          try {
            y && !y.done && (f = m.return) && f.call(m);
          } finally {
            if (u)
              throw u.error;
          }
        }
    }, function() {
      var a, c;
      try {
        for (var l = __values$5(i), u = l.next(); !u.done; u = l.next()) {
          var f = u.value;
          n.next(f);
        }
      } catch (d) {
        a = { error: d };
      } finally {
        try {
          u && !u.done && (c = l.return) && c.call(l);
        } finally {
          if (a)
            throw a.error;
        }
      }
      n.complete();
    }, void 0, function() {
      i = null;
    }));
  });
}
bufferCount$1.bufferCount = bufferCount;
var bufferTime$1 = {}, __values$4 = commonjsGlobal && commonjsGlobal.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferTime$1, "__esModule", { value: !0 });
bufferTime$1.bufferTime = void 0;
var Subscription_1$3 = Subscription$2, lift_1$W = lift, OperatorSubscriber_1$H = OperatorSubscriber$1, arrRemove_1$3 = arrRemove$1, async_1$7 = async, args_1$6 = args, executeSchedule_1$1 = executeSchedule$1;
function bufferTime(t) {
  for (var e, r, n = [], i = 1; i < arguments.length; i++)
    n[i - 1] = arguments[i];
  var o = (e = args_1$6.popScheduler(n)) !== null && e !== void 0 ? e : async_1$7.asyncScheduler, a = (r = n[0]) !== null && r !== void 0 ? r : null, c = n[1] || 1 / 0;
  return lift_1$W.operate(function(l, u) {
    var f = [], d = !1, p = function(m) {
      var y = m.buffer, b = m.subs;
      b.unsubscribe(), arrRemove_1$3.arrRemove(f, m), u.next(y), d && g();
    }, g = function() {
      if (f) {
        var m = new Subscription_1$3.Subscription();
        u.add(m);
        var y = [], b = {
          buffer: y,
          subs: m
        };
        f.push(b), executeSchedule_1$1.executeSchedule(m, o, function() {
          return p(b);
        }, t);
      }
    };
    a !== null && a >= 0 ? executeSchedule_1$1.executeSchedule(u, o, g, a, !0) : d = !0, g();
    var h = OperatorSubscriber_1$H.createOperatorSubscriber(u, function(m) {
      var y, b, v = f.slice();
      try {
        for (var _ = __values$4(v), E = _.next(); !E.done; E = _.next()) {
          var w = E.value, S = w.buffer;
          S.push(m), c <= S.length && p(w);
        }
      } catch (x) {
        y = { error: x };
      } finally {
        try {
          E && !E.done && (b = _.return) && b.call(_);
        } finally {
          if (y)
            throw y.error;
        }
      }
    }, function() {
      for (; f != null && f.length; )
        u.next(f.shift().buffer);
      h == null || h.unsubscribe(), u.complete(), u.unsubscribe();
    }, void 0, function() {
      return f = null;
    });
    l.subscribe(h);
  });
}
bufferTime$1.bufferTime = bufferTime;
var bufferToggle$1 = {}, __values$3 = commonjsGlobal && commonjsGlobal.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferToggle$1, "__esModule", { value: !0 });
bufferToggle$1.bufferToggle = void 0;
var Subscription_1$2 = Subscription$2, lift_1$V = lift, innerFrom_1$e = innerFrom$1, OperatorSubscriber_1$G = OperatorSubscriber$1, noop_1$a = noop$1, arrRemove_1$2 = arrRemove$1;
function bufferToggle(t, e) {
  return lift_1$V.operate(function(r, n) {
    var i = [];
    innerFrom_1$e.innerFrom(t).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(n, function(o) {
      var a = [];
      i.push(a);
      var c = new Subscription_1$2.Subscription(), l = function() {
        arrRemove_1$2.arrRemove(i, a), n.next(a), c.unsubscribe();
      };
      c.add(innerFrom_1$e.innerFrom(e(o)).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(n, l, noop_1$a.noop)));
    }, noop_1$a.noop)), r.subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(n, function(o) {
      var a, c;
      try {
        for (var l = __values$3(i), u = l.next(); !u.done; u = l.next()) {
          var f = u.value;
          f.push(o);
        }
      } catch (d) {
        a = { error: d };
      } finally {
        try {
          u && !u.done && (c = l.return) && c.call(l);
        } finally {
          if (a)
            throw a.error;
        }
      }
    }, function() {
      for (; i.length > 0; )
        n.next(i.shift());
      n.complete();
    }));
  });
}
bufferToggle$1.bufferToggle = bufferToggle;
var bufferWhen$1 = {};
Object.defineProperty(bufferWhen$1, "__esModule", { value: !0 });
bufferWhen$1.bufferWhen = void 0;
var lift_1$U = lift, noop_1$9 = noop$1, OperatorSubscriber_1$F = OperatorSubscriber$1, innerFrom_1$d = innerFrom$1;
function bufferWhen(t) {
  return lift_1$U.operate(function(e, r) {
    var n = null, i = null, o = function() {
      i == null || i.unsubscribe();
      var a = n;
      n = [], a && r.next(a), innerFrom_1$d.innerFrom(t()).subscribe(i = OperatorSubscriber_1$F.createOperatorSubscriber(r, o, noop_1$9.noop));
    };
    o(), e.subscribe(OperatorSubscriber_1$F.createOperatorSubscriber(r, function(a) {
      return n == null ? void 0 : n.push(a);
    }, function() {
      n && r.next(n), r.complete();
    }, void 0, function() {
      return n = i = null;
    }));
  });
}
bufferWhen$1.bufferWhen = bufferWhen;
var catchError$1 = {};
Object.defineProperty(catchError$1, "__esModule", { value: !0 });
catchError$1.catchError = void 0;
var innerFrom_1$c = innerFrom$1, OperatorSubscriber_1$E = OperatorSubscriber$1, lift_1$T = lift;
function catchError(t) {
  return lift_1$T.operate(function(e, r) {
    var n = null, i = !1, o;
    n = e.subscribe(OperatorSubscriber_1$E.createOperatorSubscriber(r, void 0, void 0, function(a) {
      o = innerFrom_1$c.innerFrom(t(a, catchError(t)(e))), n ? (n.unsubscribe(), n = null, o.subscribe(r)) : i = !0;
    })), i && (n.unsubscribe(), n = null, o.subscribe(r));
  });
}
catchError$1.catchError = catchError;
var combineAll = {}, combineLatestAll$1 = {}, joinAllInternals$1 = {}, toArray$1 = {}, reduce$1 = {}, scanInternals$1 = {};
Object.defineProperty(scanInternals$1, "__esModule", { value: !0 });
scanInternals$1.scanInternals = void 0;
var OperatorSubscriber_1$D = OperatorSubscriber$1;
function scanInternals(t, e, r, n, i) {
  return function(o, a) {
    var c = r, l = e, u = 0;
    o.subscribe(OperatorSubscriber_1$D.createOperatorSubscriber(a, function(f) {
      var d = u++;
      l = c ? t(l, f, d) : (c = !0, f), n && a.next(l);
    }, i && function() {
      c && a.next(l), a.complete();
    }));
  };
}
scanInternals$1.scanInternals = scanInternals;
Object.defineProperty(reduce$1, "__esModule", { value: !0 });
reduce$1.reduce = void 0;
var scanInternals_1$1 = scanInternals$1, lift_1$S = lift;
function reduce(t, e) {
  return lift_1$S.operate(scanInternals_1$1.scanInternals(t, e, arguments.length >= 2, !1, !0));
}
reduce$1.reduce = reduce;
Object.defineProperty(toArray$1, "__esModule", { value: !0 });
toArray$1.toArray = void 0;
var reduce_1$3 = reduce$1, lift_1$R = lift, arrReducer = function(t, e) {
  return t.push(e), t;
};
function toArray() {
  return lift_1$R.operate(function(t, e) {
    reduce_1$3.reduce(arrReducer, [])(t).subscribe(e);
  });
}
toArray$1.toArray = toArray;
Object.defineProperty(joinAllInternals$1, "__esModule", { value: !0 });
joinAllInternals$1.joinAllInternals = void 0;
var identity_1$9 = identity$1, mapOneOrManyArgs_1$1 = mapOneOrManyArgs$1, pipe_1$1 = pipe$1, mergeMap_1$4 = mergeMap$1, toArray_1 = toArray$1;
function joinAllInternals(t, e) {
  return pipe_1$1.pipe(toArray_1.toArray(), mergeMap_1$4.mergeMap(function(r) {
    return t(r);
  }), e ? mapOneOrManyArgs_1$1.mapOneOrManyArgs(e) : identity_1$9.identity);
}
joinAllInternals$1.joinAllInternals = joinAllInternals;
Object.defineProperty(combineLatestAll$1, "__esModule", { value: !0 });
combineLatestAll$1.combineLatestAll = void 0;
var combineLatest_1$2 = combineLatest$3, joinAllInternals_1$1 = joinAllInternals$1;
function combineLatestAll(t) {
  return joinAllInternals_1$1.joinAllInternals(combineLatest_1$2.combineLatest, t);
}
combineLatestAll$1.combineLatestAll = combineLatestAll;
Object.defineProperty(combineAll, "__esModule", { value: !0 });
combineAll.combineAll = void 0;
var combineLatestAll_1 = combineLatestAll$1;
combineAll.combineAll = combineLatestAll_1.combineLatestAll;
var combineLatestWith$1 = {}, combineLatest$1 = {}, __read$b = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$b = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(combineLatest$1, "__esModule", { value: !0 });
combineLatest$1.combineLatest = void 0;
var combineLatest_1$1 = combineLatest$3, lift_1$Q = lift, argsOrArgArray_1$1 = argsOrArgArray$1, mapOneOrManyArgs_1 = mapOneOrManyArgs$1, pipe_1 = pipe$1, args_1$5 = args;
function combineLatest() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1$5.popResultSelector(t);
  return r ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray$b([], __read$b(t))), mapOneOrManyArgs_1.mapOneOrManyArgs(r)) : lift_1$Q.operate(function(n, i) {
    combineLatest_1$1.combineLatestInit(__spreadArray$b([n], __read$b(argsOrArgArray_1$1.argsOrArgArray(t))))(i);
  });
}
combineLatest$1.combineLatest = combineLatest;
var __read$a = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$a = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(combineLatestWith$1, "__esModule", { value: !0 });
combineLatestWith$1.combineLatestWith = void 0;
var combineLatest_1 = combineLatest$1;
function combineLatestWith() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return combineLatest_1.combineLatest.apply(void 0, __spreadArray$a([], __read$a(t)));
}
combineLatestWith$1.combineLatestWith = combineLatestWith;
var concatMap$1 = {};
Object.defineProperty(concatMap$1, "__esModule", { value: !0 });
concatMap$1.concatMap = void 0;
var mergeMap_1$3 = mergeMap$1, isFunction_1$8 = isFunction$1;
function concatMap(t, e) {
  return isFunction_1$8.isFunction(e) ? mergeMap_1$3.mergeMap(t, e, 1) : mergeMap_1$3.mergeMap(t, 1);
}
concatMap$1.concatMap = concatMap;
var concatMapTo$1 = {};
Object.defineProperty(concatMapTo$1, "__esModule", { value: !0 });
concatMapTo$1.concatMapTo = void 0;
var concatMap_1 = concatMap$1, isFunction_1$7 = isFunction$1;
function concatMapTo(t, e) {
  return isFunction_1$7.isFunction(e) ? concatMap_1.concatMap(function() {
    return t;
  }, e) : concatMap_1.concatMap(function() {
    return t;
  });
}
concatMapTo$1.concatMapTo = concatMapTo;
var concatWith$1 = {}, concat$1 = {}, __read$9 = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$9 = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(concat$1, "__esModule", { value: !0 });
concat$1.concat = void 0;
var lift_1$P = lift, concatAll_1 = concatAll$1, args_1$4 = args, from_1$3 = from$1;
function concat() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1$4.popScheduler(t);
  return lift_1$P.operate(function(n, i) {
    concatAll_1.concatAll()(from_1$3.from(__spreadArray$9([n], __read$9(t)), r)).subscribe(i);
  });
}
concat$1.concat = concat;
var __read$8 = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$8 = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(concatWith$1, "__esModule", { value: !0 });
concatWith$1.concatWith = void 0;
var concat_1$3 = concat$1;
function concatWith() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return concat_1$3.concat.apply(void 0, __spreadArray$8([], __read$8(t)));
}
concatWith$1.concatWith = concatWith;
var connect$1 = {}, fromSubscribable$1 = {};
Object.defineProperty(fromSubscribable$1, "__esModule", { value: !0 });
fromSubscribable$1.fromSubscribable = void 0;
var Observable_1$1 = Observable$3;
function fromSubscribable(t) {
  return new Observable_1$1.Observable(function(e) {
    return t.subscribe(e);
  });
}
fromSubscribable$1.fromSubscribable = fromSubscribable;
Object.defineProperty(connect$1, "__esModule", { value: !0 });
connect$1.connect = void 0;
var Subject_1$a = Subject$2, from_1$2 = from$1, lift_1$O = lift, fromSubscribable_1 = fromSubscribable$1, DEFAULT_CONFIG = {
  connector: function() {
    return new Subject_1$a.Subject();
  }
};
function connect(t, e) {
  e === void 0 && (e = DEFAULT_CONFIG);
  var r = e.connector;
  return lift_1$O.operate(function(n, i) {
    var o = r();
    from_1$2.from(t(fromSubscribable_1.fromSubscribable(o))).subscribe(i), i.add(n.subscribe(o));
  });
}
connect$1.connect = connect;
var count$1 = {};
Object.defineProperty(count$1, "__esModule", { value: !0 });
count$1.count = void 0;
var reduce_1$2 = reduce$1;
function count(t) {
  return reduce_1$2.reduce(function(e, r, n) {
    return !t || t(r, n) ? e + 1 : e;
  }, 0);
}
count$1.count = count;
var debounce$1 = {};
Object.defineProperty(debounce$1, "__esModule", { value: !0 });
debounce$1.debounce = void 0;
var lift_1$N = lift, noop_1$8 = noop$1, OperatorSubscriber_1$C = OperatorSubscriber$1, innerFrom_1$b = innerFrom$1;
function debounce(t) {
  return lift_1$N.operate(function(e, r) {
    var n = !1, i = null, o = null, a = function() {
      if (o == null || o.unsubscribe(), o = null, n) {
        n = !1;
        var c = i;
        i = null, r.next(c);
      }
    };
    e.subscribe(OperatorSubscriber_1$C.createOperatorSubscriber(r, function(c) {
      o == null || o.unsubscribe(), n = !0, i = c, o = OperatorSubscriber_1$C.createOperatorSubscriber(r, a, noop_1$8.noop), innerFrom_1$b.innerFrom(t(c)).subscribe(o);
    }, function() {
      a(), r.complete();
    }, void 0, function() {
      i = o = null;
    }));
  });
}
debounce$1.debounce = debounce;
var debounceTime$1 = {};
Object.defineProperty(debounceTime$1, "__esModule", { value: !0 });
debounceTime$1.debounceTime = void 0;
var async_1$6 = async, lift_1$M = lift, OperatorSubscriber_1$B = OperatorSubscriber$1;
function debounceTime(t, e) {
  return e === void 0 && (e = async_1$6.asyncScheduler), lift_1$M.operate(function(r, n) {
    var i = null, o = null, a = null, c = function() {
      if (i) {
        i.unsubscribe(), i = null;
        var u = o;
        o = null, n.next(u);
      }
    };
    function l() {
      var u = a + t, f = e.now();
      if (f < u) {
        i = this.schedule(void 0, u - f), n.add(i);
        return;
      }
      c();
    }
    r.subscribe(OperatorSubscriber_1$B.createOperatorSubscriber(n, function(u) {
      o = u, a = e.now(), i || (i = e.schedule(l, t), n.add(i));
    }, function() {
      c(), n.complete();
    }, void 0, function() {
      o = i = null;
    }));
  });
}
debounceTime$1.debounceTime = debounceTime;
var defaultIfEmpty$1 = {};
Object.defineProperty(defaultIfEmpty$1, "__esModule", { value: !0 });
defaultIfEmpty$1.defaultIfEmpty = void 0;
var lift_1$L = lift, OperatorSubscriber_1$A = OperatorSubscriber$1;
function defaultIfEmpty(t) {
  return lift_1$L.operate(function(e, r) {
    var n = !1;
    e.subscribe(OperatorSubscriber_1$A.createOperatorSubscriber(r, function(i) {
      n = !0, r.next(i);
    }, function() {
      n || r.next(t), r.complete();
    }));
  });
}
defaultIfEmpty$1.defaultIfEmpty = defaultIfEmpty;
var delay$1 = {}, delayWhen$1 = {}, take$1 = {};
Object.defineProperty(take$1, "__esModule", { value: !0 });
take$1.take = void 0;
var empty_1$2 = empty, lift_1$K = lift, OperatorSubscriber_1$z = OperatorSubscriber$1;
function take(t) {
  return t <= 0 ? function() {
    return empty_1$2.EMPTY;
  } : lift_1$K.operate(function(e, r) {
    var n = 0;
    e.subscribe(OperatorSubscriber_1$z.createOperatorSubscriber(r, function(i) {
      ++n <= t && (r.next(i), t <= n && r.complete());
    }));
  });
}
take$1.take = take;
var ignoreElements$1 = {};
Object.defineProperty(ignoreElements$1, "__esModule", { value: !0 });
ignoreElements$1.ignoreElements = void 0;
var lift_1$J = lift, OperatorSubscriber_1$y = OperatorSubscriber$1, noop_1$7 = noop$1;
function ignoreElements() {
  return lift_1$J.operate(function(t, e) {
    t.subscribe(OperatorSubscriber_1$y.createOperatorSubscriber(e, noop_1$7.noop));
  });
}
ignoreElements$1.ignoreElements = ignoreElements;
var mapTo$1 = {};
Object.defineProperty(mapTo$1, "__esModule", { value: !0 });
mapTo$1.mapTo = void 0;
var map_1$3 = map$1;
function mapTo(t) {
  return map_1$3.map(function() {
    return t;
  });
}
mapTo$1.mapTo = mapTo;
Object.defineProperty(delayWhen$1, "__esModule", { value: !0 });
delayWhen$1.delayWhen = void 0;
var concat_1$2 = concat$3, take_1$3 = take$1, ignoreElements_1 = ignoreElements$1, mapTo_1 = mapTo$1, mergeMap_1$2 = mergeMap$1;
function delayWhen(t, e) {
  return e ? function(r) {
    return concat_1$2.concat(e.pipe(take_1$3.take(1), ignoreElements_1.ignoreElements()), r.pipe(delayWhen(t)));
  } : mergeMap_1$2.mergeMap(function(r, n) {
    return t(r, n).pipe(take_1$3.take(1), mapTo_1.mapTo(r));
  });
}
delayWhen$1.delayWhen = delayWhen;
Object.defineProperty(delay$1, "__esModule", { value: !0 });
delay$1.delay = void 0;
var async_1$5 = async, delayWhen_1 = delayWhen$1, timer_1$3 = timer$1;
function delay(t, e) {
  e === void 0 && (e = async_1$5.asyncScheduler);
  var r = timer_1$3.timer(t, e);
  return delayWhen_1.delayWhen(function() {
    return r;
  });
}
delay$1.delay = delay;
var dematerialize$1 = {};
Object.defineProperty(dematerialize$1, "__esModule", { value: !0 });
dematerialize$1.dematerialize = void 0;
var Notification_1$1 = Notification, lift_1$I = lift, OperatorSubscriber_1$x = OperatorSubscriber$1;
function dematerialize() {
  return lift_1$I.operate(function(t, e) {
    t.subscribe(OperatorSubscriber_1$x.createOperatorSubscriber(e, function(r) {
      return Notification_1$1.observeNotification(r, e);
    }));
  });
}
dematerialize$1.dematerialize = dematerialize;
var distinct$1 = {};
Object.defineProperty(distinct$1, "__esModule", { value: !0 });
distinct$1.distinct = void 0;
var lift_1$H = lift, OperatorSubscriber_1$w = OperatorSubscriber$1, noop_1$6 = noop$1;
function distinct(t, e) {
  return lift_1$H.operate(function(r, n) {
    var i = /* @__PURE__ */ new Set();
    r.subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(n, function(o) {
      var a = t ? t(o) : o;
      i.has(a) || (i.add(a), n.next(o));
    })), e == null || e.subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(n, function() {
      return i.clear();
    }, noop_1$6.noop));
  });
}
distinct$1.distinct = distinct;
var distinctUntilChanged$1 = {};
Object.defineProperty(distinctUntilChanged$1, "__esModule", { value: !0 });
distinctUntilChanged$1.distinctUntilChanged = void 0;
var identity_1$8 = identity$1, lift_1$G = lift, OperatorSubscriber_1$v = OperatorSubscriber$1;
function distinctUntilChanged(t, e) {
  return e === void 0 && (e = identity_1$8.identity), t = t ?? defaultCompare, lift_1$G.operate(function(r, n) {
    var i, o = !0;
    r.subscribe(OperatorSubscriber_1$v.createOperatorSubscriber(n, function(a) {
      var c = e(a);
      (o || !t(i, c)) && (o = !1, i = c, n.next(a));
    }));
  });
}
distinctUntilChanged$1.distinctUntilChanged = distinctUntilChanged;
function defaultCompare(t, e) {
  return t === e;
}
var distinctUntilKeyChanged$1 = {};
Object.defineProperty(distinctUntilKeyChanged$1, "__esModule", { value: !0 });
distinctUntilKeyChanged$1.distinctUntilKeyChanged = void 0;
var distinctUntilChanged_1 = distinctUntilChanged$1;
function distinctUntilKeyChanged(t, e) {
  return distinctUntilChanged_1.distinctUntilChanged(function(r, n) {
    return e ? e(r[t], n[t]) : r[t] === n[t];
  });
}
distinctUntilKeyChanged$1.distinctUntilKeyChanged = distinctUntilKeyChanged;
var elementAt$1 = {}, throwIfEmpty$1 = {};
Object.defineProperty(throwIfEmpty$1, "__esModule", { value: !0 });
throwIfEmpty$1.throwIfEmpty = void 0;
var EmptyError_1$3 = EmptyError, lift_1$F = lift, OperatorSubscriber_1$u = OperatorSubscriber$1;
function throwIfEmpty(t) {
  return t === void 0 && (t = defaultErrorFactory), lift_1$F.operate(function(e, r) {
    var n = !1;
    e.subscribe(OperatorSubscriber_1$u.createOperatorSubscriber(r, function(i) {
      n = !0, r.next(i);
    }, function() {
      return n ? r.complete() : r.error(t());
    }));
  });
}
throwIfEmpty$1.throwIfEmpty = throwIfEmpty;
function defaultErrorFactory() {
  return new EmptyError_1$3.EmptyError();
}
Object.defineProperty(elementAt$1, "__esModule", { value: !0 });
elementAt$1.elementAt = void 0;
var ArgumentOutOfRangeError_1 = ArgumentOutOfRangeError, filter_1$3 = filter$1, throwIfEmpty_1$2 = throwIfEmpty$1, defaultIfEmpty_1$2 = defaultIfEmpty$1, take_1$2 = take$1;
function elementAt(t, e) {
  if (t < 0)
    throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
  var r = arguments.length >= 2;
  return function(n) {
    return n.pipe(filter_1$3.filter(function(i, o) {
      return o === t;
    }), take_1$2.take(1), r ? defaultIfEmpty_1$2.defaultIfEmpty(e) : throwIfEmpty_1$2.throwIfEmpty(function() {
      return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }));
  };
}
elementAt$1.elementAt = elementAt;
var endWith$1 = {}, __read$7 = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$7 = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(endWith$1, "__esModule", { value: !0 });
endWith$1.endWith = void 0;
var concat_1$1 = concat$3, of_1 = of$1;
function endWith() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return function(r) {
    return concat_1$1.concat(r, of_1.of.apply(void 0, __spreadArray$7([], __read$7(t))));
  };
}
endWith$1.endWith = endWith;
var every$1 = {};
Object.defineProperty(every$1, "__esModule", { value: !0 });
every$1.every = void 0;
var lift_1$E = lift, OperatorSubscriber_1$t = OperatorSubscriber$1;
function every(t, e) {
  return lift_1$E.operate(function(r, n) {
    var i = 0;
    r.subscribe(OperatorSubscriber_1$t.createOperatorSubscriber(n, function(o) {
      t.call(e, o, i++, r) || (n.next(!1), n.complete());
    }, function() {
      n.next(!0), n.complete();
    }));
  });
}
every$1.every = every;
var exhaust = {}, exhaustAll$1 = {};
Object.defineProperty(exhaustAll$1, "__esModule", { value: !0 });
exhaustAll$1.exhaustAll = void 0;
var lift_1$D = lift, innerFrom_1$a = innerFrom$1, OperatorSubscriber_1$s = OperatorSubscriber$1;
function exhaustAll() {
  return lift_1$D.operate(function(t, e) {
    var r = !1, n = null;
    t.subscribe(OperatorSubscriber_1$s.createOperatorSubscriber(e, function(i) {
      n || (n = innerFrom_1$a.innerFrom(i).subscribe(OperatorSubscriber_1$s.createOperatorSubscriber(e, void 0, function() {
        n = null, r && e.complete();
      })));
    }, function() {
      r = !0, !n && e.complete();
    }));
  });
}
exhaustAll$1.exhaustAll = exhaustAll;
Object.defineProperty(exhaust, "__esModule", { value: !0 });
exhaust.exhaust = void 0;
var exhaustAll_1 = exhaustAll$1;
exhaust.exhaust = exhaustAll_1.exhaustAll;
var exhaustMap$1 = {};
Object.defineProperty(exhaustMap$1, "__esModule", { value: !0 });
exhaustMap$1.exhaustMap = void 0;
var map_1$2 = map$1, innerFrom_1$9 = innerFrom$1, lift_1$C = lift, OperatorSubscriber_1$r = OperatorSubscriber$1;
function exhaustMap(t, e) {
  return e ? function(r) {
    return r.pipe(exhaustMap(function(n, i) {
      return innerFrom_1$9.innerFrom(t(n, i)).pipe(map_1$2.map(function(o, a) {
        return e(n, o, i, a);
      }));
    }));
  } : lift_1$C.operate(function(r, n) {
    var i = 0, o = null, a = !1;
    r.subscribe(OperatorSubscriber_1$r.createOperatorSubscriber(n, function(c) {
      o || (o = OperatorSubscriber_1$r.createOperatorSubscriber(n, void 0, function() {
        o = null, a && n.complete();
      }), innerFrom_1$9.innerFrom(t(c, i++)).subscribe(o));
    }, function() {
      a = !0, !o && n.complete();
    }));
  });
}
exhaustMap$1.exhaustMap = exhaustMap;
var expand$1 = {};
Object.defineProperty(expand$1, "__esModule", { value: !0 });
expand$1.expand = void 0;
var lift_1$B = lift, mergeInternals_1$1 = mergeInternals$1;
function expand(t, e, r) {
  return e === void 0 && (e = 1 / 0), e = (e || 0) < 1 ? 1 / 0 : e, lift_1$B.operate(function(n, i) {
    return mergeInternals_1$1.mergeInternals(n, i, t, e, void 0, !0, r);
  });
}
expand$1.expand = expand;
var finalize$1 = {};
Object.defineProperty(finalize$1, "__esModule", { value: !0 });
finalize$1.finalize = void 0;
var lift_1$A = lift;
function finalize(t) {
  return lift_1$A.operate(function(e, r) {
    try {
      e.subscribe(r);
    } finally {
      r.add(t);
    }
  });
}
finalize$1.finalize = finalize;
var find$1 = {};
Object.defineProperty(find$1, "__esModule", { value: !0 });
find$1.createFind = find$1.find = void 0;
var lift_1$z = lift, OperatorSubscriber_1$q = OperatorSubscriber$1;
function find(t, e) {
  return lift_1$z.operate(createFind(t, e, "value"));
}
find$1.find = find;
function createFind(t, e, r) {
  var n = r === "index";
  return function(i, o) {
    var a = 0;
    i.subscribe(OperatorSubscriber_1$q.createOperatorSubscriber(o, function(c) {
      var l = a++;
      t.call(e, c, l, i) && (o.next(n ? l : c), o.complete());
    }, function() {
      o.next(n ? -1 : void 0), o.complete();
    }));
  };
}
find$1.createFind = createFind;
var findIndex$1 = {};
Object.defineProperty(findIndex$1, "__esModule", { value: !0 });
findIndex$1.findIndex = void 0;
var lift_1$y = lift, find_1 = find$1;
function findIndex(t, e) {
  return lift_1$y.operate(find_1.createFind(t, e, "index"));
}
findIndex$1.findIndex = findIndex;
var first$1 = {};
Object.defineProperty(first$1, "__esModule", { value: !0 });
first$1.first = void 0;
var EmptyError_1$2 = EmptyError, filter_1$2 = filter$1, take_1$1 = take$1, defaultIfEmpty_1$1 = defaultIfEmpty$1, throwIfEmpty_1$1 = throwIfEmpty$1, identity_1$7 = identity$1;
function first(t, e) {
  var r = arguments.length >= 2;
  return function(n) {
    return n.pipe(t ? filter_1$2.filter(function(i, o) {
      return t(i, o, n);
    }) : identity_1$7.identity, take_1$1.take(1), r ? defaultIfEmpty_1$1.defaultIfEmpty(e) : throwIfEmpty_1$1.throwIfEmpty(function() {
      return new EmptyError_1$2.EmptyError();
    }));
  };
}
first$1.first = first;
var groupBy$1 = {};
Object.defineProperty(groupBy$1, "__esModule", { value: !0 });
groupBy$1.groupBy = void 0;
var Observable_1 = Observable$3, innerFrom_1$8 = innerFrom$1, Subject_1$9 = Subject$2, lift_1$x = lift, OperatorSubscriber_1$p = OperatorSubscriber$1;
function groupBy(t, e, r, n) {
  return lift_1$x.operate(function(i, o) {
    var a;
    !e || typeof e == "function" ? a = e : (r = e.duration, a = e.element, n = e.connector);
    var c = /* @__PURE__ */ new Map(), l = function(h) {
      c.forEach(h), h(o);
    }, u = function(h) {
      return l(function(m) {
        return m.error(h);
      });
    }, f = 0, d = !1, p = new OperatorSubscriber_1$p.OperatorSubscriber(o, function(h) {
      try {
        var m = t(h), y = c.get(m);
        if (!y) {
          c.set(m, y = n ? n() : new Subject_1$9.Subject());
          var b = g(m, y);
          if (o.next(b), r) {
            var v = OperatorSubscriber_1$p.createOperatorSubscriber(y, function() {
              y.complete(), v == null || v.unsubscribe();
            }, void 0, void 0, function() {
              return c.delete(m);
            });
            p.add(innerFrom_1$8.innerFrom(r(b)).subscribe(v));
          }
        }
        y.next(a ? a(h) : h);
      } catch (_) {
        u(_);
      }
    }, function() {
      return l(function(h) {
        return h.complete();
      });
    }, u, function() {
      return c.clear();
    }, function() {
      return d = !0, f === 0;
    });
    i.subscribe(p);
    function g(h, m) {
      var y = new Observable_1.Observable(function(b) {
        f++;
        var v = m.subscribe(b);
        return function() {
          v.unsubscribe(), --f === 0 && d && p.unsubscribe();
        };
      });
      return y.key = h, y;
    }
  });
}
groupBy$1.groupBy = groupBy;
var isEmpty$1 = {};
Object.defineProperty(isEmpty$1, "__esModule", { value: !0 });
isEmpty$1.isEmpty = void 0;
var lift_1$w = lift, OperatorSubscriber_1$o = OperatorSubscriber$1;
function isEmpty() {
  return lift_1$w.operate(function(t, e) {
    t.subscribe(OperatorSubscriber_1$o.createOperatorSubscriber(e, function() {
      e.next(!1), e.complete();
    }, function() {
      e.next(!0), e.complete();
    }));
  });
}
isEmpty$1.isEmpty = isEmpty;
var last$1 = {}, takeLast$1 = {}, __values$2 = commonjsGlobal && commonjsGlobal.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(takeLast$1, "__esModule", { value: !0 });
takeLast$1.takeLast = void 0;
var empty_1$1 = empty, lift_1$v = lift, OperatorSubscriber_1$n = OperatorSubscriber$1;
function takeLast(t) {
  return t <= 0 ? function() {
    return empty_1$1.EMPTY;
  } : lift_1$v.operate(function(e, r) {
    var n = [];
    e.subscribe(OperatorSubscriber_1$n.createOperatorSubscriber(r, function(i) {
      n.push(i), t < n.length && n.shift();
    }, function() {
      var i, o;
      try {
        for (var a = __values$2(n), c = a.next(); !c.done; c = a.next()) {
          var l = c.value;
          r.next(l);
        }
      } catch (u) {
        i = { error: u };
      } finally {
        try {
          c && !c.done && (o = a.return) && o.call(a);
        } finally {
          if (i)
            throw i.error;
        }
      }
      r.complete();
    }, void 0, function() {
      n = null;
    }));
  });
}
takeLast$1.takeLast = takeLast;
Object.defineProperty(last$1, "__esModule", { value: !0 });
last$1.last = void 0;
var EmptyError_1$1 = EmptyError, filter_1$1 = filter$1, takeLast_1 = takeLast$1, throwIfEmpty_1 = throwIfEmpty$1, defaultIfEmpty_1 = defaultIfEmpty$1, identity_1$6 = identity$1;
function last(t, e) {
  var r = arguments.length >= 2;
  return function(n) {
    return n.pipe(t ? filter_1$1.filter(function(i, o) {
      return t(i, o, n);
    }) : identity_1$6.identity, takeLast_1.takeLast(1), r ? defaultIfEmpty_1.defaultIfEmpty(e) : throwIfEmpty_1.throwIfEmpty(function() {
      return new EmptyError_1$1.EmptyError();
    }));
  };
}
last$1.last = last;
var materialize$1 = {};
Object.defineProperty(materialize$1, "__esModule", { value: !0 });
materialize$1.materialize = void 0;
var Notification_1 = Notification, lift_1$u = lift, OperatorSubscriber_1$m = OperatorSubscriber$1;
function materialize() {
  return lift_1$u.operate(function(t, e) {
    t.subscribe(OperatorSubscriber_1$m.createOperatorSubscriber(e, function(r) {
      e.next(Notification_1.Notification.createNext(r));
    }, function() {
      e.next(Notification_1.Notification.createComplete()), e.complete();
    }, function(r) {
      e.next(Notification_1.Notification.createError(r)), e.complete();
    }));
  });
}
materialize$1.materialize = materialize;
var max$1 = {};
Object.defineProperty(max$1, "__esModule", { value: !0 });
max$1.max = void 0;
var reduce_1$1 = reduce$1, isFunction_1$6 = isFunction$1;
function max(t) {
  return reduce_1$1.reduce(isFunction_1$6.isFunction(t) ? function(e, r) {
    return t(e, r) > 0 ? e : r;
  } : function(e, r) {
    return e > r ? e : r;
  });
}
max$1.max = max;
var flatMap = {};
Object.defineProperty(flatMap, "__esModule", { value: !0 });
flatMap.flatMap = void 0;
var mergeMap_1$1 = mergeMap$1;
flatMap.flatMap = mergeMap_1$1.mergeMap;
var mergeMapTo$1 = {};
Object.defineProperty(mergeMapTo$1, "__esModule", { value: !0 });
mergeMapTo$1.mergeMapTo = void 0;
var mergeMap_1 = mergeMap$1, isFunction_1$5 = isFunction$1;
function mergeMapTo(t, e, r) {
  return r === void 0 && (r = 1 / 0), isFunction_1$5.isFunction(e) ? mergeMap_1.mergeMap(function() {
    return t;
  }, e, r) : (typeof e == "number" && (r = e), mergeMap_1.mergeMap(function() {
    return t;
  }, r));
}
mergeMapTo$1.mergeMapTo = mergeMapTo;
var mergeScan$1 = {};
Object.defineProperty(mergeScan$1, "__esModule", { value: !0 });
mergeScan$1.mergeScan = void 0;
var lift_1$t = lift, mergeInternals_1 = mergeInternals$1;
function mergeScan(t, e, r) {
  return r === void 0 && (r = 1 / 0), lift_1$t.operate(function(n, i) {
    var o = e;
    return mergeInternals_1.mergeInternals(n, i, function(a, c) {
      return t(o, a, c);
    }, r, function(a) {
      o = a;
    }, !1, void 0, function() {
      return o = null;
    });
  });
}
mergeScan$1.mergeScan = mergeScan;
var mergeWith$1 = {}, merge$1 = {}, __read$6 = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$6 = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(merge$1, "__esModule", { value: !0 });
merge$1.merge = void 0;
var lift_1$s = lift, argsOrArgArray_1 = argsOrArgArray$1, mergeAll_1 = mergeAll$1, args_1$3 = args, from_1$1 = from$1;
function merge() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1$3.popScheduler(t), n = args_1$3.popNumber(t, 1 / 0);
  return t = argsOrArgArray_1.argsOrArgArray(t), lift_1$s.operate(function(i, o) {
    mergeAll_1.mergeAll(n)(from_1$1.from(__spreadArray$6([i], __read$6(t)), r)).subscribe(o);
  });
}
merge$1.merge = merge;
var __read$5 = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$5 = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(mergeWith$1, "__esModule", { value: !0 });
mergeWith$1.mergeWith = void 0;
var merge_1 = merge$1;
function mergeWith() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return merge_1.merge.apply(void 0, __spreadArray$5([], __read$5(t)));
}
mergeWith$1.mergeWith = mergeWith;
var min$1 = {};
Object.defineProperty(min$1, "__esModule", { value: !0 });
min$1.min = void 0;
var reduce_1 = reduce$1, isFunction_1$4 = isFunction$1;
function min(t) {
  return reduce_1.reduce(isFunction_1$4.isFunction(t) ? function(e, r) {
    return t(e, r) < 0 ? e : r;
  } : function(e, r) {
    return e < r ? e : r;
  });
}
min$1.min = min;
var multicast$2 = {};
Object.defineProperty(multicast$2, "__esModule", { value: !0 });
multicast$2.multicast = void 0;
var ConnectableObservable_1$2 = ConnectableObservable$1, isFunction_1$3 = isFunction$1, connect_1$1 = connect$1;
function multicast$1(t, e) {
  var r = isFunction_1$3.isFunction(t) ? t : function() {
    return t;
  };
  return isFunction_1$3.isFunction(e) ? connect_1$1.connect(e, {
    connector: r
  }) : function(n) {
    return new ConnectableObservable_1$2.ConnectableObservable(n, r);
  };
}
multicast$2.multicast = multicast$1;
var pairwise$1 = {};
Object.defineProperty(pairwise$1, "__esModule", { value: !0 });
pairwise$1.pairwise = void 0;
var lift_1$r = lift, OperatorSubscriber_1$l = OperatorSubscriber$1;
function pairwise() {
  return lift_1$r.operate(function(t, e) {
    var r, n = !1;
    t.subscribe(OperatorSubscriber_1$l.createOperatorSubscriber(e, function(i) {
      var o = r;
      r = i, n && e.next([o, i]), n = !0;
    }));
  });
}
pairwise$1.pairwise = pairwise;
var pluck$1 = {};
Object.defineProperty(pluck$1, "__esModule", { value: !0 });
pluck$1.pluck = void 0;
var map_1$1 = map$1;
function pluck() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = t.length;
  if (r === 0)
    throw new Error("list of properties cannot be empty.");
  return map_1$1.map(function(n) {
    for (var i = n, o = 0; o < r; o++) {
      var a = i == null ? void 0 : i[t[o]];
      if (typeof a < "u")
        i = a;
      else
        return;
    }
    return i;
  });
}
pluck$1.pluck = pluck;
var publish$1 = {};
Object.defineProperty(publish$1, "__esModule", { value: !0 });
publish$1.publish = void 0;
var Subject_1$8 = Subject$2, multicast_1$1 = multicast$2, connect_1 = connect$1;
function publish(t) {
  return t ? function(e) {
    return connect_1.connect(t)(e);
  } : function(e) {
    return multicast_1$1.multicast(new Subject_1$8.Subject())(e);
  };
}
publish$1.publish = publish;
var publishBehavior$1 = {};
Object.defineProperty(publishBehavior$1, "__esModule", { value: !0 });
publishBehavior$1.publishBehavior = void 0;
var BehaviorSubject_1 = BehaviorSubject$1, ConnectableObservable_1$1 = ConnectableObservable$1;
function publishBehavior(t) {
  return function(e) {
    var r = new BehaviorSubject_1.BehaviorSubject(t);
    return new ConnectableObservable_1$1.ConnectableObservable(e, function() {
      return r;
    });
  };
}
publishBehavior$1.publishBehavior = publishBehavior;
var publishLast$1 = {};
Object.defineProperty(publishLast$1, "__esModule", { value: !0 });
publishLast$1.publishLast = void 0;
var AsyncSubject_1 = AsyncSubject$1, ConnectableObservable_1 = ConnectableObservable$1;
function publishLast() {
  return function(t) {
    var e = new AsyncSubject_1.AsyncSubject();
    return new ConnectableObservable_1.ConnectableObservable(t, function() {
      return e;
    });
  };
}
publishLast$1.publishLast = publishLast;
var publishReplay$1 = {};
Object.defineProperty(publishReplay$1, "__esModule", { value: !0 });
publishReplay$1.publishReplay = void 0;
var ReplaySubject_1$1 = ReplaySubject$1, multicast_1 = multicast$2, isFunction_1$2 = isFunction$1;
function publishReplay(t, e, r, n) {
  r && !isFunction_1$2.isFunction(r) && (n = r);
  var i = isFunction_1$2.isFunction(r) ? r : void 0;
  return function(o) {
    return multicast_1.multicast(new ReplaySubject_1$1.ReplaySubject(t, e, n), i)(o);
  };
}
publishReplay$1.publishReplay = publishReplay;
var raceWith$1 = {}, __read$4 = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$4 = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(raceWith$1, "__esModule", { value: !0 });
raceWith$1.raceWith = void 0;
var race_1 = race$1, lift_1$q = lift, identity_1$5 = identity$1;
function raceWith() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return t.length ? lift_1$q.operate(function(r, n) {
    race_1.raceInit(__spreadArray$4([r], __read$4(t)))(n);
  }) : identity_1$5.identity;
}
raceWith$1.raceWith = raceWith;
var repeat$1 = {};
Object.defineProperty(repeat$1, "__esModule", { value: !0 });
repeat$1.repeat = void 0;
var empty_1 = empty, lift_1$p = lift, OperatorSubscriber_1$k = OperatorSubscriber$1, innerFrom_1$7 = innerFrom$1, timer_1$2 = timer$1;
function repeat(t) {
  var e, r = 1 / 0, n;
  return t != null && (typeof t == "object" ? (e = t.count, r = e === void 0 ? 1 / 0 : e, n = t.delay) : r = t), r <= 0 ? function() {
    return empty_1.EMPTY;
  } : lift_1$p.operate(function(i, o) {
    var a = 0, c, l = function() {
      if (c == null || c.unsubscribe(), c = null, n != null) {
        var f = typeof n == "number" ? timer_1$2.timer(n) : innerFrom_1$7.innerFrom(n(a)), d = OperatorSubscriber_1$k.createOperatorSubscriber(o, function() {
          d.unsubscribe(), u();
        });
        f.subscribe(d);
      } else
        u();
    }, u = function() {
      var f = !1;
      c = i.subscribe(OperatorSubscriber_1$k.createOperatorSubscriber(o, void 0, function() {
        ++a < r ? c ? l() : f = !0 : o.complete();
      })), f && l();
    };
    u();
  });
}
repeat$1.repeat = repeat;
var repeatWhen$1 = {};
Object.defineProperty(repeatWhen$1, "__esModule", { value: !0 });
repeatWhen$1.repeatWhen = void 0;
var Subject_1$7 = Subject$2, lift_1$o = lift, OperatorSubscriber_1$j = OperatorSubscriber$1;
function repeatWhen(t) {
  return lift_1$o.operate(function(e, r) {
    var n, i = !1, o, a = !1, c = !1, l = function() {
      return c && a && (r.complete(), !0);
    }, u = function() {
      return o || (o = new Subject_1$7.Subject(), t(o).subscribe(OperatorSubscriber_1$j.createOperatorSubscriber(r, function() {
        n ? f() : i = !0;
      }, function() {
        a = !0, l();
      }))), o;
    }, f = function() {
      c = !1, n = e.subscribe(OperatorSubscriber_1$j.createOperatorSubscriber(r, void 0, function() {
        c = !0, !l() && u().next();
      })), i && (n.unsubscribe(), n = null, i = !1, f());
    };
    f();
  });
}
repeatWhen$1.repeatWhen = repeatWhen;
var retry$1 = {};
Object.defineProperty(retry$1, "__esModule", { value: !0 });
retry$1.retry = void 0;
var lift_1$n = lift, OperatorSubscriber_1$i = OperatorSubscriber$1, identity_1$4 = identity$1, timer_1$1 = timer$1, innerFrom_1$6 = innerFrom$1;
function retry(t) {
  t === void 0 && (t = 1 / 0);
  var e;
  t && typeof t == "object" ? e = t : e = {
    count: t
  };
  var r = e.count, n = r === void 0 ? 1 / 0 : r, i = e.delay, o = e.resetOnSuccess, a = o === void 0 ? !1 : o;
  return n <= 0 ? identity_1$4.identity : lift_1$n.operate(function(c, l) {
    var u = 0, f, d = function() {
      var p = !1;
      f = c.subscribe(OperatorSubscriber_1$i.createOperatorSubscriber(l, function(g) {
        a && (u = 0), l.next(g);
      }, void 0, function(g) {
        if (u++ < n) {
          var h = function() {
            f ? (f.unsubscribe(), f = null, d()) : p = !0;
          };
          if (i != null) {
            var m = typeof i == "number" ? timer_1$1.timer(i) : innerFrom_1$6.innerFrom(i(g, u)), y = OperatorSubscriber_1$i.createOperatorSubscriber(l, function() {
              y.unsubscribe(), h();
            }, function() {
              l.complete();
            });
            m.subscribe(y);
          } else
            h();
        } else
          l.error(g);
      })), p && (f.unsubscribe(), f = null, d());
    };
    d();
  });
}
retry$1.retry = retry;
var retryWhen$1 = {};
Object.defineProperty(retryWhen$1, "__esModule", { value: !0 });
retryWhen$1.retryWhen = void 0;
var Subject_1$6 = Subject$2, lift_1$m = lift, OperatorSubscriber_1$h = OperatorSubscriber$1;
function retryWhen(t) {
  return lift_1$m.operate(function(e, r) {
    var n, i = !1, o, a = function() {
      n = e.subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(r, void 0, void 0, function(c) {
        o || (o = new Subject_1$6.Subject(), t(o).subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(r, function() {
          return n ? a() : i = !0;
        }))), o && o.next(c);
      })), i && (n.unsubscribe(), n = null, i = !1, a());
    };
    a();
  });
}
retryWhen$1.retryWhen = retryWhen;
var sample$1 = {};
Object.defineProperty(sample$1, "__esModule", { value: !0 });
sample$1.sample = void 0;
var lift_1$l = lift, noop_1$5 = noop$1, OperatorSubscriber_1$g = OperatorSubscriber$1;
function sample(t) {
  return lift_1$l.operate(function(e, r) {
    var n = !1, i = null;
    e.subscribe(OperatorSubscriber_1$g.createOperatorSubscriber(r, function(o) {
      n = !0, i = o;
    })), t.subscribe(OperatorSubscriber_1$g.createOperatorSubscriber(r, function() {
      if (n) {
        n = !1;
        var o = i;
        i = null, r.next(o);
      }
    }, noop_1$5.noop));
  });
}
sample$1.sample = sample;
var sampleTime$1 = {};
Object.defineProperty(sampleTime$1, "__esModule", { value: !0 });
sampleTime$1.sampleTime = void 0;
var async_1$4 = async, sample_1 = sample$1, interval_1 = interval$1;
function sampleTime(t, e) {
  return e === void 0 && (e = async_1$4.asyncScheduler), sample_1.sample(interval_1.interval(t, e));
}
sampleTime$1.sampleTime = sampleTime;
var scan$1 = {};
Object.defineProperty(scan$1, "__esModule", { value: !0 });
scan$1.scan = void 0;
var lift_1$k = lift, scanInternals_1 = scanInternals$1;
function scan(t, e) {
  return lift_1$k.operate(scanInternals_1.scanInternals(t, e, arguments.length >= 2, !0));
}
scan$1.scan = scan;
var sequenceEqual$1 = {};
Object.defineProperty(sequenceEqual$1, "__esModule", { value: !0 });
sequenceEqual$1.sequenceEqual = void 0;
var lift_1$j = lift, OperatorSubscriber_1$f = OperatorSubscriber$1;
function sequenceEqual(t, e) {
  return e === void 0 && (e = function(r, n) {
    return r === n;
  }), lift_1$j.operate(function(r, n) {
    var i = createState(), o = createState(), a = function(l) {
      n.next(l), n.complete();
    }, c = function(l, u) {
      var f = OperatorSubscriber_1$f.createOperatorSubscriber(n, function(d) {
        var p = u.buffer, g = u.complete;
        p.length === 0 ? g ? a(!1) : l.buffer.push(d) : !e(d, p.shift()) && a(!1);
      }, function() {
        l.complete = !0;
        var d = u.complete, p = u.buffer;
        d && a(p.length === 0), f == null || f.unsubscribe();
      });
      return f;
    };
    r.subscribe(c(i, o)), t.subscribe(c(o, i));
  });
}
sequenceEqual$1.sequenceEqual = sequenceEqual;
function createState() {
  return {
    buffer: [],
    complete: !1
  };
}
var share$1 = {}, __read$3 = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$3 = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(share$1, "__esModule", { value: !0 });
share$1.share = void 0;
var from_1 = from$1, take_1 = take$1, Subject_1$5 = Subject$2, Subscriber_1 = Subscriber, lift_1$i = lift;
function share(t) {
  t === void 0 && (t = {});
  var e = t.connector, r = e === void 0 ? function() {
    return new Subject_1$5.Subject();
  } : e, n = t.resetOnError, i = n === void 0 ? !0 : n, o = t.resetOnComplete, a = o === void 0 ? !0 : o, c = t.resetOnRefCountZero, l = c === void 0 ? !0 : c;
  return function(u) {
    var f = null, d = null, p = null, g = 0, h = !1, m = !1, y = function() {
      d == null || d.unsubscribe(), d = null;
    }, b = function() {
      y(), f = p = null, h = m = !1;
    }, v = function() {
      var _ = f;
      b(), _ == null || _.unsubscribe();
    };
    return lift_1$i.operate(function(_, E) {
      g++, !m && !h && y();
      var w = p = p ?? r();
      E.add(function() {
        g--, g === 0 && !m && !h && (d = handleReset(v, l));
      }), w.subscribe(E), f || (f = new Subscriber_1.SafeSubscriber({
        next: function(S) {
          return w.next(S);
        },
        error: function(S) {
          m = !0, y(), d = handleReset(b, i, S), w.error(S);
        },
        complete: function() {
          h = !0, y(), d = handleReset(b, a), w.complete();
        }
      }), from_1.from(_).subscribe(f));
    })(u);
  };
}
share$1.share = share;
function handleReset(t, e) {
  for (var r = [], n = 2; n < arguments.length; n++)
    r[n - 2] = arguments[n];
  return e === !0 ? (t(), null) : e === !1 ? null : e.apply(void 0, __spreadArray$3([], __read$3(r))).pipe(take_1.take(1)).subscribe(function() {
    return t();
  });
}
var shareReplay$1 = {};
Object.defineProperty(shareReplay$1, "__esModule", { value: !0 });
shareReplay$1.shareReplay = void 0;
var ReplaySubject_1 = ReplaySubject$1, share_1 = share$1;
function shareReplay(t, e, r) {
  var n, i, o, a, c = !1;
  return t && typeof t == "object" ? (n = t.bufferSize, a = n === void 0 ? 1 / 0 : n, i = t.windowTime, e = i === void 0 ? 1 / 0 : i, o = t.refCount, c = o === void 0 ? !1 : o, r = t.scheduler) : a = t ?? 1 / 0, share_1.share({
    connector: function() {
      return new ReplaySubject_1.ReplaySubject(a, e, r);
    },
    resetOnError: !0,
    resetOnComplete: !1,
    resetOnRefCountZero: c
  });
}
shareReplay$1.shareReplay = shareReplay;
var single$1 = {};
Object.defineProperty(single$1, "__esModule", { value: !0 });
single$1.single = void 0;
var EmptyError_1 = EmptyError, SequenceError_1 = SequenceError, NotFoundError_1 = NotFoundError, lift_1$h = lift, OperatorSubscriber_1$e = OperatorSubscriber$1;
function single(t) {
  return lift_1$h.operate(function(e, r) {
    var n = !1, i, o = !1, a = 0;
    e.subscribe(OperatorSubscriber_1$e.createOperatorSubscriber(r, function(c) {
      o = !0, (!t || t(c, a++, e)) && (n && r.error(new SequenceError_1.SequenceError("Too many matching values")), n = !0, i = c);
    }, function() {
      n ? (r.next(i), r.complete()) : r.error(o ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
    }));
  });
}
single$1.single = single;
var skip$1 = {};
Object.defineProperty(skip$1, "__esModule", { value: !0 });
skip$1.skip = void 0;
var filter_1 = filter$1;
function skip(t) {
  return filter_1.filter(function(e, r) {
    return t <= r;
  });
}
skip$1.skip = skip;
var skipLast$1 = {};
Object.defineProperty(skipLast$1, "__esModule", { value: !0 });
skipLast$1.skipLast = void 0;
var identity_1$3 = identity$1, lift_1$g = lift, OperatorSubscriber_1$d = OperatorSubscriber$1;
function skipLast(t) {
  return t <= 0 ? identity_1$3.identity : lift_1$g.operate(function(e, r) {
    var n = new Array(t), i = 0;
    return e.subscribe(OperatorSubscriber_1$d.createOperatorSubscriber(r, function(o) {
      var a = i++;
      if (a < t)
        n[a] = o;
      else {
        var c = a % t, l = n[c];
        n[c] = o, r.next(l);
      }
    })), function() {
      n = null;
    };
  });
}
skipLast$1.skipLast = skipLast;
var skipUntil$1 = {};
Object.defineProperty(skipUntil$1, "__esModule", { value: !0 });
skipUntil$1.skipUntil = void 0;
var lift_1$f = lift, OperatorSubscriber_1$c = OperatorSubscriber$1, innerFrom_1$5 = innerFrom$1, noop_1$4 = noop$1;
function skipUntil(t) {
  return lift_1$f.operate(function(e, r) {
    var n = !1, i = OperatorSubscriber_1$c.createOperatorSubscriber(r, function() {
      i == null || i.unsubscribe(), n = !0;
    }, noop_1$4.noop);
    innerFrom_1$5.innerFrom(t).subscribe(i), e.subscribe(OperatorSubscriber_1$c.createOperatorSubscriber(r, function(o) {
      return n && r.next(o);
    }));
  });
}
skipUntil$1.skipUntil = skipUntil;
var skipWhile$1 = {};
Object.defineProperty(skipWhile$1, "__esModule", { value: !0 });
skipWhile$1.skipWhile = void 0;
var lift_1$e = lift, OperatorSubscriber_1$b = OperatorSubscriber$1;
function skipWhile(t) {
  return lift_1$e.operate(function(e, r) {
    var n = !1, i = 0;
    e.subscribe(OperatorSubscriber_1$b.createOperatorSubscriber(r, function(o) {
      return (n || (n = !t(o, i++))) && r.next(o);
    }));
  });
}
skipWhile$1.skipWhile = skipWhile;
var startWith$1 = {};
Object.defineProperty(startWith$1, "__esModule", { value: !0 });
startWith$1.startWith = void 0;
var concat_1 = concat$3, args_1$2 = args, lift_1$d = lift;
function startWith() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1$2.popScheduler(t);
  return lift_1$d.operate(function(n, i) {
    (r ? concat_1.concat(t, n, r) : concat_1.concat(t, n)).subscribe(i);
  });
}
startWith$1.startWith = startWith;
var switchAll$1 = {}, switchMap$1 = {};
Object.defineProperty(switchMap$1, "__esModule", { value: !0 });
switchMap$1.switchMap = void 0;
var innerFrom_1$4 = innerFrom$1, lift_1$c = lift, OperatorSubscriber_1$a = OperatorSubscriber$1;
function switchMap(t, e) {
  return lift_1$c.operate(function(r, n) {
    var i = null, o = 0, a = !1, c = function() {
      return a && !i && n.complete();
    };
    r.subscribe(OperatorSubscriber_1$a.createOperatorSubscriber(n, function(l) {
      i == null || i.unsubscribe();
      var u = 0, f = o++;
      innerFrom_1$4.innerFrom(t(l, f)).subscribe(i = OperatorSubscriber_1$a.createOperatorSubscriber(n, function(d) {
        return n.next(e ? e(l, d, f, u++) : d);
      }, function() {
        i = null, c();
      }));
    }, function() {
      a = !0, c();
    }));
  });
}
switchMap$1.switchMap = switchMap;
Object.defineProperty(switchAll$1, "__esModule", { value: !0 });
switchAll$1.switchAll = void 0;
var switchMap_1$2 = switchMap$1, identity_1$2 = identity$1;
function switchAll() {
  return switchMap_1$2.switchMap(identity_1$2.identity);
}
switchAll$1.switchAll = switchAll;
var switchMapTo$1 = {};
Object.defineProperty(switchMapTo$1, "__esModule", { value: !0 });
switchMapTo$1.switchMapTo = void 0;
var switchMap_1$1 = switchMap$1, isFunction_1$1 = isFunction$1;
function switchMapTo(t, e) {
  return isFunction_1$1.isFunction(e) ? switchMap_1$1.switchMap(function() {
    return t;
  }, e) : switchMap_1$1.switchMap(function() {
    return t;
  });
}
switchMapTo$1.switchMapTo = switchMapTo;
var switchScan$1 = {};
Object.defineProperty(switchScan$1, "__esModule", { value: !0 });
switchScan$1.switchScan = void 0;
var switchMap_1 = switchMap$1, lift_1$b = lift;
function switchScan(t, e) {
  return lift_1$b.operate(function(r, n) {
    var i = e;
    return switchMap_1.switchMap(function(o, a) {
      return t(i, o, a);
    }, function(o, a) {
      return i = a, a;
    })(r).subscribe(n), function() {
      i = null;
    };
  });
}
switchScan$1.switchScan = switchScan;
var takeUntil$1 = {};
Object.defineProperty(takeUntil$1, "__esModule", { value: !0 });
takeUntil$1.takeUntil = void 0;
var lift_1$a = lift, OperatorSubscriber_1$9 = OperatorSubscriber$1, innerFrom_1$3 = innerFrom$1, noop_1$3 = noop$1;
function takeUntil(t) {
  return lift_1$a.operate(function(e, r) {
    innerFrom_1$3.innerFrom(t).subscribe(OperatorSubscriber_1$9.createOperatorSubscriber(r, function() {
      return r.complete();
    }, noop_1$3.noop)), !r.closed && e.subscribe(r);
  });
}
takeUntil$1.takeUntil = takeUntil;
var takeWhile$1 = {};
Object.defineProperty(takeWhile$1, "__esModule", { value: !0 });
takeWhile$1.takeWhile = void 0;
var lift_1$9 = lift, OperatorSubscriber_1$8 = OperatorSubscriber$1;
function takeWhile(t, e) {
  return e === void 0 && (e = !1), lift_1$9.operate(function(r, n) {
    var i = 0;
    r.subscribe(OperatorSubscriber_1$8.createOperatorSubscriber(n, function(o) {
      var a = t(o, i++);
      (a || e) && n.next(o), !a && n.complete();
    }));
  });
}
takeWhile$1.takeWhile = takeWhile;
var tap$1 = {};
Object.defineProperty(tap$1, "__esModule", { value: !0 });
tap$1.tap = void 0;
var isFunction_1 = isFunction$1, lift_1$8 = lift, OperatorSubscriber_1$7 = OperatorSubscriber$1, identity_1$1 = identity$1;
function tap(t, e, r) {
  var n = isFunction_1.isFunction(t) || e || r ? { next: t, error: e, complete: r } : t;
  return n ? lift_1$8.operate(function(i, o) {
    var a;
    (a = n.subscribe) === null || a === void 0 || a.call(n);
    var c = !0;
    i.subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(o, function(l) {
      var u;
      (u = n.next) === null || u === void 0 || u.call(n, l), o.next(l);
    }, function() {
      var l;
      c = !1, (l = n.complete) === null || l === void 0 || l.call(n), o.complete();
    }, function(l) {
      var u;
      c = !1, (u = n.error) === null || u === void 0 || u.call(n, l), o.error(l);
    }, function() {
      var l, u;
      c && ((l = n.unsubscribe) === null || l === void 0 || l.call(n)), (u = n.finalize) === null || u === void 0 || u.call(n);
    }));
  }) : identity_1$1.identity;
}
tap$1.tap = tap;
var throttle = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.throttle = t.defaultThrottleConfig = void 0;
  var e = lift, r = OperatorSubscriber$1, n = innerFrom$1;
  t.defaultThrottleConfig = {
    leading: !0,
    trailing: !1
  };
  function i(o, a) {
    return a === void 0 && (a = t.defaultThrottleConfig), e.operate(function(c, l) {
      var u = a.leading, f = a.trailing, d = !1, p = null, g = null, h = !1, m = function() {
        g == null || g.unsubscribe(), g = null, f && (v(), h && l.complete());
      }, y = function() {
        g = null, h && l.complete();
      }, b = function(_) {
        return g = n.innerFrom(o(_)).subscribe(r.createOperatorSubscriber(l, m, y));
      }, v = function() {
        if (d) {
          d = !1;
          var _ = p;
          p = null, l.next(_), !h && b(_);
        }
      };
      c.subscribe(r.createOperatorSubscriber(l, function(_) {
        d = !0, p = _, !(g && !g.closed) && (u ? v() : b(_));
      }, function() {
        h = !0, !(f && d && g && !g.closed) && l.complete();
      }));
    });
  }
  t.throttle = i;
})(throttle);
var throttleTime$1 = {};
Object.defineProperty(throttleTime$1, "__esModule", { value: !0 });
throttleTime$1.throttleTime = void 0;
var async_1$3 = async, throttle_1 = throttle, timer_1 = timer$1;
function throttleTime(t, e, r) {
  e === void 0 && (e = async_1$3.asyncScheduler), r === void 0 && (r = throttle_1.defaultThrottleConfig);
  var n = timer_1.timer(t, e);
  return throttle_1.throttle(function() {
    return n;
  }, r);
}
throttleTime$1.throttleTime = throttleTime;
var timeInterval$1 = {};
Object.defineProperty(timeInterval$1, "__esModule", { value: !0 });
timeInterval$1.TimeInterval = timeInterval$1.timeInterval = void 0;
var async_1$2 = async, lift_1$7 = lift, OperatorSubscriber_1$6 = OperatorSubscriber$1;
function timeInterval(t) {
  return t === void 0 && (t = async_1$2.asyncScheduler), lift_1$7.operate(function(e, r) {
    var n = t.now();
    e.subscribe(OperatorSubscriber_1$6.createOperatorSubscriber(r, function(i) {
      var o = t.now(), a = o - n;
      n = o, r.next(new TimeInterval(i, a));
    }));
  });
}
timeInterval$1.timeInterval = timeInterval;
var TimeInterval = function() {
  function t(e, r) {
    this.value = e, this.interval = r;
  }
  return t;
}();
timeInterval$1.TimeInterval = TimeInterval;
var timeoutWith$1 = {};
Object.defineProperty(timeoutWith$1, "__esModule", { value: !0 });
timeoutWith$1.timeoutWith = void 0;
var async_1$1 = async, isDate_1 = isDate, timeout_1 = timeout;
function timeoutWith(t, e, r) {
  var n, i, o;
  if (r = r ?? async_1$1.async, isDate_1.isValidDate(t) ? n = t : typeof t == "number" && (i = t), e)
    o = function() {
      return e;
    };
  else
    throw new TypeError("No observable provided to switch to");
  if (n == null && i == null)
    throw new TypeError("No timeout provided.");
  return timeout_1.timeout({
    first: n,
    each: i,
    scheduler: r,
    with: o
  });
}
timeoutWith$1.timeoutWith = timeoutWith;
var timestamp$1 = {};
Object.defineProperty(timestamp$1, "__esModule", { value: !0 });
timestamp$1.timestamp = void 0;
var dateTimestampProvider_1 = dateTimestampProvider, map_1 = map$1;
function timestamp(t) {
  return t === void 0 && (t = dateTimestampProvider_1.dateTimestampProvider), map_1.map(function(e) {
    return { value: e, timestamp: t.now() };
  });
}
timestamp$1.timestamp = timestamp;
var window$2 = {};
Object.defineProperty(window$2, "__esModule", { value: !0 });
window$2.window = void 0;
var Subject_1$4 = Subject$2, lift_1$6 = lift, OperatorSubscriber_1$5 = OperatorSubscriber$1, noop_1$2 = noop$1;
function window$1(t) {
  return lift_1$6.operate(function(e, r) {
    var n = new Subject_1$4.Subject();
    r.next(n.asObservable());
    var i = function(o) {
      n.error(o), r.error(o);
    };
    return e.subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(r, function(o) {
      return n == null ? void 0 : n.next(o);
    }, function() {
      n.complete(), r.complete();
    }, i)), t.subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(r, function() {
      n.complete(), r.next(n = new Subject_1$4.Subject());
    }, noop_1$2.noop, i)), function() {
      n == null || n.unsubscribe(), n = null;
    };
  });
}
window$2.window = window$1;
var windowCount$1 = {}, __values$1 = commonjsGlobal && commonjsGlobal.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(windowCount$1, "__esModule", { value: !0 });
windowCount$1.windowCount = void 0;
var Subject_1$3 = Subject$2, lift_1$5 = lift, OperatorSubscriber_1$4 = OperatorSubscriber$1;
function windowCount(t, e) {
  e === void 0 && (e = 0);
  var r = e > 0 ? e : t;
  return lift_1$5.operate(function(n, i) {
    var o = [new Subject_1$3.Subject()], a = 0;
    i.next(o[0].asObservable()), n.subscribe(OperatorSubscriber_1$4.createOperatorSubscriber(i, function(c) {
      var l, u;
      try {
        for (var f = __values$1(o), d = f.next(); !d.done; d = f.next()) {
          var p = d.value;
          p.next(c);
        }
      } catch (m) {
        l = { error: m };
      } finally {
        try {
          d && !d.done && (u = f.return) && u.call(f);
        } finally {
          if (l)
            throw l.error;
        }
      }
      var g = a - t + 1;
      if (g >= 0 && g % r === 0 && o.shift().complete(), ++a % r === 0) {
        var h = new Subject_1$3.Subject();
        o.push(h), i.next(h.asObservable());
      }
    }, function() {
      for (; o.length > 0; )
        o.shift().complete();
      i.complete();
    }, function(c) {
      for (; o.length > 0; )
        o.shift().error(c);
      i.error(c);
    }, function() {
      o = null;
    }));
  });
}
windowCount$1.windowCount = windowCount;
var windowTime$1 = {};
Object.defineProperty(windowTime$1, "__esModule", { value: !0 });
windowTime$1.windowTime = void 0;
var Subject_1$2 = Subject$2, async_1 = async, Subscription_1$1 = Subscription$2, lift_1$4 = lift, OperatorSubscriber_1$3 = OperatorSubscriber$1, arrRemove_1$1 = arrRemove$1, args_1$1 = args, executeSchedule_1 = executeSchedule$1;
function windowTime(t) {
  for (var e, r, n = [], i = 1; i < arguments.length; i++)
    n[i - 1] = arguments[i];
  var o = (e = args_1$1.popScheduler(n)) !== null && e !== void 0 ? e : async_1.asyncScheduler, a = (r = n[0]) !== null && r !== void 0 ? r : null, c = n[1] || 1 / 0;
  return lift_1$4.operate(function(l, u) {
    var f = [], d = !1, p = function(y) {
      var b = y.window, v = y.subs;
      b.complete(), v.unsubscribe(), arrRemove_1$1.arrRemove(f, y), d && g();
    }, g = function() {
      if (f) {
        var y = new Subscription_1$1.Subscription();
        u.add(y);
        var b = new Subject_1$2.Subject(), v = {
          window: b,
          subs: y,
          seen: 0
        };
        f.push(v), u.next(b.asObservable()), executeSchedule_1.executeSchedule(y, o, function() {
          return p(v);
        }, t);
      }
    };
    a !== null && a >= 0 ? executeSchedule_1.executeSchedule(u, o, g, a, !0) : d = !0, g();
    var h = function(y) {
      return f.slice().forEach(y);
    }, m = function(y) {
      h(function(b) {
        var v = b.window;
        return y(v);
      }), y(u), u.unsubscribe();
    };
    return l.subscribe(OperatorSubscriber_1$3.createOperatorSubscriber(u, function(y) {
      h(function(b) {
        b.window.next(y), c <= ++b.seen && p(b);
      });
    }, function() {
      return m(function(y) {
        return y.complete();
      });
    }, function(y) {
      return m(function(b) {
        return b.error(y);
      });
    })), function() {
      f = null;
    };
  });
}
windowTime$1.windowTime = windowTime;
var windowToggle$1 = {}, __values = commonjsGlobal && commonjsGlobal.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(windowToggle$1, "__esModule", { value: !0 });
windowToggle$1.windowToggle = void 0;
var Subject_1$1 = Subject$2, Subscription_1 = Subscription$2, lift_1$3 = lift, innerFrom_1$2 = innerFrom$1, OperatorSubscriber_1$2 = OperatorSubscriber$1, noop_1$1 = noop$1, arrRemove_1 = arrRemove$1;
function windowToggle(t, e) {
  return lift_1$3.operate(function(r, n) {
    var i = [], o = function(a) {
      for (; 0 < i.length; )
        i.shift().error(a);
      n.error(a);
    };
    innerFrom_1$2.innerFrom(t).subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(n, function(a) {
      var c = new Subject_1$1.Subject();
      i.push(c);
      var l = new Subscription_1.Subscription(), u = function() {
        arrRemove_1.arrRemove(i, c), c.complete(), l.unsubscribe();
      }, f;
      try {
        f = innerFrom_1$2.innerFrom(e(a));
      } catch (d) {
        o(d);
        return;
      }
      n.next(c.asObservable()), l.add(f.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(n, u, noop_1$1.noop, o)));
    }, noop_1$1.noop)), r.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(n, function(a) {
      var c, l, u = i.slice();
      try {
        for (var f = __values(u), d = f.next(); !d.done; d = f.next()) {
          var p = d.value;
          p.next(a);
        }
      } catch (g) {
        c = { error: g };
      } finally {
        try {
          d && !d.done && (l = f.return) && l.call(f);
        } finally {
          if (c)
            throw c.error;
        }
      }
    }, function() {
      for (; 0 < i.length; )
        i.shift().complete();
      n.complete();
    }, o, function() {
      for (; 0 < i.length; )
        i.shift().unsubscribe();
    }));
  });
}
windowToggle$1.windowToggle = windowToggle;
var windowWhen$1 = {};
Object.defineProperty(windowWhen$1, "__esModule", { value: !0 });
windowWhen$1.windowWhen = void 0;
var Subject_1 = Subject$2, lift_1$2 = lift, OperatorSubscriber_1$1 = OperatorSubscriber$1, innerFrom_1$1 = innerFrom$1;
function windowWhen(t) {
  return lift_1$2.operate(function(e, r) {
    var n, i, o = function(c) {
      n.error(c), r.error(c);
    }, a = function() {
      i == null || i.unsubscribe(), n == null || n.complete(), n = new Subject_1.Subject(), r.next(n.asObservable());
      var c;
      try {
        c = innerFrom_1$1.innerFrom(t());
      } catch (l) {
        o(l);
        return;
      }
      c.subscribe(i = OperatorSubscriber_1$1.createOperatorSubscriber(r, a, a, o));
    };
    a(), e.subscribe(OperatorSubscriber_1$1.createOperatorSubscriber(r, function(c) {
      return n.next(c);
    }, function() {
      n.complete(), r.complete();
    }, o, function() {
      i == null || i.unsubscribe(), n = null;
    }));
  });
}
windowWhen$1.windowWhen = windowWhen;
var withLatestFrom$1 = {}, __read$2 = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(withLatestFrom$1, "__esModule", { value: !0 });
withLatestFrom$1.withLatestFrom = void 0;
var lift_1$1 = lift, OperatorSubscriber_1 = OperatorSubscriber$1, innerFrom_1 = innerFrom$1, identity_1 = identity$1, noop_1 = noop$1, args_1 = args;
function withLatestFrom() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = args_1.popResultSelector(t);
  return lift_1$1.operate(function(n, i) {
    for (var o = t.length, a = new Array(o), c = t.map(function() {
      return !1;
    }), l = !1, u = function(d) {
      innerFrom_1.innerFrom(t[d]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(i, function(p) {
        a[d] = p, !l && !c[d] && (c[d] = !0, (l = c.every(identity_1.identity)) && (c = null));
      }, noop_1.noop));
    }, f = 0; f < o; f++)
      u(f);
    n.subscribe(OperatorSubscriber_1.createOperatorSubscriber(i, function(d) {
      if (l) {
        var p = __spreadArray$2([d], __read$2(a));
        i.next(r ? r.apply(void 0, __spreadArray$2([], __read$2(p))) : p);
      }
    }));
  });
}
withLatestFrom$1.withLatestFrom = withLatestFrom;
var zipAll$1 = {};
Object.defineProperty(zipAll$1, "__esModule", { value: !0 });
zipAll$1.zipAll = void 0;
var zip_1$2 = zip$3, joinAllInternals_1 = joinAllInternals$1;
function zipAll(t) {
  return joinAllInternals_1.joinAllInternals(zip_1$2.zip, t);
}
zipAll$1.zipAll = zipAll;
var zipWith$1 = {}, zip$1 = {}, __read$1 = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray$1 = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(zip$1, "__esModule", { value: !0 });
zip$1.zip = void 0;
var zip_1$1 = zip$3, lift_1 = lift;
function zip() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return lift_1.operate(function(r, n) {
    zip_1$1.zip.apply(void 0, __spreadArray$1([r], __read$1(t))).subscribe(n);
  });
}
zip$1.zip = zip;
var __read = commonjsGlobal && commonjsGlobal.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, o = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      o.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return o;
}, __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
Object.defineProperty(zipWith$1, "__esModule", { value: !0 });
zipWith$1.zipWith = void 0;
var zip_1 = zip$1;
function zipWith() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return zip_1.zip.apply(void 0, __spreadArray([], __read(t)));
}
zipWith$1.zipWith = zipWith;
(function(t) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(be, _e, ce, ge) {
    ge === void 0 && (ge = ce), Object.defineProperty(be, ge, { enumerable: !0, get: function() {
      return _e[ce];
    } });
  } : function(be, _e, ce, ge) {
    ge === void 0 && (ge = ce), be[ge] = _e[ce];
  }), r = commonjsGlobal && commonjsGlobal.__exportStar || function(be, _e) {
    for (var ce in be)
      ce !== "default" && !Object.prototype.hasOwnProperty.call(_e, ce) && e(_e, be, ce);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.interval = t.iif = t.generate = t.fromEventPattern = t.fromEvent = t.from = t.forkJoin = t.empty = t.defer = t.connectable = t.concat = t.combineLatest = t.bindNodeCallback = t.bindCallback = t.UnsubscriptionError = t.TimeoutError = t.SequenceError = t.ObjectUnsubscribedError = t.NotFoundError = t.EmptyError = t.ArgumentOutOfRangeError = t.firstValueFrom = t.lastValueFrom = t.isObservable = t.identity = t.noop = t.pipe = t.NotificationKind = t.Notification = t.Subscriber = t.Subscription = t.Scheduler = t.VirtualAction = t.VirtualTimeScheduler = t.animationFrameScheduler = t.animationFrame = t.queueScheduler = t.queue = t.asyncScheduler = t.async = t.asapScheduler = t.asap = t.AsyncSubject = t.ReplaySubject = t.BehaviorSubject = t.Subject = t.animationFrames = t.observable = t.ConnectableObservable = t.Observable = void 0, t.filter = t.expand = t.exhaustMap = t.exhaustAll = t.exhaust = t.every = t.endWith = t.elementAt = t.distinctUntilKeyChanged = t.distinctUntilChanged = t.distinct = t.dematerialize = t.delayWhen = t.delay = t.defaultIfEmpty = t.debounceTime = t.debounce = t.count = t.connect = t.concatWith = t.concatMapTo = t.concatMap = t.concatAll = t.combineLatestWith = t.combineLatestAll = t.combineAll = t.catchError = t.bufferWhen = t.bufferToggle = t.bufferTime = t.bufferCount = t.buffer = t.auditTime = t.audit = t.config = t.NEVER = t.EMPTY = t.scheduled = t.zip = t.using = t.timer = t.throwError = t.range = t.race = t.partition = t.pairs = t.onErrorResumeNext = t.of = t.never = t.merge = void 0, t.switchMapTo = t.switchMap = t.switchAll = t.subscribeOn = t.startWith = t.skipWhile = t.skipUntil = t.skipLast = t.skip = t.single = t.shareReplay = t.share = t.sequenceEqual = t.scan = t.sampleTime = t.sample = t.refCount = t.retryWhen = t.retry = t.repeatWhen = t.repeat = t.reduce = t.raceWith = t.publishReplay = t.publishLast = t.publishBehavior = t.publish = t.pluck = t.pairwise = t.observeOn = t.multicast = t.min = t.mergeWith = t.mergeScan = t.mergeMapTo = t.mergeMap = t.flatMap = t.mergeAll = t.max = t.materialize = t.mapTo = t.map = t.last = t.isEmpty = t.ignoreElements = t.groupBy = t.first = t.findIndex = t.find = t.finalize = void 0, t.zipWith = t.zipAll = t.withLatestFrom = t.windowWhen = t.windowToggle = t.windowTime = t.windowCount = t.window = t.toArray = t.timestamp = t.timeoutWith = t.timeout = t.timeInterval = t.throwIfEmpty = t.throttleTime = t.throttle = t.tap = t.takeWhile = t.takeUntil = t.takeLast = t.take = t.switchScan = void 0;
  var n = Observable$3;
  Object.defineProperty(t, "Observable", { enumerable: !0, get: function() {
    return n.Observable;
  } });
  var i = ConnectableObservable$1;
  Object.defineProperty(t, "ConnectableObservable", { enumerable: !0, get: function() {
    return i.ConnectableObservable;
  } });
  var o = observable;
  Object.defineProperty(t, "observable", { enumerable: !0, get: function() {
    return o.observable;
  } });
  var a = animationFrames$1;
  Object.defineProperty(t, "animationFrames", { enumerable: !0, get: function() {
    return a.animationFrames;
  } });
  var c = Subject$2;
  Object.defineProperty(t, "Subject", { enumerable: !0, get: function() {
    return c.Subject;
  } });
  var l = BehaviorSubject$1;
  Object.defineProperty(t, "BehaviorSubject", { enumerable: !0, get: function() {
    return l.BehaviorSubject;
  } });
  var u = ReplaySubject$1;
  Object.defineProperty(t, "ReplaySubject", { enumerable: !0, get: function() {
    return u.ReplaySubject;
  } });
  var f = AsyncSubject$1;
  Object.defineProperty(t, "AsyncSubject", { enumerable: !0, get: function() {
    return f.AsyncSubject;
  } });
  var d = asap;
  Object.defineProperty(t, "asap", { enumerable: !0, get: function() {
    return d.asap;
  } }), Object.defineProperty(t, "asapScheduler", { enumerable: !0, get: function() {
    return d.asapScheduler;
  } });
  var p = async;
  Object.defineProperty(t, "async", { enumerable: !0, get: function() {
    return p.async;
  } }), Object.defineProperty(t, "asyncScheduler", { enumerable: !0, get: function() {
    return p.asyncScheduler;
  } });
  var g = queue;
  Object.defineProperty(t, "queue", { enumerable: !0, get: function() {
    return g.queue;
  } }), Object.defineProperty(t, "queueScheduler", { enumerable: !0, get: function() {
    return g.queueScheduler;
  } });
  var h = animationFrame;
  Object.defineProperty(t, "animationFrame", { enumerable: !0, get: function() {
    return h.animationFrame;
  } }), Object.defineProperty(t, "animationFrameScheduler", { enumerable: !0, get: function() {
    return h.animationFrameScheduler;
  } });
  var m = VirtualTimeScheduler$1;
  Object.defineProperty(t, "VirtualTimeScheduler", { enumerable: !0, get: function() {
    return m.VirtualTimeScheduler;
  } }), Object.defineProperty(t, "VirtualAction", { enumerable: !0, get: function() {
    return m.VirtualAction;
  } });
  var y = Scheduler$1;
  Object.defineProperty(t, "Scheduler", { enumerable: !0, get: function() {
    return y.Scheduler;
  } });
  var b = Subscription$2;
  Object.defineProperty(t, "Subscription", { enumerable: !0, get: function() {
    return b.Subscription;
  } });
  var v = Subscriber;
  Object.defineProperty(t, "Subscriber", { enumerable: !0, get: function() {
    return v.Subscriber;
  } });
  var _ = Notification;
  Object.defineProperty(t, "Notification", { enumerable: !0, get: function() {
    return _.Notification;
  } }), Object.defineProperty(t, "NotificationKind", { enumerable: !0, get: function() {
    return _.NotificationKind;
  } });
  var E = pipe$1;
  Object.defineProperty(t, "pipe", { enumerable: !0, get: function() {
    return E.pipe;
  } });
  var w = noop$1;
  Object.defineProperty(t, "noop", { enumerable: !0, get: function() {
    return w.noop;
  } });
  var S = identity$1;
  Object.defineProperty(t, "identity", { enumerable: !0, get: function() {
    return S.identity;
  } });
  var x = isObservable$2;
  Object.defineProperty(t, "isObservable", { enumerable: !0, get: function() {
    return x.isObservable;
  } });
  var I = lastValueFrom$1;
  Object.defineProperty(t, "lastValueFrom", { enumerable: !0, get: function() {
    return I.lastValueFrom;
  } });
  var C = firstValueFrom$1;
  Object.defineProperty(t, "firstValueFrom", { enumerable: !0, get: function() {
    return C.firstValueFrom;
  } });
  var M = ArgumentOutOfRangeError;
  Object.defineProperty(t, "ArgumentOutOfRangeError", { enumerable: !0, get: function() {
    return M.ArgumentOutOfRangeError;
  } });
  var O = EmptyError;
  Object.defineProperty(t, "EmptyError", { enumerable: !0, get: function() {
    return O.EmptyError;
  } });
  var B = NotFoundError;
  Object.defineProperty(t, "NotFoundError", { enumerable: !0, get: function() {
    return B.NotFoundError;
  } });
  var k = ObjectUnsubscribedError;
  Object.defineProperty(t, "ObjectUnsubscribedError", { enumerable: !0, get: function() {
    return k.ObjectUnsubscribedError;
  } });
  var U = SequenceError;
  Object.defineProperty(t, "SequenceError", { enumerable: !0, get: function() {
    return U.SequenceError;
  } });
  var R = timeout;
  Object.defineProperty(t, "TimeoutError", { enumerable: !0, get: function() {
    return R.TimeoutError;
  } });
  var P = UnsubscriptionError;
  Object.defineProperty(t, "UnsubscriptionError", { enumerable: !0, get: function() {
    return P.UnsubscriptionError;
  } });
  var T = bindCallback$1;
  Object.defineProperty(t, "bindCallback", { enumerable: !0, get: function() {
    return T.bindCallback;
  } });
  var L = bindNodeCallback$1;
  Object.defineProperty(t, "bindNodeCallback", { enumerable: !0, get: function() {
    return L.bindNodeCallback;
  } });
  var A = combineLatest$3;
  Object.defineProperty(t, "combineLatest", { enumerable: !0, get: function() {
    return A.combineLatest;
  } });
  var N = concat$3;
  Object.defineProperty(t, "concat", { enumerable: !0, get: function() {
    return N.concat;
  } });
  var D = connectable$1;
  Object.defineProperty(t, "connectable", { enumerable: !0, get: function() {
    return D.connectable;
  } });
  var F = defer$1;
  Object.defineProperty(t, "defer", { enumerable: !0, get: function() {
    return F.defer;
  } });
  var j = empty;
  Object.defineProperty(t, "empty", { enumerable: !0, get: function() {
    return j.empty;
  } });
  var K = forkJoin$1;
  Object.defineProperty(t, "forkJoin", { enumerable: !0, get: function() {
    return K.forkJoin;
  } });
  var G = from$1;
  Object.defineProperty(t, "from", { enumerable: !0, get: function() {
    return G.from;
  } });
  var W = fromEvent$1;
  Object.defineProperty(t, "fromEvent", { enumerable: !0, get: function() {
    return W.fromEvent;
  } });
  var H = fromEventPattern$1;
  Object.defineProperty(t, "fromEventPattern", { enumerable: !0, get: function() {
    return H.fromEventPattern;
  } });
  var q = generate$1;
  Object.defineProperty(t, "generate", { enumerable: !0, get: function() {
    return q.generate;
  } });
  var z = iif$1;
  Object.defineProperty(t, "iif", { enumerable: !0, get: function() {
    return z.iif;
  } });
  var Z = interval$1;
  Object.defineProperty(t, "interval", { enumerable: !0, get: function() {
    return Z.interval;
  } });
  var J = merge$3;
  Object.defineProperty(t, "merge", { enumerable: !0, get: function() {
    return J.merge;
  } });
  var ee = never;
  Object.defineProperty(t, "never", { enumerable: !0, get: function() {
    return ee.never;
  } });
  var Q = of$1;
  Object.defineProperty(t, "of", { enumerable: !0, get: function() {
    return Q.of;
  } });
  var ne = onErrorResumeNext$3;
  Object.defineProperty(t, "onErrorResumeNext", { enumerable: !0, get: function() {
    return ne.onErrorResumeNext;
  } });
  var ae = pairs$1;
  Object.defineProperty(t, "pairs", { enumerable: !0, get: function() {
    return ae.pairs;
  } });
  var me = partition$1;
  Object.defineProperty(t, "partition", { enumerable: !0, get: function() {
    return me.partition;
  } });
  var Te = race$1;
  Object.defineProperty(t, "race", { enumerable: !0, get: function() {
    return Te.race;
  } });
  var Ke = range$1;
  Object.defineProperty(t, "range", { enumerable: !0, get: function() {
    return Ke.range;
  } });
  var Ve = throwError$1;
  Object.defineProperty(t, "throwError", { enumerable: !0, get: function() {
    return Ve.throwError;
  } });
  var We = timer$1;
  Object.defineProperty(t, "timer", { enumerable: !0, get: function() {
    return We.timer;
  } });
  var Ge = using$1;
  Object.defineProperty(t, "using", { enumerable: !0, get: function() {
    return Ge.using;
  } });
  var Ce = zip$3;
  Object.defineProperty(t, "zip", { enumerable: !0, get: function() {
    return Ce.zip;
  } });
  var Le = scheduled$1;
  Object.defineProperty(t, "scheduled", { enumerable: !0, get: function() {
    return Le.scheduled;
  } });
  var xe = empty;
  Object.defineProperty(t, "EMPTY", { enumerable: !0, get: function() {
    return xe.EMPTY;
  } });
  var Be = never;
  Object.defineProperty(t, "NEVER", { enumerable: !0, get: function() {
    return Be.NEVER;
  } }), r(types$1, t);
  var ke = config;
  Object.defineProperty(t, "config", { enumerable: !0, get: function() {
    return ke.config;
  } });
  var Ne = audit$1;
  Object.defineProperty(t, "audit", { enumerable: !0, get: function() {
    return Ne.audit;
  } });
  var Me = auditTime$1;
  Object.defineProperty(t, "auditTime", { enumerable: !0, get: function() {
    return Me.auditTime;
  } });
  var De = buffer$1;
  Object.defineProperty(t, "buffer", { enumerable: !0, get: function() {
    return De.buffer;
  } });
  var He = bufferCount$1;
  Object.defineProperty(t, "bufferCount", { enumerable: !0, get: function() {
    return He.bufferCount;
  } });
  var ze = bufferTime$1;
  Object.defineProperty(t, "bufferTime", { enumerable: !0, get: function() {
    return ze.bufferTime;
  } });
  var qe = bufferToggle$1;
  Object.defineProperty(t, "bufferToggle", { enumerable: !0, get: function() {
    return qe.bufferToggle;
  } });
  var Ye = bufferWhen$1;
  Object.defineProperty(t, "bufferWhen", { enumerable: !0, get: function() {
    return Ye.bufferWhen;
  } });
  var lt = catchError$1;
  Object.defineProperty(t, "catchError", { enumerable: !0, get: function() {
    return lt.catchError;
  } });
  var ft = combineAll;
  Object.defineProperty(t, "combineAll", { enumerable: !0, get: function() {
    return ft.combineAll;
  } });
  var dt = combineLatestAll$1;
  Object.defineProperty(t, "combineLatestAll", { enumerable: !0, get: function() {
    return dt.combineLatestAll;
  } });
  var ht = combineLatestWith$1;
  Object.defineProperty(t, "combineLatestWith", { enumerable: !0, get: function() {
    return ht.combineLatestWith;
  } });
  var pt = concatAll$1;
  Object.defineProperty(t, "concatAll", { enumerable: !0, get: function() {
    return pt.concatAll;
  } });
  var mt = concatMap$1;
  Object.defineProperty(t, "concatMap", { enumerable: !0, get: function() {
    return mt.concatMap;
  } });
  var gt = concatMapTo$1;
  Object.defineProperty(t, "concatMapTo", { enumerable: !0, get: function() {
    return gt.concatMapTo;
  } });
  var yt = concatWith$1;
  Object.defineProperty(t, "concatWith", { enumerable: !0, get: function() {
    return yt.concatWith;
  } });
  var bt = connect$1;
  Object.defineProperty(t, "connect", { enumerable: !0, get: function() {
    return bt.connect;
  } });
  var _t = count$1;
  Object.defineProperty(t, "count", { enumerable: !0, get: function() {
    return _t.count;
  } });
  var vt = debounce$1;
  Object.defineProperty(t, "debounce", { enumerable: !0, get: function() {
    return vt.debounce;
  } });
  var $t = debounceTime$1;
  Object.defineProperty(t, "debounceTime", { enumerable: !0, get: function() {
    return $t.debounceTime;
  } });
  var Et = defaultIfEmpty$1;
  Object.defineProperty(t, "defaultIfEmpty", { enumerable: !0, get: function() {
    return Et.defaultIfEmpty;
  } });
  var wt = delay$1;
  Object.defineProperty(t, "delay", { enumerable: !0, get: function() {
    return wt.delay;
  } });
  var St = delayWhen$1;
  Object.defineProperty(t, "delayWhen", { enumerable: !0, get: function() {
    return St.delayWhen;
  } });
  var xt = dematerialize$1;
  Object.defineProperty(t, "dematerialize", { enumerable: !0, get: function() {
    return xt.dematerialize;
  } });
  var At = distinct$1;
  Object.defineProperty(t, "distinct", { enumerable: !0, get: function() {
    return At.distinct;
  } });
  var It = distinctUntilChanged$1;
  Object.defineProperty(t, "distinctUntilChanged", { enumerable: !0, get: function() {
    return It.distinctUntilChanged;
  } });
  var Rt = distinctUntilKeyChanged$1;
  Object.defineProperty(t, "distinctUntilKeyChanged", { enumerable: !0, get: function() {
    return Rt.distinctUntilKeyChanged;
  } });
  var Ot = elementAt$1;
  Object.defineProperty(t, "elementAt", { enumerable: !0, get: function() {
    return Ot.elementAt;
  } });
  var Pt = endWith$1;
  Object.defineProperty(t, "endWith", { enumerable: !0, get: function() {
    return Pt.endWith;
  } });
  var Tt = every$1;
  Object.defineProperty(t, "every", { enumerable: !0, get: function() {
    return Tt.every;
  } });
  var Ct = exhaust;
  Object.defineProperty(t, "exhaust", { enumerable: !0, get: function() {
    return Ct.exhaust;
  } });
  var Lt = exhaustAll$1;
  Object.defineProperty(t, "exhaustAll", { enumerable: !0, get: function() {
    return Lt.exhaustAll;
  } });
  var Bt = exhaustMap$1;
  Object.defineProperty(t, "exhaustMap", { enumerable: !0, get: function() {
    return Bt.exhaustMap;
  } });
  var kt = expand$1;
  Object.defineProperty(t, "expand", { enumerable: !0, get: function() {
    return kt.expand;
  } });
  var Nt = filter$1;
  Object.defineProperty(t, "filter", { enumerable: !0, get: function() {
    return Nt.filter;
  } });
  var Mt = finalize$1;
  Object.defineProperty(t, "finalize", { enumerable: !0, get: function() {
    return Mt.finalize;
  } });
  var Dt = find$1;
  Object.defineProperty(t, "find", { enumerable: !0, get: function() {
    return Dt.find;
  } });
  var Ft = findIndex$1;
  Object.defineProperty(t, "findIndex", { enumerable: !0, get: function() {
    return Ft.findIndex;
  } });
  var Ut = first$1;
  Object.defineProperty(t, "first", { enumerable: !0, get: function() {
    return Ut.first;
  } });
  var jt = groupBy$1;
  Object.defineProperty(t, "groupBy", { enumerable: !0, get: function() {
    return jt.groupBy;
  } });
  var Kt = ignoreElements$1;
  Object.defineProperty(t, "ignoreElements", { enumerable: !0, get: function() {
    return Kt.ignoreElements;
  } });
  var Vt = isEmpty$1;
  Object.defineProperty(t, "isEmpty", { enumerable: !0, get: function() {
    return Vt.isEmpty;
  } });
  var Wt = last$1;
  Object.defineProperty(t, "last", { enumerable: !0, get: function() {
    return Wt.last;
  } });
  var Gt = map$1;
  Object.defineProperty(t, "map", { enumerable: !0, get: function() {
    return Gt.map;
  } });
  var Ht = mapTo$1;
  Object.defineProperty(t, "mapTo", { enumerable: !0, get: function() {
    return Ht.mapTo;
  } });
  var zt = materialize$1;
  Object.defineProperty(t, "materialize", { enumerable: !0, get: function() {
    return zt.materialize;
  } });
  var qt = max$1;
  Object.defineProperty(t, "max", { enumerable: !0, get: function() {
    return qt.max;
  } });
  var Yt = mergeAll$1;
  Object.defineProperty(t, "mergeAll", { enumerable: !0, get: function() {
    return Yt.mergeAll;
  } });
  var Qt = flatMap;
  Object.defineProperty(t, "flatMap", { enumerable: !0, get: function() {
    return Qt.flatMap;
  } });
  var Xt = mergeMap$1;
  Object.defineProperty(t, "mergeMap", { enumerable: !0, get: function() {
    return Xt.mergeMap;
  } });
  var Zt = mergeMapTo$1;
  Object.defineProperty(t, "mergeMapTo", { enumerable: !0, get: function() {
    return Zt.mergeMapTo;
  } });
  var Jt = mergeScan$1;
  Object.defineProperty(t, "mergeScan", { enumerable: !0, get: function() {
    return Jt.mergeScan;
  } });
  var er = mergeWith$1;
  Object.defineProperty(t, "mergeWith", { enumerable: !0, get: function() {
    return er.mergeWith;
  } });
  var tr = min$1;
  Object.defineProperty(t, "min", { enumerable: !0, get: function() {
    return tr.min;
  } });
  var nr = multicast$2;
  Object.defineProperty(t, "multicast", { enumerable: !0, get: function() {
    return nr.multicast;
  } });
  var ir = observeOn$1;
  Object.defineProperty(t, "observeOn", { enumerable: !0, get: function() {
    return ir.observeOn;
  } });
  var sr = pairwise$1;
  Object.defineProperty(t, "pairwise", { enumerable: !0, get: function() {
    return sr.pairwise;
  } });
  var ar = pluck$1;
  Object.defineProperty(t, "pluck", { enumerable: !0, get: function() {
    return ar.pluck;
  } });
  var cr = publish$1;
  Object.defineProperty(t, "publish", { enumerable: !0, get: function() {
    return cr.publish;
  } });
  var ur = publishBehavior$1;
  Object.defineProperty(t, "publishBehavior", { enumerable: !0, get: function() {
    return ur.publishBehavior;
  } });
  var lr = publishLast$1;
  Object.defineProperty(t, "publishLast", { enumerable: !0, get: function() {
    return lr.publishLast;
  } });
  var fr = publishReplay$1;
  Object.defineProperty(t, "publishReplay", { enumerable: !0, get: function() {
    return fr.publishReplay;
  } });
  var dr = raceWith$1;
  Object.defineProperty(t, "raceWith", { enumerable: !0, get: function() {
    return dr.raceWith;
  } });
  var hr = reduce$1;
  Object.defineProperty(t, "reduce", { enumerable: !0, get: function() {
    return hr.reduce;
  } });
  var pr = repeat$1;
  Object.defineProperty(t, "repeat", { enumerable: !0, get: function() {
    return pr.repeat;
  } });
  var mr = repeatWhen$1;
  Object.defineProperty(t, "repeatWhen", { enumerable: !0, get: function() {
    return mr.repeatWhen;
  } });
  var gr = retry$1;
  Object.defineProperty(t, "retry", { enumerable: !0, get: function() {
    return gr.retry;
  } });
  var yr = retryWhen$1;
  Object.defineProperty(t, "retryWhen", { enumerable: !0, get: function() {
    return yr.retryWhen;
  } });
  var br = refCount$1;
  Object.defineProperty(t, "refCount", { enumerable: !0, get: function() {
    return br.refCount;
  } });
  var _r = sample$1;
  Object.defineProperty(t, "sample", { enumerable: !0, get: function() {
    return _r.sample;
  } });
  var vr = sampleTime$1;
  Object.defineProperty(t, "sampleTime", { enumerable: !0, get: function() {
    return vr.sampleTime;
  } });
  var $r = scan$1;
  Object.defineProperty(t, "scan", { enumerable: !0, get: function() {
    return $r.scan;
  } });
  var Er = sequenceEqual$1;
  Object.defineProperty(t, "sequenceEqual", { enumerable: !0, get: function() {
    return Er.sequenceEqual;
  } });
  var wr = share$1;
  Object.defineProperty(t, "share", { enumerable: !0, get: function() {
    return wr.share;
  } });
  var Sr = shareReplay$1;
  Object.defineProperty(t, "shareReplay", { enumerable: !0, get: function() {
    return Sr.shareReplay;
  } });
  var xr = single$1;
  Object.defineProperty(t, "single", { enumerable: !0, get: function() {
    return xr.single;
  } });
  var Ar = skip$1;
  Object.defineProperty(t, "skip", { enumerable: !0, get: function() {
    return Ar.skip;
  } });
  var Ir = skipLast$1;
  Object.defineProperty(t, "skipLast", { enumerable: !0, get: function() {
    return Ir.skipLast;
  } });
  var Rr = skipUntil$1;
  Object.defineProperty(t, "skipUntil", { enumerable: !0, get: function() {
    return Rr.skipUntil;
  } });
  var Or = skipWhile$1;
  Object.defineProperty(t, "skipWhile", { enumerable: !0, get: function() {
    return Or.skipWhile;
  } });
  var Pr = startWith$1;
  Object.defineProperty(t, "startWith", { enumerable: !0, get: function() {
    return Pr.startWith;
  } });
  var Tr = subscribeOn$1;
  Object.defineProperty(t, "subscribeOn", { enumerable: !0, get: function() {
    return Tr.subscribeOn;
  } });
  var Cr = switchAll$1;
  Object.defineProperty(t, "switchAll", { enumerable: !0, get: function() {
    return Cr.switchAll;
  } });
  var Lr = switchMap$1;
  Object.defineProperty(t, "switchMap", { enumerable: !0, get: function() {
    return Lr.switchMap;
  } });
  var Br = switchMapTo$1;
  Object.defineProperty(t, "switchMapTo", { enumerable: !0, get: function() {
    return Br.switchMapTo;
  } });
  var kr = switchScan$1;
  Object.defineProperty(t, "switchScan", { enumerable: !0, get: function() {
    return kr.switchScan;
  } });
  var Nr = take$1;
  Object.defineProperty(t, "take", { enumerable: !0, get: function() {
    return Nr.take;
  } });
  var Mr = takeLast$1;
  Object.defineProperty(t, "takeLast", { enumerable: !0, get: function() {
    return Mr.takeLast;
  } });
  var Dr = takeUntil$1;
  Object.defineProperty(t, "takeUntil", { enumerable: !0, get: function() {
    return Dr.takeUntil;
  } });
  var Fr = takeWhile$1;
  Object.defineProperty(t, "takeWhile", { enumerable: !0, get: function() {
    return Fr.takeWhile;
  } });
  var Ur = tap$1;
  Object.defineProperty(t, "tap", { enumerable: !0, get: function() {
    return Ur.tap;
  } });
  var jr = throttle;
  Object.defineProperty(t, "throttle", { enumerable: !0, get: function() {
    return jr.throttle;
  } });
  var Kr = throttleTime$1;
  Object.defineProperty(t, "throttleTime", { enumerable: !0, get: function() {
    return Kr.throttleTime;
  } });
  var Vr = throwIfEmpty$1;
  Object.defineProperty(t, "throwIfEmpty", { enumerable: !0, get: function() {
    return Vr.throwIfEmpty;
  } });
  var Wr = timeInterval$1;
  Object.defineProperty(t, "timeInterval", { enumerable: !0, get: function() {
    return Wr.timeInterval;
  } });
  var Gr = timeout;
  Object.defineProperty(t, "timeout", { enumerable: !0, get: function() {
    return Gr.timeout;
  } });
  var Hr = timeoutWith$1;
  Object.defineProperty(t, "timeoutWith", { enumerable: !0, get: function() {
    return Hr.timeoutWith;
  } });
  var zr = timestamp$1;
  Object.defineProperty(t, "timestamp", { enumerable: !0, get: function() {
    return zr.timestamp;
  } });
  var qr = toArray$1;
  Object.defineProperty(t, "toArray", { enumerable: !0, get: function() {
    return qr.toArray;
  } });
  var Yr = window$2;
  Object.defineProperty(t, "window", { enumerable: !0, get: function() {
    return Yr.window;
  } });
  var Qr = windowCount$1;
  Object.defineProperty(t, "windowCount", { enumerable: !0, get: function() {
    return Qr.windowCount;
  } });
  var Xr = windowTime$1;
  Object.defineProperty(t, "windowTime", { enumerable: !0, get: function() {
    return Xr.windowTime;
  } });
  var Zr = windowToggle$1;
  Object.defineProperty(t, "windowToggle", { enumerable: !0, get: function() {
    return Zr.windowToggle;
  } });
  var Jr = windowWhen$1;
  Object.defineProperty(t, "windowWhen", { enumerable: !0, get: function() {
    return Jr.windowWhen;
  } });
  var en = withLatestFrom$1;
  Object.defineProperty(t, "withLatestFrom", { enumerable: !0, get: function() {
    return en.withLatestFrom;
  } });
  var tn = zipAll$1;
  Object.defineProperty(t, "zipAll", { enumerable: !0, get: function() {
    return tn.zipAll;
  } });
  var rn = zipWith$1;
  Object.defineProperty(t, "zipWith", { enumerable: !0, get: function() {
    return rn.zipWith;
  } });
})(cjs);
function jsonify(t) {
  return JSON.stringify(t, null, 4);
}
const isString$1 = (t) => t !== null && typeof t == "string";
function relayOptionToMultiaddr(t) {
  const e = isString$1(t) ? t : t.multiaddr, r = multiaddr(e);
  return throwIfHasNoPeerId(r), r;
}
function throwIfHasNoPeerId(t) {
  if (!t.getPeerId())
    throw new Error("Specified multiaddr is invalid or missing peer id: " + t.toString());
}
const _hasatob = typeof atob == "function", _hasbtoa = typeof btoa == "function", _hasBuffer = typeof Buffer == "function";
typeof TextDecoder == "function" && new TextDecoder();
typeof TextEncoder == "function" && new TextEncoder();
const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", b64chs = Array.prototype.slice.call(b64ch), b64tab = ((t) => {
  let e = {};
  return t.forEach((r, n) => e[r] = n), e;
})(b64chs), b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, _fromCC = String.fromCharCode.bind(String), _U8Afrom = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : (t) => new Uint8Array(Array.prototype.slice.call(t, 0)), _mkUriSafe = (t) => t.replace(/=/g, "").replace(/[+\/]/g, (e) => e == "+" ? "-" : "_"), _tidyB64 = (t) => t.replace(/[^A-Za-z0-9\+\/]/g, ""), btoaPolyfill = (t) => {
  let e, r, n, i, o = "";
  const a = t.length % 3;
  for (let c = 0; c < t.length; ) {
    if ((r = t.charCodeAt(c++)) > 255 || (n = t.charCodeAt(c++)) > 255 || (i = t.charCodeAt(c++)) > 255)
      throw new TypeError("invalid character found");
    e = r << 16 | n << 8 | i, o += b64chs[e >> 18 & 63] + b64chs[e >> 12 & 63] + b64chs[e >> 6 & 63] + b64chs[e & 63];
  }
  return a ? o.slice(0, a - 3) + "===".substring(a) : o;
}, _btoa = _hasbtoa ? (t) => btoa(t) : _hasBuffer ? (t) => Buffer.from(t, "binary").toString("base64") : btoaPolyfill, _fromUint8Array = _hasBuffer ? (t) => Buffer.from(t).toString("base64") : (t) => {
  let r = [];
  for (let n = 0, i = t.length; n < i; n += 4096)
    r.push(_fromCC.apply(null, t.subarray(n, n + 4096)));
  return _btoa(r.join(""));
}, fromUint8Array = (t, e = !1) => e ? _mkUriSafe(_fromUint8Array(t)) : _fromUint8Array(t), atobPolyfill = (t) => {
  if (t = t.replace(/\s+/g, ""), !b64re.test(t))
    throw new TypeError("malformed base64.");
  t += "==".slice(2 - (t.length & 3));
  let e, r = "", n, i;
  for (let o = 0; o < t.length; )
    e = b64tab[t.charAt(o++)] << 18 | b64tab[t.charAt(o++)] << 12 | (n = b64tab[t.charAt(o++)]) << 6 | (i = b64tab[t.charAt(o++)]), r += n === 64 ? _fromCC(e >> 16 & 255) : i === 64 ? _fromCC(e >> 16 & 255, e >> 8 & 255) : _fromCC(e >> 16 & 255, e >> 8 & 255, e & 255);
  return r;
}, _atob = _hasatob ? (t) => atob(_tidyB64(t)) : _hasBuffer ? (t) => Buffer.from(t, "base64").toString("binary") : atobPolyfill, _toUint8Array = _hasBuffer ? (t) => _U8Afrom(Buffer.from(t, "base64")) : (t) => _U8Afrom(_atob(t).split("").map((e) => e.charCodeAt(0))), toUint8Array = (t) => _toUint8Array(_unURI(t)), _unURI = (t) => _tidyB64(t.replace(/[-_]/g, (e) => e == "-" ? "+" : "/")), rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
  return poolPtr > rnds8Pool.length - 16 && (crypto$3.randomFillSync(rnds8Pool), poolPtr = 0), rnds8Pool.slice(poolPtr, poolPtr += 16);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(t) {
  return typeof t == "string" && REGEX.test(t);
}
const byteToHex = [];
for (let t = 0; t < 256; ++t)
  byteToHex.push((t + 256).toString(16).substr(1));
function stringify(t, e = 0) {
  const r = (byteToHex[t[e + 0]] + byteToHex[t[e + 1]] + byteToHex[t[e + 2]] + byteToHex[t[e + 3]] + "-" + byteToHex[t[e + 4]] + byteToHex[t[e + 5]] + "-" + byteToHex[t[e + 6]] + byteToHex[t[e + 7]] + "-" + byteToHex[t[e + 8]] + byteToHex[t[e + 9]] + "-" + byteToHex[t[e + 10]] + byteToHex[t[e + 11]] + byteToHex[t[e + 12]] + byteToHex[t[e + 13]] + byteToHex[t[e + 14]] + byteToHex[t[e + 15]]).toLowerCase();
  if (!validate(r))
    throw TypeError("Stringified UUID is invalid");
  return r;
}
function v4(t, e, r) {
  t = t || {};
  const n = t.random || (t.rng || rng)();
  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, e) {
    r = r || 0;
    for (let i = 0; i < 16; ++i)
      e[r + i] = n[i];
    return e;
  }
  return stringify(n);
}
class Particle {
  constructor(e, r, n, i, o, a) {
    $(this, "signature");
    this.id = e, this.timestamp = r, this.script = n, this.data = i, this.ttl = o, this.initPeerId = a, this.signature = void 0;
  }
  static createNew(e, r, n) {
    return new Particle(v4(), Date.now(), e, Buffer$1.from([]), n, r);
  }
  static fromString(e) {
    const r = JSON.parse(e);
    return new Particle(
      r.id,
      r.timestamp,
      r.script,
      toUint8Array(r.data),
      r.ttl,
      r.init_peer_id
    );
  }
}
const getActualTTL = (t) => t.timestamp + t.ttl - Date.now(), hasExpired = (t) => getActualTTL(t) <= 0, cloneWithNewData = (t, e) => new Particle(t.id, t.timestamp, t.script, e, t.ttl, t.initPeerId), serializeToString = (t) => JSON.stringify({
  action: "Particle",
  id: t.id,
  init_peer_id: t.initPeerId,
  timestamp: t.timestamp,
  ttl: t.ttl,
  script: t.script,
  // TODO: copy signature from a particle after signatures will be implemented on nodes
  signature: [],
  data: t.data && fromUint8Array(t.data)
}), version = "0.46.6", AGENT_VERSION = `js-libp2p/${version}`, IDENTIFY_PROTOCOL_VERSION = "0.1.0", MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id", MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push", MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0", MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
function pbStream(t, e) {
  const r = lpStream(t, e), n = {
    read: async (i, o) => {
      const a = await r.read(o);
      return i.decode(a);
    },
    write: async (i, o, a) => {
      await r.write(o.encode(i), a);
    },
    pb: (i) => ({
      read: async (o) => n.read(i, o),
      write: async (o, a) => n.write(o, i, a),
      unwrap: () => n
    }),
    unwrap: () => r.unwrap()
  };
  return n;
}
var Identify;
(function(t) {
  let e;
  t.codec = () => (e == null && (e = message((r, n, i = {}) => {
    if (i.lengthDelimited !== !1 && n.fork(), r.protocolVersion != null && (n.uint32(42), n.string(r.protocolVersion)), r.agentVersion != null && (n.uint32(50), n.string(r.agentVersion)), r.publicKey != null && (n.uint32(10), n.bytes(r.publicKey)), r.listenAddrs != null)
      for (const o of r.listenAddrs)
        n.uint32(18), n.bytes(o);
    if (r.observedAddr != null && (n.uint32(34), n.bytes(r.observedAddr)), r.protocols != null)
      for (const o of r.protocols)
        n.uint32(26), n.string(o);
    r.signedPeerRecord != null && (n.uint32(66), n.bytes(r.signedPeerRecord)), i.lengthDelimited !== !1 && n.ldelim();
  }, (r, n) => {
    const i = {
      listenAddrs: [],
      protocols: []
    }, o = n == null ? r.len : r.pos + n;
    for (; r.pos < o; ) {
      const a = r.uint32();
      switch (a >>> 3) {
        case 5:
          i.protocolVersion = r.string();
          break;
        case 6:
          i.agentVersion = r.string();
          break;
        case 1:
          i.publicKey = r.bytes();
          break;
        case 2:
          i.listenAddrs.push(r.bytes());
          break;
        case 4:
          i.observedAddr = r.bytes();
          break;
        case 3:
          i.protocols.push(r.string());
          break;
        case 8:
          i.signedPeerRecord = r.bytes();
          break;
        default:
          r.skipType(a & 7);
          break;
      }
    }
    return i;
  })), e), t.encode = (r) => encodeMessage(r, t.codec()), t.decode = (r) => decodeMessage(r, t.codec());
})(Identify || (Identify = {}));
const log$5 = logger$1("libp2p:identify"), MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8, defaultValues = {
  protocolPrefix: "ipfs",
  agentVersion: AGENT_VERSION,
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L48
  timeout: 6e4,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxPushIncomingStreams: 1,
  maxPushOutgoingStreams: 1,
  maxObservedAddresses: 10,
  maxIdentifyMessageSize: 8192,
  runOnConnectionOpen: !0,
  runOnTransientConnection: !0
};
var Pe, Ze;
class DefaultIdentifyService {
  constructor(e, r) {
    ie(this, Pe);
    $(this, "identifyProtocolStr");
    $(this, "identifyPushProtocolStr");
    $(this, "host");
    $(this, "started");
    $(this, "timeout");
    $(this, "peerId");
    $(this, "peerStore");
    $(this, "registrar");
    $(this, "connectionManager");
    $(this, "addressManager");
    $(this, "maxInboundStreams");
    $(this, "maxOutboundStreams");
    $(this, "maxPushIncomingStreams");
    $(this, "maxPushOutgoingStreams");
    $(this, "maxIdentifyMessageSize");
    $(this, "maxObservedAddresses");
    $(this, "events");
    $(this, "runOnTransientConnection");
    this.started = !1, this.peerId = e.peerId, this.peerStore = e.peerStore, this.registrar = e.registrar, this.addressManager = e.addressManager, this.connectionManager = e.connectionManager, this.events = e.events, this.identifyProtocolStr = `/${r.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`, this.identifyPushProtocolStr = `/${r.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`, this.timeout = r.timeout ?? defaultValues.timeout, this.maxInboundStreams = r.maxInboundStreams ?? defaultValues.maxInboundStreams, this.maxOutboundStreams = r.maxOutboundStreams ?? defaultValues.maxOutboundStreams, this.maxPushIncomingStreams = r.maxPushIncomingStreams ?? defaultValues.maxPushIncomingStreams, this.maxPushOutgoingStreams = r.maxPushOutgoingStreams ?? defaultValues.maxPushOutgoingStreams, this.maxIdentifyMessageSize = r.maxIdentifyMessageSize ?? defaultValues.maxIdentifyMessageSize, this.maxObservedAddresses = r.maxObservedAddresses ?? defaultValues.maxObservedAddresses, this.runOnTransientConnection = r.runOnTransientConnection ?? defaultValues.runOnTransientConnection, this.host = {
      protocolVersion: `${r.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: r.agentVersion ?? defaultValues.agentVersion
    }, (r.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) && e.events.addEventListener("connection:open", (n) => {
      const i = n.detail;
      this.identify(i).catch((o) => {
        log$5.error("error during identify trigged by connection:open", o);
      });
    }), e.events.addEventListener("self:peer:update", (n) => {
      this.push().catch((i) => {
        log$5.error(i);
      });
    }), this.host.agentVersion === AGENT_VERSION && (isNode$2 || isElectronMain ? this.host.agentVersion += ` UserAgent=${globalThis.process.version}` : (isBrowser || isWebWorker || isElectronRenderer || isReactNative) && (this.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`));
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started || (await this.peerStore.merge(this.peerId, {
      metadata: {
        AgentVersion: fromString$3(this.host.agentVersion),
        ProtocolVersion: fromString$3(this.host.protocolVersion)
      }
    }), await this.registrar.handle(this.identifyProtocolStr, (e) => {
      this._handleIdentify(e).catch((r) => {
        log$5.error(r);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: this.runOnTransientConnection
    }), await this.registrar.handle(this.identifyPushProtocolStr, (e) => {
      this._handlePush(e).catch((r) => {
        log$5.error(r);
      });
    }, {
      maxInboundStreams: this.maxPushIncomingStreams,
      maxOutboundStreams: this.maxPushOutgoingStreams,
      runOnTransientConnection: this.runOnTransientConnection
    }), this.started = !0);
  }
  async stop() {
    await this.registrar.unhandle(this.identifyProtocolStr), await this.registrar.unhandle(this.identifyPushProtocolStr), this.started = !1;
  }
  /**
   * Send an Identify Push update to the list of connections
   */
  async pushToConnections(e) {
    const r = this.addressManager.getAddresses().map((f) => f.decapsulateCode(getProtocol$1("p2p").code)), n = new PeerRecord({
      peerId: this.peerId,
      multiaddrs: r
    }), i = await RecordEnvelope.seal(n, this.peerId), o = this.registrar.getProtocols(), a = await this.peerStore.get(this.peerId), c = toString$4(a.metadata.get("AgentVersion") ?? fromString$3(this.host.agentVersion)), l = toString$4(a.metadata.get("ProtocolVersion") ?? fromString$3(this.host.protocolVersion)), u = e.map(async (f) => {
      var g;
      let d;
      const p = AbortSignal.timeout(this.timeout);
      try {
        (g = setMaxListeners) == null || g(1 / 0, p);
      } catch {
      }
      try {
        d = await f.newStream([this.identifyPushProtocolStr], {
          signal: p,
          runOnTransientConnection: this.runOnTransientConnection
        }), await pbStream(d, {
          maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
        }).pb(Identify).write({
          listenAddrs: r.map((m) => m.bytes),
          signedPeerRecord: i.marshal(),
          protocols: o,
          agentVersion: c,
          protocolVersion: l
        }, {
          signal: p
        }), await d.close({
          signal: p
        });
      } catch (h) {
        log$5.error("could not push identify update to peer", h), d == null || d.abort(h);
      }
    });
    await Promise.all(u);
  }
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    if (!this.isStarted())
      return;
    const e = [];
    await Promise.all(this.connectionManager.getConnections().map(async (r) => {
      try {
        if (!(await this.peerStore.get(r.remotePeer)).protocols.includes(this.identifyPushProtocolStr))
          return;
        e.push(r);
      } catch (n) {
        if (n.code !== codes$1.ERR_NOT_FOUND)
          throw n;
      }
    })), await this.pushToConnections(e);
  }
  async _identify(e, r = {}) {
    let n;
    r.signal = r.signal ?? AbortSignal.timeout(this.timeout);
    try {
      n = await e.newStream([this.identifyProtocolStr], {
        ...r,
        runOnTransientConnection: this.runOnTransientConnection
      });
      const o = await pbStream(n, {
        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }).pb(Identify).read(r);
      return await n.close(r), o;
    } catch (i) {
      throw log$5.error("error while reading identify message", i), n == null || n.abort(i), i;
    }
  }
  async identify(e, r = {}) {
    const n = await this._identify(e, r), { publicKey: i, protocols: o, observedAddr: a } = n;
    if (i == null)
      throw new CodeError$2("public key was missing from identify message", codes$1.ERR_MISSING_PUBLIC_KEY);
    const c = await peerIdFromKeys(i);
    if (!e.remotePeer.equals(c))
      throw new CodeError$2("identified peer does not match the expected peer", codes$1.ERR_INVALID_PEER);
    if (this.peerId.equals(c))
      throw new CodeError$2("identified peer is our own peer id?", codes$1.ERR_INVALID_PEER);
    const l = getCleanMultiaddr(a);
    log$5("identify completed for peer %p and protocols %o", c, o), log$5("our observed address is %a", l), l != null && this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? 1 / 0) && (log$5("storing our observed address %a", l), this.addressManager.addObservedAddr(l));
    const u = await re(this, Pe, Ze).call(this, e.remotePeer, n), f = {
      peerId: c,
      protocolVersion: n.protocolVersion,
      agentVersion: n.agentVersion,
      publicKey: n.publicKey,
      listenAddrs: n.listenAddrs.map((d) => multiaddr$1(d)),
      observedAddr: n.observedAddr == null ? void 0 : multiaddr$1(n.observedAddr),
      protocols: n.protocols,
      signedPeerRecord: u
    };
    return this.events.safeDispatchEvent("peer:identify", { detail: f }), f;
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async _handleIdentify(e) {
    var o;
    const { connection: r, stream: n } = e, i = AbortSignal.timeout(this.timeout);
    try {
      (o = setMaxListeners) == null || o(1 / 0, i);
    } catch {
    }
    try {
      const a = this.peerId.publicKey ?? new Uint8Array(0), c = await this.peerStore.get(this.peerId), l = this.addressManager.getAddresses().map((d) => d.decapsulateCode(getProtocol$1("p2p").code));
      let u = c.peerRecordEnvelope;
      if (l.length > 0 && u == null) {
        const d = new PeerRecord({
          peerId: this.peerId,
          multiaddrs: l
        });
        u = (await RecordEnvelope.seal(d, this.peerId)).marshal().subarray();
      }
      await pbStream(n).pb(Identify).write({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey: a,
        listenAddrs: l.map((d) => d.bytes),
        signedPeerRecord: u,
        observedAddr: r.remoteAddr.bytes,
        protocols: c.protocols
      }, {
        signal: i
      }), await n.close({
        signal: i
      });
    } catch (a) {
      log$5.error("could not respond to identify request", a), n.abort(a);
    }
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async _handlePush(e) {
    const { connection: r, stream: n } = e;
    try {
      if (this.peerId.equals(r.remotePeer))
        throw new Error("received push from ourselves?");
      const i = {
        signal: AbortSignal.timeout(this.timeout)
      }, a = await pbStream(n, {
        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }).pb(Identify).read(i);
      await n.close(i), await re(this, Pe, Ze).call(this, r.remotePeer, a);
    } catch (i) {
      log$5.error("received invalid message", i), n.abort(i);
      return;
    }
    log$5("handled push from %p", r.remotePeer);
  }
}
Pe = new WeakSet(), Ze = async function(e, r) {
  if (log$5("received identify from %p", e), r == null)
    throw new Error("Message was null or undefined");
  const n = {
    addresses: r.listenAddrs.map((o) => ({
      isCertified: !1,
      multiaddr: multiaddr$1(o)
    })),
    protocols: r.protocols,
    metadata: /* @__PURE__ */ new Map(),
    peerRecordEnvelope: r.signedPeerRecord
  };
  let i;
  if (r.signedPeerRecord != null) {
    log$5("received signedPeerRecord in push from %p", e);
    let o = r.signedPeerRecord;
    const a = await RecordEnvelope.openAndCertify(o, PeerRecord.DOMAIN);
    let c = PeerRecord.createFromProtobuf(a.payload);
    if (!c.peerId.equals(a.peerId))
      throw new Error("signing key does not match PeerId in the PeerRecord");
    if (!e.equals(c.peerId))
      throw new Error("signing key does not match remote PeerId");
    let l;
    try {
      l = await this.peerStore.get(c.peerId);
    } catch (u) {
      if (u.code !== "ERR_NOT_FOUND")
        throw u;
    }
    if (l != null && (n.metadata = l.metadata, l.peerRecordEnvelope != null)) {
      const u = await RecordEnvelope.createFromProtobuf(l.peerRecordEnvelope), f = PeerRecord.createFromProtobuf(u.payload);
      f.seqNumber >= c.seqNumber && (log$5("sequence number was lower or equal to existing sequence number - stored: %d received: %d", f.seqNumber, c.seqNumber), c = f, o = l.peerRecordEnvelope);
    }
    n.peerRecordEnvelope = o, n.addresses = c.multiaddrs.map((u) => ({
      isCertified: !0,
      multiaddr: u
    })), i = {
      seq: c.seqNumber,
      addresses: c.multiaddrs
    };
  } else
    log$5("%p did not send a signed peer record", e);
  return r.agentVersion != null && n.metadata.set("AgentVersion", fromString$3(r.agentVersion)), r.protocolVersion != null && n.metadata.set("ProtocolVersion", fromString$3(r.protocolVersion)), await this.peerStore.patch(e, n), i;
};
function getCleanMultiaddr(t) {
  if (t != null && t.length > 0)
    try {
      return multiaddr$1(t);
    } catch {
    }
}
function identifyService(t = {}) {
  return (e) => new DefaultIdentifyService(e, t);
}
const PING_LENGTH = 32, PROTOCOL_VERSION = "1.0.0", PROTOCOL_NAME$1 = "ping", PROTOCOL_PREFIX = "ipfs", TIMEOUT = 1e4, MAX_INBOUND_STREAMS$1 = 2, MAX_OUTBOUND_STREAMS$1 = 1, log$4 = logger$1("libp2p:ping");
class DefaultPingService {
  constructor(e, r) {
    $(this, "protocol");
    $(this, "components");
    $(this, "started");
    $(this, "timeout");
    $(this, "maxInboundStreams");
    $(this, "maxOutboundStreams");
    $(this, "runOnTransientConnection");
    this.components = e, this.started = !1, this.protocol = `/${r.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME$1}/${PROTOCOL_VERSION}`, this.timeout = r.timeout ?? TIMEOUT, this.maxInboundStreams = r.maxInboundStreams ?? MAX_INBOUND_STREAMS$1, this.maxOutboundStreams = r.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS$1, this.runOnTransientConnection = r.runOnTransientConnection ?? !0;
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: this.runOnTransientConnection
    }), this.started = !0;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol), this.started = !1;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  handleMessage(e) {
    log$4("incoming ping from %p", e.connection.remotePeer);
    const { stream: r } = e, n = Date.now();
    pipe$2(r, r).catch((i) => {
      log$4.error("incoming ping from %p failed with error", e.connection.remotePeer, i);
    }).finally(() => {
      const i = Date.now() - n;
      log$4("incoming ping from %p complete in %dms", e.connection.remotePeer, i);
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   *
   * @param {PeerId|Multiaddr} peer
   * @returns {Promise<number>}
   */
  async ping(e, r = {}) {
    log$4("pinging %p", e);
    const n = Date.now(), i = randomBytes$1(PING_LENGTH), o = await this.components.connectionManager.openConnection(e, r);
    let a;
    r.signal = r.signal ?? AbortSignal.timeout(this.timeout);
    try {
      a = await o.newStream(this.protocol, {
        ...r,
        runOnTransientConnection: this.runOnTransientConnection
      });
      const c = abortableDuplex(a, r.signal), l = await pipe$2([i], c, async (f) => first$2(f)), u = Date.now() - n;
      if (l == null)
        throw new CodeError$2(`Did not receive a ping ack after ${u}ms`, codes$1.ERR_WRONG_PING_ACK);
      if (!equals$2(i, l.subarray()))
        throw new CodeError$2(`Received wrong ping ack after ${u}ms`, codes$1.ERR_WRONG_PING_ACK);
      return log$4("ping %p complete in %dms", o.remotePeer, u), u;
    } catch (c) {
      throw log$4.error("error while pinging %p", o.remotePeer, c), a == null || a.abort(c), c;
    } finally {
      a != null && await a.close();
    }
  }
}
function pingService(t = {}) {
  return (e) => new DefaultPingService(e, t);
}
const log$3 = logger("connection"), PROTOCOL_NAME = "/fluence/particle/2.0.0";
class RelayConnection {
  constructor(e) {
    $(this, "relayAddress");
    $(this, "lib2p2Peer", null);
    $(this, "particleSource", new cjs.Subject());
    this.config = e, this.relayAddress = multiaddr(this.config.relayAddress), throwIfHasNoPeerId(this.relayAddress);
  }
  getRelayPeerId() {
    return this.relayAddress.getPeerId();
  }
  supportsRelay() {
    return !0;
  }
  async start() {
    if (this.lib2p2Peer !== null)
      return;
    this.lib2p2Peer = await createLibp2p({
      peerId: this.config.peerId,
      transports: [
        webSockets({
          filter: all
        })
      ],
      streamMuxers: [yamux()],
      connectionEncryption: [noise()],
      connectionManager: {
        dialTimeout: this.config.dialTimeoutMs
      },
      connectionGater: {
        // By default, this function forbids connections to private peers. For example multiaddr with ip 127.0.0.1 isn't allowed
        denyDialMultiaddr: () => Promise.resolve(!1)
      },
      services: {
        identify: identifyService(),
        ping: pingService()
      }
    });
    const e = (await this.lib2p2Peer.peerStore.get(this.lib2p2Peer.peerId)).protocols;
    await this.lib2p2Peer.peerStore.patch(this.lib2p2Peer.peerId, {
      protocols: [...e, PROTOCOL_NAME]
    }), await this.connect();
  }
  async stop() {
    this.lib2p2Peer !== null && (await this.lib2p2Peer.unhandle(PROTOCOL_NAME), await this.lib2p2Peer.stop());
  }
  async sendParticle(e, r) {
    if (this.lib2p2Peer === null)
      throw new Error("Relay connection is not started");
    if (e.length !== 1 && e[0] !== this.getRelayPeerId())
      throw new Error(
        `Relay connection only accepts peer id of the connected relay. Got: ${JSON.stringify(
          e
        )} instead.`
      );
    log$3.trace("sending particle...");
    const n = await this.lib2p2Peer.dialProtocol(this.relayAddress, PROTOCOL_NAME);
    log$3.trace("created stream with id ", n.id);
    const i = n.sink;
    await pipe$3(
      [fromString$1(serializeToString(r))],
      encode$c(),
      i
    ), log$3.trace("data written to sink");
  }
  async connect() {
    var e;
    if (this.lib2p2Peer === null)
      throw new Error("Relay connection is not started");
    await this.lib2p2Peer.handle(
      [PROTOCOL_NAME],
      async ({ connection: r, stream: n }) => {
        pipe$3(
          n.source,
          // @ts-ignore
          decode$f(),
          // @ts-ignore
          (i) => map$2(i, (o) => toString$2(o.subarray())),
          async (i) => {
            try {
              for await (const o of i)
                try {
                  const a = Particle.fromString(o);
                  log$3.trace("got particle from stream with id %s and particle id %s", n.id, a.id), this.particleSource.next(a);
                } catch (a) {
                  log$3.error("error on handling a new incoming message: %j", a);
                }
            } catch (o) {
              log$3.error("connection closed: %j", o);
            }
          }
        );
      },
      {
        maxInboundStreams: this.config.maxInboundStreams,
        maxOutboundStreams: this.config.maxOutboundStreams
      }
    ), log$3.debug("dialing to the node with client's address: %s", this.lib2p2Peer.peerId.toString());
    try {
      await this.lib2p2Peer.dial(this.relayAddress);
    } catch (r) {
      if (r.name === "AggregateError" && ((e = r._errors) == null ? void 0 : e.length) === 1) {
        const n = r._errors[0];
        throw new Error(`Error dialing node ${this.relayAddress}:
${n.code}
${n.message}`);
      } else
        throw r;
    }
  }
}
function base(t) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), r = 0; r < e.length; r++)
    e[r] = 255;
  for (var n = 0; n < t.length; n++) {
    var i = t.charAt(n), o = i.charCodeAt(0);
    if (e[o] !== 255)
      throw new TypeError(i + " is ambiguous");
    e[o] = n;
  }
  var a = t.length, c = t.charAt(0), l = Math.log(a) / Math.log(256), u = Math.log(256) / Math.log(a);
  function f(g) {
    if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (g.length === 0)
      return "";
    for (var h = 0, m = 0, y = 0, b = g.length; y !== b && g[y] === 0; )
      y++, h++;
    for (var v = (b - y) * u + 1 >>> 0, _ = new Uint8Array(v); y !== b; ) {
      for (var E = g[y], w = 0, S = v - 1; (E !== 0 || w < m) && S !== -1; S--, w++)
        E += 256 * _[S] >>> 0, _[S] = E % a >>> 0, E = E / a >>> 0;
      if (E !== 0)
        throw new Error("Non-zero carry");
      m = w, y++;
    }
    for (var x = v - m; x !== v && _[x] === 0; )
      x++;
    for (var I = c.repeat(h); x < v; ++x)
      I += t.charAt(_[x]);
    return I;
  }
  function d(g) {
    if (typeof g != "string")
      throw new TypeError("Expected String");
    if (g.length === 0)
      return new Uint8Array();
    for (var h = 0, m = 0, y = 0; g[h] === c; )
      m++, h++;
    for (var b = (g.length - h) * l + 1 >>> 0, v = new Uint8Array(b); g[h]; ) {
      var _ = e[g.charCodeAt(h)];
      if (_ === 255)
        return;
      for (var E = 0, w = b - 1; (_ !== 0 || E < y) && w !== -1; w--, E++)
        _ += a * v[w] >>> 0, v[w] = _ % 256 >>> 0, _ = _ / 256 >>> 0;
      if (_ !== 0)
        throw new Error("Non-zero carry");
      y = E, h++;
    }
    for (var S = b - y; S !== b && v[S] === 0; )
      S++;
    for (var x = new Uint8Array(m + (b - S)), I = m; S !== b; )
      x[I++] = v[S++];
    return x;
  }
  function p(g) {
    var h = d(g);
    if (h)
      return h;
    throw new Error("Non-base" + a + " character");
  }
  return {
    encode: f,
    decodeUnsafe: d,
    decode: p
  };
}
var src = base;
const basex = src, ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET);
class KeyPair {
  constructor(e, r) {
    this.key = e, this.libp2pPeerId = r;
  }
  /**
   * Key pair in libp2p format. Used for backward compatibility with the current FluencePeer implementation
   */
  getLibp2pPeerId() {
    return this.libp2pPeerId;
  }
  /**
   * Generates new KeyPair from ed25519 private key represented as a 32 byte array
   * @param seed - Any sequence of 32 bytes
   * @returns - Promise with the created KeyPair
   */
  static async fromEd25519SK(e) {
    const r = await generateKeyPairFromSeed("Ed25519", e), n = await createFromPrivKey(r);
    return new KeyPair(r, n);
  }
  /**
   * Generates new KeyPair with a random secret key
   * @returns - Promise with the created KeyPair
   */
  static async randomEd25519() {
    const e = await generateKeyPair("Ed25519"), r = await createFromPrivKey(e);
    return new KeyPair(e, r);
  }
  getPeerId() {
    return this.libp2pPeerId.toString();
  }
  /**
   * @returns 32 byte private key
   */
  toEd25519PrivateKey() {
    return this.key.marshal().subarray(0, 32);
  }
  signBytes(e) {
    return this.key.sign(e);
  }
  verify(e, r) {
    return this.key.public.verify(e, r);
  }
}
const fromOpts = (t) => t.source === "random" ? KeyPair.randomEd25519() : KeyPair.fromEd25519SK(t.source);
var dist = {}, types = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.KeyPairFormat = void 0, function(e) {
    e[e.Ed25519 = 0] = "Ed25519";
  }(t.KeyPairFormat || (t.KeyPairFormat = {}));
})(types);
var avmHelpers = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(t, e, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(a) {
      a(o);
    });
  }
  return new (r || (r = Promise))(function(o, a) {
    function c(f) {
      try {
        u(n.next(f));
      } catch (d) {
        a(d);
      }
    }
    function l(f) {
      try {
        u(n.throw(f));
      } catch (d) {
        a(d);
      }
    }
    function u(f) {
      f.done ? o(f.value) : i(f.value).then(c, l);
    }
    u((n = n.apply(t, e || [])).next());
  });
}, __generator = commonjsGlobal && commonjsGlobal.__generator || function(t, e) {
  var r = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, n, i, o, a;
  return a = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function c(u) {
    return function(f) {
      return l([u, f]);
    };
  }
  function l(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, u[0] && (r = 0)), r; )
      try {
        if (n = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done)
          return o;
        switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
          case 0:
          case 1:
            o = u;
            break;
          case 4:
            return r.label++, { value: u[1], done: !1 };
          case 5:
            r.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (o = r.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < o[1]) {
              r.label = o[1], o = u;
              break;
            }
            if (o && r.label < o[2]) {
              r.label = o[2], r.ops.push(u);
              break;
            }
            o[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = e.call(t, r);
      } catch (f) {
        u = [6, f], i = 0;
      } finally {
        n = o = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
};
Object.defineProperty(avmHelpers, "__esModule", { value: !0 });
avmHelpers.callAvm = avmHelpers.deserializeAvmResult = avmHelpers.serializeAvmArgs = void 0;
var decoder = new TextDecoder(), encoder = new TextEncoder();
function serializeAvmArgs(t, e, r, n, i) {
  for (var o = {}, a = 0, c = i; a < c.length; a++) {
    var l = c[a], u = l[0], f = l[1];
    o[u] = {
      ret_code: f.retCode,
      result: f.result
    };
  }
  var d = encoder.encode(JSON.stringify(o)), p = {
    init_peer_id: t.initPeerId,
    current_peer_id: t.currentPeerId,
    key_format: t.keyFormat,
    secret_key_bytes: Array.from(t.secretKeyBytes),
    timestamp: t.timestamp,
    ttl: t.ttl,
    particle_id: t.particleId
  };
  return [e, Array.from(r), Array.from(n), p, Array.from(d)];
}
avmHelpers.serializeAvmArgs = serializeAvmArgs;
function deserializeAvmResult(t) {
  var e = decoder.decode(new Uint8Array(t.call_requests)), r;
  try {
    e.length === 0 ? r = {} : r = JSON.parse(e);
  } catch (l) {
    throw "Couldn't parse call requests: " + l + ". Original string is: " + e;
  }
  var n = [];
  for (var i in r) {
    var o = r[i], a = void 0, c = void 0;
    try {
      a = JSON.parse(o.arguments);
    } catch (l) {
      throw "Couldn't parse arguments: " + l + ". Original string is: " + a;
    }
    try {
      c = JSON.parse(o.tetraplets);
    } catch (l) {
      throw "Couldn't parse tetraplets: " + l + ". Original string is: " + c;
    }
    n.push([
      i,
      {
        serviceId: o.service_id,
        functionName: o.function_name,
        arguments: a,
        tetraplets: c
      }
    ]);
  }
  return {
    retCode: t.ret_code,
    errorMessage: t.error_message,
    data: t.data,
    nextPeerPks: t.next_peer_pks,
    callRequests: n
  };
}
avmHelpers.deserializeAvmResult = deserializeAvmResult;
function callAvm(t, e, r, n, i, o) {
  return __awaiter$1(this, void 0, void 0, function() {
    var a, c;
    return __generator(this, function(l) {
      switch (l.label) {
        case 0:
          return a = serializeAvmArgs(e, r, n, i, o), [4, t(a)];
        case 1:
          return c = l.sent(), [2, deserializeAvmResult(c)];
      }
    });
  });
}
avmHelpers.callAvm = callAvm;
(function(t) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, i, o, a) {
    a === void 0 && (a = o);
    var c = Object.getOwnPropertyDescriptor(i, o);
    (!c || ("get" in c ? !i.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return i[o];
    } }), Object.defineProperty(n, a, c);
  } : function(n, i, o, a) {
    a === void 0 && (a = o), n[a] = i[o];
  }), r = commonjsGlobal && commonjsGlobal.__exportStar || function(n, i) {
    for (var o in n)
      o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && e(i, n, o);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(types, t), r(avmHelpers, t);
})(dist);
const logLevelToEnv = (t) => ({
  WASM_LOG: t
}), defaultCallParameters = {
  host_id: "",
  init_peer_id: "",
  particle_id: "",
  service_creator_peer_id: "",
  service_id: "",
  tetraplets: []
}, allowTetraplet = (t) => (e) => {
  const r = e.tetraplets.data[0];
  return t(r);
}, allowServiceFn = (t, e) => allowTetraplet((r) => r.service_id === t && r.function_name === e), allowOnlyParticleOriginatedAt = (t) => (e) => e.initPeerId === t, and = (...t) => (e) => t.every((r) => r(e)), or = (...t) => (e) => t.some((r) => r(e)), defaultSigGuard = (t) => and(
  allowOnlyParticleOriginatedAt(t),
  or(
    allowServiceFn("trust-graph", "get_trust_bytes"),
    allowServiceFn("trust-graph", "get_revocation_bytes"),
    allowServiceFn("registry", "get_key_bytes"),
    allowServiceFn("registry", "get_record_bytes"),
    allowServiceFn("registry", "get_record_metadata_bytes"),
    allowServiceFn("registry", "get_tombstone_bytes")
  )
);
class Sig {
  constructor(e) {
    /**
     * Configurable security guard for sign method
     */
    $(this, "securityGuard", (e) => !0);
    this.keyPair = e;
  }
  /**
   * Gets the public key of KeyPair. Required by aqua
   */
  get_peer_id() {
    return this.keyPair.getPeerId();
  }
  /**
   * Signs the data using key pair's private key. Required by aqua
   */
  async sign(e, r) {
    if (!this.securityGuard(r))
      return {
        success: !1,
        error: "Security guard validation failed",
        signature: null
      };
    const n = await this.keyPair.signBytes(Uint8Array.from(e));
    return {
      success: !0,
      error: null,
      signature: Array.from(n)
    };
  }
  /**
   * Verifies the signature. Required by aqua
   */
  verify(e, r) {
    return this.keyPair.verify(Uint8Array.from(r), Uint8Array.from(e));
  }
}
var lib = {}, symbols = {};
Object.defineProperty(symbols, "__esModule", { value: !0 });
symbols.AnonymousSelect = symbols.NamedSelect = symbols.Not = symbols.Guard = symbols.PatternKind = void 0;
symbols.PatternKind = Symbol("@ts-pattern/pattern-kind");
symbols.Guard = Symbol("@ts-pattern/guard");
symbols.Not = Symbol("@ts-pattern/not");
symbols.NamedSelect = Symbol("@ts-pattern/named-select");
symbols.AnonymousSelect = Symbol("@ts-pattern/anonymous-select");
var guards = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.instanceOf = t.select = t.ANONYMOUS_SELECT_KEY = t.not = t.when = void 0;
  const e = symbols, r = (c) => ({
    [e.PatternKind]: e.Guard,
    [e.Guard]: c
  });
  t.when = r;
  const n = (c) => ({
    [e.PatternKind]: e.Not,
    [e.Not]: c
  });
  t.not = n, t.ANONYMOUS_SELECT_KEY = "@ts-pattern/__anonymous-select-key";
  function i(c) {
    return c === void 0 ? {
      [e.PatternKind]: e.AnonymousSelect
    } : {
      [e.PatternKind]: e.NamedSelect,
      [e.NamedSelect]: c
    };
  }
  t.select = i;
  function o(c) {
    return (l) => l instanceof c;
  }
  const a = (c) => (0, t.when)(o(c));
  t.instanceOf = a;
})(guards);
var wildcards = {};
Object.defineProperty(wildcards, "__esModule", { value: !0 });
wildcards.__ = void 0;
const guards_1 = guards;
function isUnknown(t) {
  return !0;
}
function isNumber(t) {
  return typeof t == "number";
}
function numberIsNaN(t) {
  return Number.isNaN(t);
}
function isString(t) {
  return typeof t == "string";
}
function isBoolean(t) {
  return typeof t == "boolean";
}
function isNullish(t) {
  return t == null;
}
const unknownGuard = (0, guards_1.when)(isUnknown), stringGuard = (0, guards_1.when)(isString), numberGuard = (0, guards_1.when)(isNumber), NaNGuard = (0, guards_1.when)(numberIsNaN), booleanGuard = (0, guards_1.when)(isBoolean), nullishGuard = (0, guards_1.when)(isNullish);
wildcards.__ = Object.assign(unknownGuard, {
  string: stringGuard,
  number: numberGuard,
  NaN: NaNGuard,
  boolean: booleanGuard,
  nullish: nullishGuard
});
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.isMatching = t.match = t.instanceOf = t.select = t.not = t.when = t.__ = void 0;
  const e = symbols, r = guards;
  Object.defineProperty(t, "when", { enumerable: !0, get: function() {
    return r.when;
  } }), Object.defineProperty(t, "not", { enumerable: !0, get: function() {
    return r.not;
  } }), Object.defineProperty(t, "select", { enumerable: !0, get: function() {
    return r.select;
  } }), Object.defineProperty(t, "instanceOf", { enumerable: !0, get: function() {
    return r.instanceOf;
  } });
  const n = wildcards;
  Object.defineProperty(t, "__", { enumerable: !0, get: function() {
    return n.__;
  } });
  const i = (g) => o(g, []);
  t.match = i;
  const o = (g, h) => {
    const m = () => {
      const y = h.find(({ test: b }) => b(g));
      if (!y) {
        let b;
        try {
          b = JSON.stringify(g);
        } catch {
          b = g;
        }
        throw new Error(`Pattern matching error: no pattern matches value ${b}`);
      }
      return y.handler(y.select(g), g);
    };
    return {
      with(...y) {
        const b = y[y.length - 1], v = [], _ = [];
        for (let S = 0; S < y.length - 1; S++) {
          const x = y[S];
          typeof x == "function" ? _.push(x) : v.push(x);
        }
        let E = {};
        const w = (S) => Boolean(v.some((x) => d(x, S, (I, C) => {
          E[I] = C;
        })) && _.every((x) => x(S)));
        return o(g, h.concat([
          {
            test: w,
            handler: b,
            select: (S) => Object.keys(E).length ? E[r.ANONYMOUS_SELECT_KEY] !== void 0 ? E[r.ANONYMOUS_SELECT_KEY] : E : S
          }
        ]));
      },
      when: (y, b) => o(g, h.concat([
        {
          test: y,
          handler: b,
          select: (v) => v
        }
      ])),
      otherwise: (y) => o(g, h.concat([
        {
          test: () => !0,
          handler: y,
          select: (b) => b
        }
      ])).run(),
      exhaustive: () => m(),
      run: m
    };
  }, a = (g) => Boolean(g && typeof g == "object"), c = (g) => {
    const h = g;
    return h && h[e.PatternKind] === e.Guard;
  }, l = (g) => {
    const h = g;
    return h && h[e.PatternKind] === e.Not;
  }, u = (g) => {
    const h = g;
    return h && h[e.PatternKind] === e.NamedSelect;
  }, f = (g) => {
    const h = g;
    return h && h[e.PatternKind] === e.AnonymousSelect;
  }, d = (g, h, m) => {
    if (a(g)) {
      if (c(g))
        return Boolean(g[e.Guard](h));
      if (u(g))
        return m(g[e.NamedSelect], h), !0;
      if (f(g))
        return m(r.ANONYMOUS_SELECT_KEY, h), !0;
      if (l(g))
        return !d(g[e.Not], h, m);
      if (!a(h))
        return !1;
      if (Array.isArray(g)) {
        if (!Array.isArray(h))
          return !1;
        if (g.length === 1) {
          const y = {}, b = (_, E) => {
            y[_] = (y[_] || []).concat([E]);
          }, v = h.every((_) => d(g[0], _, b));
          return v && Object.keys(y).forEach((_) => m(_, y[_])), v;
        }
        return g.length === h.length ? g.every((y, b) => d(y, h[b], m)) : !1;
      }
      if (g instanceof Map)
        return h instanceof Map ? [...g.keys()].every((y) => d(g.get(y), h.get(y), m)) : !1;
      if (g instanceof Set) {
        if (!(h instanceof Set))
          return !1;
        if (g.size === 0)
          return h.size === 0;
        if (g.size === 1) {
          const [y] = [...g.values()];
          return Object.values(n.__).includes(y) ? d([y], [...h.values()], m) : h.has(y);
        }
        return [...g.values()].every((y) => h.has(y));
      }
      return Object.keys(g).every((y) => y in h && d(
        // @ts-ignore
        g[y],
        // @ts-ignore
        h[y],
        m
      ));
    }
    return h === g;
  };
  function p(...g) {
    if (g.length === 1) {
      const [h] = g;
      return (m) => d(h, m, () => {
      });
    }
    if (g.length === 2) {
      const [h, m] = g;
      return d(h, m, () => {
      });
    }
    throw new Error(`isMatching wasn't given enough arguments: expected 1 or 2, received ${g.length}.`);
  }
  t.isMatching = p;
})(lib);
const aqua2ts = (t, e) => lib.match(e).with({ tag: "nil" }, () => null).with({ tag: "option" }, (n) => t.length === 0 ? null : aqua2ts(t[0], n.type)).with({ tag: "scalar" }, { tag: "bottomType" }, { tag: "topType" }, () => t).with({ tag: "array" }, (n) => t.map((i) => aqua2ts(i, n.type))).with({ tag: "struct" }, (n) => Object.entries(n.fields).reduce((i, [o, a]) => {
  const c = aqua2ts(t[o], a);
  return { ...i, [o]: c };
}, {})).with({ tag: "labeledProduct" }, (n) => Object.entries(n.fields).reduce((i, [o, a]) => {
  const c = aqua2ts(t[o], a);
  return { ...i, [o]: c };
}, {})).with({ tag: "unlabeledProduct" }, (n) => n.items.map((i, o) => aqua2ts(t[o], i))).otherwise(() => {
  throw new Error("Unexpected tag: " + jsonify(e));
}), aquaArgs2Ts = (t, e) => {
  const r = lib.match(e.domain).with({ tag: "labeledProduct" }, (n) => Object.values(n.fields)).with({ tag: "unlabeledProduct" }, (n) => n.items).with({ tag: "nil" }, (n) => []).otherwise(() => {
    throw new Error("Unexpected tag: " + jsonify(e.domain));
  });
  if (t.args.length !== r.length)
    throw new Error(`incorrect number of arguments, expected: ${r.length}, got: ${t.args.length}`);
  return t.args.map((n, i) => aqua2ts(n, r[i]));
}, ts2aqua = (t, e) => lib.match(e).with({ tag: "nil" }, () => null).with({ tag: "option" }, (n) => t == null ? [] : [ts2aqua(t, n.type)]).with({ tag: "scalar" }, { tag: "bottomType" }, { tag: "topType" }, () => t).with({ tag: "array" }, (n) => t.map((i) => ts2aqua(i, n.type))).with({ tag: "struct" }, (n) => Object.entries(n.fields).reduce((i, [o, a]) => {
  const c = ts2aqua(t[o], a);
  return { ...i, [o]: c };
}, {})).with({ tag: "labeledProduct" }, (n) => Object.entries(n.fields).reduce((i, [o, a]) => {
  const c = ts2aqua(t[o], a);
  return { ...i, [o]: c };
}, {})).with({ tag: "unlabeledProduct" }, (n) => n.items.map((i, o) => ts2aqua(t[o], i))).otherwise(() => {
  throw new Error("Unexpected tag: " + jsonify(e));
}), returnType2Aqua = (t, e) => e.codomain.tag === "nil" ? {} : e.codomain.items.length === 0 ? {} : e.codomain.items.length === 1 ? ts2aqua(t, e.codomain.items[0]) : e.codomain.items.map((r, n) => ts2aqua(t[n], r)), responseServiceValue2ts = (t, e) => lib.match(e.codomain).with({ tag: "nil" }, () => {
}).with({ tag: "unlabeledProduct" }, (r) => {
  if (r.items.length !== 0)
    return r.items.length === 1 ? aqua2ts(t.args[0], r.items[0]) : t.args.map((n, i) => aqua2ts(n, r.items[i]));
}).exhaustive();
var ResultCodes = /* @__PURE__ */ ((t) => (t[t.success = 0] = "success", t[t.error = 1] = "error", t))(ResultCodes || {});
const injectRelayService = (t, e) => ({
  serviceId: t.names.getDataSrv,
  fnName: t.names.relay,
  handler: () => ({
    retCode: ResultCodes.success,
    result: e.internals.getRelayPeerId()
  })
}), injectValueService = (t, e, r, n) => ({
  serviceId: t,
  fnName: e,
  handler: () => ({
    retCode: ResultCodes.success,
    result: ts2aqua(n, r)
  })
}), responseService = (t, e) => ({
  serviceId: t.names.responseSrv,
  fnName: t.names.responseFnName,
  handler: (r) => {
    const n = responseServiceValue2ts(r, t.arrow);
    return setTimeout(() => {
      e(n);
    }, 0), {
      retCode: ResultCodes.success,
      result: {}
    };
  }
}), errorHandlingService = (t, e) => ({
  serviceId: t.names.errorHandlingSrv,
  fnName: t.names.errorFnName,
  handler: (r) => {
    const [n, i] = r.args;
    return setTimeout(() => {
      e(n);
    }, 0), {
      retCode: ResultCodes.success,
      result: {}
    };
  }
}), userHandlerService = (t, e, r) => {
  const [n, i] = e;
  return {
    serviceId: t,
    fnName: n,
    handler: async (o) => {
      const a = [...aquaArgs2Ts(o, i), extractCallParams(o, i)], c = await r.apply(null, a), l = returnType2Aqua(c, i);
      return {
        retCode: ResultCodes.success,
        result: l
      };
    }
  };
}, extractCallParams = (t, e) => {
  const r = lib.match(e.domain).with({ tag: "nil" }, () => []).with({ tag: "labeledProduct" }, (o) => Object.keys(o.fields)).with({ tag: "unlabeledProduct" }, (o) => o.items.map((a, c) => "arg" + c)).exhaustive(), n = {};
  for (let o = 0; o < t.args.length; o++)
    r[o] && (n[r[o]] = t.tetraplets[o]);
  return {
    ...t.particleContext,
    tetraplets: n
  };
}, registerParticleScopeService = (t, e, r) => {
  t.internals.regHandler.forParticle(e.id, r.serviceId, r.fnName, r.handler);
}, registerGlobalService = (t, e) => {
  t.internals.regHandler.common(e.serviceId, e.fnName, e.handler);
}, log$2 = logger("aqua"), registerService = ({ peer: t, def: e, serviceId: r, service: n }) => {
  log$2.trace("registering aqua service %o", { def: e, serviceId: r, service: n });
  const o = (e.functions.tag === "nil" ? [] : Object.keys(e.functions.fields)).filter((c) => !(c in n));
  if (o.length)
    throw new Error(
      `Error registering service ${r}: missing functions: ` + o.map((c) => "'" + c + "'").join(", ")
    );
  if (r || (r = e.defaultServiceId), !r)
    throw new Error("Service ID must be specified");
  const a = e.functions.tag === "nil" ? [] : Object.entries(e.functions.fields);
  for (let c of a) {
    let [l, u] = c;
    const f = n[l].bind(n), d = userHandlerService(r, c, f);
    registerGlobalService(t, d);
  }
  log$2.trace("aqua service registered %s", r);
};
function registerSig(t, e, r) {
  registerService({
    peer: t,
    service: r,
    serviceId: e,
    def: {
      defaultServiceId: "sig",
      functions: {
        tag: "labeledProduct",
        fields: {
          get_peer_id: {
            tag: "arrow",
            domain: {
              tag: "nil"
            },
            codomain: {
              tag: "unlabeledProduct",
              items: [
                {
                  tag: "scalar",
                  name: "string"
                }
              ]
            }
          },
          sign: {
            tag: "arrow",
            domain: {
              tag: "labeledProduct",
              fields: {
                data: {
                  tag: "array",
                  type: {
                    tag: "scalar",
                    name: "u8"
                  }
                }
              }
            },
            codomain: {
              tag: "unlabeledProduct",
              items: [
                {
                  tag: "struct",
                  name: "SignResult",
                  fields: {
                    error: {
                      tag: "option",
                      type: {
                        tag: "scalar",
                        name: "string"
                      }
                    },
                    signature: {
                      tag: "option",
                      type: {
                        tag: "array",
                        type: {
                          tag: "scalar",
                          name: "u8"
                        }
                      }
                    },
                    success: {
                      tag: "scalar",
                      name: "bool"
                    }
                  }
                }
              ]
            }
          },
          verify: {
            tag: "arrow",
            domain: {
              tag: "labeledProduct",
              fields: {
                signature: {
                  tag: "array",
                  type: {
                    tag: "scalar",
                    name: "u8"
                  }
                },
                data: {
                  tag: "array",
                  type: {
                    tag: "scalar",
                    name: "u8"
                  }
                }
              }
            },
            codomain: {
              tag: "unlabeledProduct",
              items: [
                {
                  tag: "scalar",
                  name: "bool"
                }
              ]
            }
          }
        }
      }
    }
  });
}
function registerSrv(t, e, r) {
  registerService({
    peer: t,
    serviceId: e,
    service: r,
    def: {
      defaultServiceId: "single_module_srv",
      functions: {
        tag: "labeledProduct",
        fields: {
          create: {
            tag: "arrow",
            domain: {
              tag: "labeledProduct",
              fields: {
                wasm_b64_content: {
                  tag: "scalar",
                  name: "string"
                }
              }
            },
            codomain: {
              tag: "unlabeledProduct",
              items: [
                {
                  tag: "struct",
                  name: "ServiceCreationResult",
                  fields: {
                    error: {
                      tag: "option",
                      type: {
                        tag: "scalar",
                        name: "string"
                      }
                    },
                    service_id: {
                      tag: "option",
                      type: {
                        tag: "scalar",
                        name: "string"
                      }
                    },
                    success: {
                      tag: "scalar",
                      name: "bool"
                    }
                  }
                }
              ]
            }
          },
          list: {
            tag: "arrow",
            domain: {
              tag: "nil"
            },
            codomain: {
              tag: "unlabeledProduct",
              items: [
                {
                  tag: "array",
                  type: {
                    tag: "scalar",
                    name: "string"
                  }
                }
              ]
            }
          },
          remove: {
            tag: "arrow",
            domain: {
              tag: "labeledProduct",
              fields: {
                service_id: {
                  tag: "scalar",
                  name: "string"
                }
              }
            },
            codomain: {
              tag: "unlabeledProduct",
              items: [
                {
                  tag: "struct",
                  name: "RemoveResult",
                  fields: {
                    error: {
                      tag: "option",
                      type: {
                        tag: "scalar",
                        name: "string"
                      }
                    },
                    success: {
                      tag: "scalar",
                      name: "bool"
                    }
                  }
                }
              ]
            }
          }
        }
      }
    }
  });
}
function registerTracing(t, e, r) {
  registerService({
    peer: t,
    serviceId: e,
    service: r,
    def: {
      defaultServiceId: "tracingSrv",
      functions: {
        tag: "labeledProduct",
        fields: {
          tracingEvent: {
            tag: "arrow",
            domain: {
              tag: "labeledProduct",
              fields: {
                arrowName: {
                  tag: "scalar",
                  name: "string"
                },
                event: {
                  tag: "scalar",
                  name: "string"
                }
              }
            },
            codomain: {
              tag: "nil"
            }
          }
        }
      }
    }
  });
}
const defaultGuard = (t) => allowOnlyParticleOriginatedAt(t.keyPair.getPeerId());
class Srv {
  constructor(e) {
    $(this, "services", /* @__PURE__ */ new Set());
    $(this, "securityGuard_create");
    $(this, "securityGuard_remove");
    this.peer = e, this.securityGuard_create = defaultGuard(this.peer), this.securityGuard_remove = defaultGuard(this.peer);
  }
  async create(e, r) {
    if (!this.securityGuard_create(r))
      return {
        success: !1,
        error: "Security guard validation failed",
        service_id: null
      };
    try {
      const n = v4(), i = Buffer$1.from(e, "base64");
      return await this.peer.registerMarineService(i, n), this.services.add(n), {
        success: !0,
        service_id: n,
        error: null
      };
    } catch (n) {
      return {
        success: !0,
        service_id: null,
        error: n.message
      };
    }
  }
  async remove(e, r) {
    return this.securityGuard_remove(r) ? this.services.has(e) ? (await this.peer.removeMarineService(e), this.services.delete(e), {
      success: !0,
      error: null
    }) : {
      success: !1,
      error: `Service with id ${e} not found`
    } : {
      success: !1,
      error: "Security guard validation failed",
      service_id: null
    };
  }
  list() {
    return Array.from(this.services.values());
  }
}
class Tracing {
  tracingEvent(e, r, n) {
    console.log("[%s] (%s) %s", n.particleId, e, r);
  }
}
const { encode, decode } = bs58, success = (t) => ({
  result: t,
  retCode: ResultCodes.success
}), error = (t) => ({
  result: t,
  retCode: ResultCodes.error
}), errorNotImpl = (t) => error(`The JS implementation of Peer does not support "${t}"`), makeJsonImpl = (t) => {
  const [e, ...r] = t, n = {};
  for (let o = 0; o < r.length / 2; o++) {
    const a = r[o * 2];
    if (!isString$1(a))
      return error(`Argument ${a} is expected to be string`);
    const c = r[o * 2 + 1];
    n[a] = c;
  }
  const i = { ...e, ...n };
  return success(i);
}, builtInServices = {
  peer: {
    identify: () => success({
      external_addresses: [],
      // TODO: remove hardcoded values
      node_version: "js-0.23.0",
      air_version: "js-0.24.2"
    }),
    timestamp_ms: () => success(Date.now()),
    timestamp_sec: () => success(Math.floor(Date.now() / 1e3)),
    is_connected: () => errorNotImpl("peer.is_connected"),
    connect: () => errorNotImpl("peer.connect"),
    get_contact: () => errorNotImpl("peer.get_contact"),
    timeout: (t) => {
      if (t.args.length !== 2)
        return error("timeout accepts exactly two arguments: timeout duration in ms and a message string");
      const e = t.args[0], r = t.args[1];
      return new Promise((n) => {
        setTimeout(() => {
          const i = success(r);
          n(i);
        }, e);
      });
    }
  },
  kad: {
    neighborhood: () => errorNotImpl("kad.neighborhood"),
    merge: () => errorNotImpl("kad.merge")
  },
  srv: {
    list: () => errorNotImpl("srv.list"),
    create: () => errorNotImpl("srv.create"),
    get_interface: () => errorNotImpl("srv.get_interface"),
    resolve_alias: () => errorNotImpl("srv.resolve_alias"),
    add_alias: () => errorNotImpl("srv.add_alias"),
    remove: () => errorNotImpl("srv.remove")
  },
  dist: {
    add_module_from_vault: () => errorNotImpl("dist.add_module_from_vault"),
    add_module: () => errorNotImpl("dist.add_module"),
    add_blueprint: () => errorNotImpl("dist.add_blueprint"),
    make_module_config: () => errorNotImpl("dist.make_module_config"),
    load_module_config: () => errorNotImpl("dist.load_module_config"),
    default_module_config: () => errorNotImpl("dist.default_module_config"),
    make_blueprint: () => errorNotImpl("dist.make_blueprint"),
    load_blueprint: () => errorNotImpl("dist.load_blueprint"),
    list_modules: () => errorNotImpl("dist.list_modules"),
    get_module_interface: () => errorNotImpl("dist.get_module_interface"),
    list_blueprints: () => errorNotImpl("dist.list_blueprints")
  },
  script: {
    add: () => errorNotImpl("script.add"),
    remove: () => errorNotImpl("script.remove"),
    list: () => errorNotImpl("script.list")
  },
  op: {
    noop: () => success({}),
    array: (t) => success(t.args),
    array_length: (t) => t.args.length !== 1 ? error("array_length accepts exactly one argument, found: " + t.args.length) : success(t.args[0].length),
    identity: (t) => t.args.length > 1 ? error(`identity accepts up to 1 arguments, received ${t.args.length} arguments`) : success(t.args.length === 0 ? {} : t.args[0]),
    concat: (t) => {
      const e = t.args.map((r, n) => [Array.isArray(r), n]).filter(([r, n]) => !r).map(([r, n]) => n);
      if (e.length > 0) {
        const r = e.join(", ");
        return error(`All arguments of 'concat' must be arrays: arguments ${r} are not`);
      } else
        return success([].concat.apply([], t.args));
    },
    string_to_b58: (t) => t.args.length !== 1 ? error("string_to_b58 accepts only one string argument") : success(encode(new TextEncoder().encode(t.args[0]))),
    string_from_b58: (t) => t.args.length !== 1 ? error("string_from_b58 accepts only one string argument") : success(new TextDecoder().decode(decode(t.args[0]))),
    bytes_to_b58: (t) => {
      if (t.args.length !== 1 || !Array.isArray(t.args[0]))
        return error("bytes_to_b58 accepts only single argument: array of numbers");
      {
        const e = t.args[0];
        return success(encode(new Uint8Array(e)));
      }
    },
    bytes_from_b58: (t) => t.args.length !== 1 ? error("bytes_from_b58 accepts only one string argument") : success(Array.from(decode(t.args[0]))),
    sha256_string: async (t) => {
      if (t.args.length < 1 || t.args.length > 3)
        return error(`sha256_string accepts 1-3 arguments, found: ${t.args.length}`);
      {
        const [e, r, n] = t.args, i = Buffer$1.from(e), o = await sha256.digest(i), a = r ? o.digest : o.bytes, c = n ? Array.from(a) : encode(a);
        return success(c);
      }
    },
    concat_strings: (t) => {
      const e = "".concat(...t.args);
      return success(e);
    }
  },
  debug: {
    stringify: (t) => {
      let e;
      return t.args.length === 0 ? e = "<empty argument list>" : t.args.length === 1 ? e = t.args[0] : e = t.args, success(jsonify(e));
    }
  },
  math: {
    add: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(r + n);
    },
    sub: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(r - n);
    },
    mul: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(r * n);
    },
    fmul: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(Math.floor(r * n));
    },
    div: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(Math.floor(r / n));
    },
    rem: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(r % n);
    },
    pow: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(Math.pow(r, n));
    },
    log: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(Math.log(n) / Math.log(r));
    }
  },
  cmp: {
    gt: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(r > n);
    },
    gte: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(r >= n);
    },
    lt: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(r < n);
    },
    lte: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(r <= n);
    },
    cmp: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args;
      return success(r === n ? 0 : r > n ? 1 : -1);
    }
  },
  array: {
    sum: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 1))
        return e;
      const [r] = t.args;
      return success(r.reduce((n, i) => n + i, 0));
    },
    dedup: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 1))
        return e;
      const [r] = t.args, n = new Set(r);
      return success(Array.from(n));
    },
    intersect: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args, i = r.filter((o) => n.includes(o));
      return success(i);
    },
    diff: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args, i = r.filter((o) => !n.includes(o));
      return success(i);
    },
    sdiff: (t) => {
      let e;
      if (e = checkForArgumentsCount(t, 2))
        return e;
      const [r, n] = t.args, i = [
        // force new line
        ...r.filter((o) => !n.includes(o)),
        ...n.filter((o) => !r.includes(o))
      ];
      return success(i);
    }
  },
  json: {
    obj: (t) => {
      let e;
      return (e = checkForArgumentsCountEven(t)) ? e : makeJsonImpl([{}, ...t.args]);
    },
    put: (t) => {
      let e;
      return (e = checkForArgumentsCount(t, 3)) || (e = checkForArgumentType(t, 0, "object")) ? e : makeJsonImpl(t.args);
    },
    puts: (t) => {
      let e;
      return (e = checkForArgumentsCountOdd(t)) || (e = checkForArgumentsCountMoreThan(t, 3)) || (e = checkForArgumentType(t, 0, "object")) ? e : makeJsonImpl(t.args);
    },
    stringify: (t) => {
      let e;
      if ((e = checkForArgumentsCount(t, 1)) || (e = checkForArgumentType(t, 0, "object")))
        return e;
      const [r] = t.args, n = JSON.stringify(r);
      return success(n);
    },
    parse: (t) => {
      let e;
      if ((e = checkForArgumentsCount(t, 1)) || (e = checkForArgumentType(t, 0, "string")))
        return e;
      const [r] = t.args;
      try {
        const n = JSON.parse(r);
        return success(n);
      } catch (n) {
        return error(n.message);
      }
    }
  },
  "run-console": {
    print: (t) => (console.log(...t.args), success({}))
  }
}, checkForArgumentsCount = (t, e) => {
  if (t.args.length !== e)
    return error(`Expected ${e} argument(s). Got ${t.args.length}`);
}, checkForArgumentsCountMoreThan = (t, e) => {
  if (t.args.length < e)
    return error(`Expected more than ${e} argument(s). Got ${t.args.length}`);
}, checkForArgumentsCountEven = (t, e) => {
  if (t.args.length % 2 === 1)
    return error(`Expected even number of argument(s). Got ${t.args.length}`);
}, checkForArgumentsCountOdd = (t, e) => {
  if (t.args.length % 2 === 0)
    return error(`Expected odd number of argument(s). Got ${t.args.length}`);
}, checkForArgumentType = (t, e, r) => {
  const n = typeof t.args[e];
  if (n !== r)
    return error(`Argument ${e} expected to be of type ${r}, Got ${n}`);
};
class ServiceError extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, ServiceError.prototype);
  }
}
const getParticleContext = (t) => ({
  particleId: t.id,
  initPeerId: t.initPeerId,
  timestamp: t.timestamp,
  ttl: t.ttl,
  signature: t.signature
});
function registerDefaultServices(t) {
  Object.entries(builtInServices).forEach(([e, r]) => {
    Object.entries(r).forEach(([n, i]) => {
      t.internals.regHandler.common(e, n, i);
    });
  });
}
const log_particle = logger("particle"), log_peer = logger("peer");
class FluencePeer {
  constructor(e, r, n, i, o) {
    // Queues for incoming and outgoing particles
    $(this, "_incomingParticles", new cjs.Subject());
    $(this, "_timeouts", []);
    $(this, "_particleSourceSubscription");
    $(this, "_incomingParticlePromise");
    // Internal peer state
    // @ts-expect-error - initialized in constructor through `_initServices` call
    $(this, "_classServices");
    $(this, "isInitialized", !1);
    $(this, "printParticleId", !1);
    this.config = e, this.keyPair = r, this.marineHost = n, this.jsServiceHost = i, this.connection = o, this._initServices();
  }
  async start() {
    var e, r;
    log_peer.trace("starting Fluence peer"), (r = (e = this.config) == null ? void 0 : e.debug) != null && r.printParticleId && (this.printParticleId = !0), await this.marineHost.start(), this._startParticleProcessing(), this.isInitialized = !0, await this.connection.start(), log_peer.trace("started Fluence peer");
  }
  /**
   * Un-initializes the peer: stops all the underlying workflows, stops the Aqua VM
   * and disconnects from the Fluence network
   */
  async stop() {
    var e;
    log_peer.trace("stopping Fluence peer"), (e = this._particleSourceSubscription) == null || e.unsubscribe(), log_peer.trace("Waiting for all particles to finish execution"), this._incomingParticles.complete(), await this._incomingParticlePromise, log_peer.trace("All particles finished execution"), this._stopParticleProcessing(), await this.marineHost.stop(), await this.connection.stop(), this.isInitialized = !1, log_peer.trace("stopped Fluence peer");
  }
  /**
   * Registers marine service within the Fluence peer from wasm file.
   * Following helper functions can be used to load wasm files:
   * * loadWasmFromFileSystem
   * * loadWasmFromNpmPackage
   * * loadWasmFromServer
   * @param wasm - buffer with the wasm file for service
   * @param serviceId - the service id by which the service can be accessed in aqua
   */
  async registerMarineService(e, r) {
    if (!this.marineHost)
      throw new Error("Can't register marine service: peer is not initialized");
    if (this.jsServiceHost.hasService(r))
      throw new Error(`Service with '${r}' id already exists`);
    await this.marineHost.createService(e, r);
  }
  /**
   * Removes the specified marine service from the Fluence peer
   * @param serviceId - the service id to remove
   */
  async removeMarineService(e) {
    await this.marineHost.removeService(e);
  }
  // internal api
  /**
   * @private Is not intended to be used manually. Subject to change
   */
  get internals() {
    return {
      getServices: () => this._classServices,
      getRelayPeerId: () => {
        if (this.connection.supportsRelay())
          return this.connection.getRelayPeerId();
        throw new Error("Relay is not supported by the current connection");
      },
      parseAst: async (e) => {
        this.isInitialized;
        const r = await this.marineHost.callService("avm", "ast", [e], defaultCallParameters);
        if (!isString$1(r))
          throw new Error(`Call to avm:ast expected to return string. Actual return: ${r}`);
        try {
          return r.startsWith("error") ? {
            success: !1,
            data: r
          } : {
            success: !0,
            data: JSON.parse(r)
          };
        } catch (n) {
          throw new Error("Failed to call avm. Result: " + r + ". Error: " + n);
        }
      },
      createNewParticle: (e, r = this.config.defaultTtlMs) => Particle.createNew(e, this.keyPair.getPeerId(), r),
      /**
       * Initiates a new particle execution starting from local peer
       * @param particle - particle to start execution of
       * @param onStageChange - callback for reacting on particle state changes
       */
      initiateParticle: (e, r) => {
        if (!this.isInitialized)
          throw new Error("Cannot initiate new particle: peer is not initialized");
        this.printParticleId && console.log("Particle id: ", e.id), this._incomingParticles.next({
          particle: e,
          callResults: [],
          onStageChange: r
        });
      },
      /**
       * Register Call Service handler functions
       */
      regHandler: {
        /**
         * Register handler for all particles
         */
        common: this.jsServiceHost.registerGlobalHandler.bind(this.jsServiceHost),
        /**
         * Register handler which will be called only for particle with the specific id
         */
        forParticle: this.jsServiceHost.registerParticleScopeHandler.bind(this.jsServiceHost)
      }
    };
  }
  _initServices() {
    this._classServices = {
      sig: new Sig(this.keyPair),
      srv: new Srv(this),
      tracing: new Tracing()
    };
    const e = this.keyPair.getPeerId();
    registerDefaultServices(this), this._classServices.sig.securityGuard = defaultSigGuard(e), registerSig(this, "sig", this._classServices.sig), registerSig(this, e, this._classServices.sig), registerSrv(this, "single_module_srv", this._classServices.srv), registerTracing(this, "tracingSrv", this._classServices.tracing);
  }
  _startParticleProcessing() {
    this._particleSourceSubscription = this.connection.particleSource.subscribe({
      next: (e) => {
        this._incomingParticles.next({ particle: e, callResults: [], onStageChange: () => {
        } });
      }
    }), this._incomingParticlePromise = cjs.lastValueFrom(this._incomingParticles.pipe(
      cjs.tap((e) => {
        log_particle.debug("id %s. received:", e.particle.id), log_particle.trace("id %s. data: %j", e.particle.id, {
          initPeerId: e.particle.initPeerId,
          timestamp: e.particle.timestamp,
          ttl: e.particle.ttl,
          signature: e.particle.signature
        }), log_particle.trace("id %s. script: %s", e.particle.id, e.particle.script), log_particle.trace("id %s. call results: %j", e.particle.id, e.callResults);
      }),
      filterExpiredParticles(this._expireParticle.bind(this)),
      cjs.groupBy((e) => e.particle.id),
      cjs.mergeMap((e) => {
        let r = Buffer$1.from([]), n = !0;
        return e.pipe(
          cjs.concatMap(async (i) => {
            if (n) {
              const c = setTimeout(() => {
                this._expireParticle(i);
              }, getActualTTL(i.particle));
              this._timeouts.push(c), n = !1;
            }
            if (!this.isInitialized || this.marineHost === void 0)
              return null;
            log_particle.debug("id %s. sending particle to interpreter", i.particle.id), log_particle.trace("id %s. prevData: %s", i.particle.id, this.decodeAvmData(r).slice(0, 50));
            const o = dist.serializeAvmArgs(
              {
                initPeerId: i.particle.initPeerId,
                currentPeerId: this.keyPair.getPeerId(),
                timestamp: i.particle.timestamp,
                ttl: i.particle.ttl,
                keyFormat: dist.KeyPairFormat.Ed25519,
                particleId: i.particle.id,
                secretKeyBytes: this.keyPair.toEd25519PrivateKey()
              },
              i.particle.script,
              r,
              i.particle.data,
              i.callResults
            );
            let a;
            try {
              const c = await this.marineHost.callService("avm", "invoke", o, defaultCallParameters);
              a = dist.deserializeAvmResult(c);
            } catch (c) {
              a = c instanceof Error ? c : new Error(String(c));
            }
            return !(a instanceof Error) && a.retCode === 0 && (r = Buffer$1.from(a.data)), {
              ...i,
              result: a
            };
          }),
          cjs.filter((i) => i !== null),
          filterExpiredParticles(this._expireParticle.bind(this)),
          cjs.mergeMap(async (i) => {
            var a;
            if (!this.isInitialized)
              return;
            if (i.result instanceof Error) {
              log_particle.error("id %s. interpreter failed: %s", i.particle.id, i.result.message), i.onStageChange({ stage: "interpreterError", errorMessage: i.result.message });
              return;
            }
            if (i.result.retCode !== 0) {
              log_particle.error(
                "id %s. interpreter failed: retCode: %d, message: %s",
                i.particle.id,
                i.result.retCode,
                i.result.errorMessage
              ), log_particle.trace("id %s. avm data: %s", i.particle.id, this.decodeAvmData(i.result.data)), i.onStageChange({ stage: "interpreterError", errorMessage: i.result.errorMessage });
              return;
            }
            log_particle.trace(
              "id %s. interpreter result: retCode: %d, avm data: %s",
              i.particle.id,
              i.result.retCode,
              this.decodeAvmData(i.result.data)
            ), setTimeout(() => {
              i.onStageChange({ stage: "interpreted" });
            }, 0);
            let o = Promise.resolve();
            if (i.result.nextPeerPks.length > 0) {
              const c = cloneWithNewData(i.particle, Buffer$1.from(i.result.data));
              if (!this.isInitialized)
                return;
              log_particle.debug(
                "id %s. sending particle into network. Next peer ids: %s",
                c.id,
                i.result.nextPeerPks.toString()
              ), o = (a = this.connection) == null ? void 0 : a.sendParticle(i.result.nextPeerPks, c).then(() => {
                log_particle.trace("id %s. send successful", c.id), i.onStageChange({ stage: "sent" });
              }).catch((l) => {
                log_particle.error("id %s. send failed %j", c.id, l), i.onStageChange({ stage: "sendingError", errorMessage: l.toString() });
              });
            }
            if (i.result.callRequests.length > 0)
              for (const [c, l] of i.result.callRequests) {
                const u = {
                  fnName: l.functionName,
                  args: l.arguments,
                  serviceId: l.serviceId,
                  tetraplets: l.tetraplets,
                  particleContext: getParticleContext(i.particle)
                };
                this._execSingleCallRequest(u).catch((f) => f instanceof ServiceError ? {
                  retCode: ResultCodes.error,
                  result: f.message
                } : {
                  retCode: ResultCodes.error,
                  result: `Service call failed. fnName="${u.fnName}" serviceId="${u.serviceId}" error: ${f.toString()}`
                }).then((f) => {
                  const d = {
                    result: jsonify(f.result),
                    retCode: f.retCode
                  }, p = cloneWithNewData(i.particle, Buffer$1.from([]));
                  this._incomingParticles.next({
                    ...i,
                    particle: p,
                    callResults: [[c, d]]
                  });
                });
              }
            else
              i.onStageChange({ stage: "localWorkDone" });
            return o;
          })
        );
      })
    ), { defaultValue: void 0 });
  }
  _expireParticle(e) {
    const r = e.particle.id;
    log_particle.debug(
      "id %s. particle has expired after %d. Deleting particle-related queues and handlers",
      e.particle.id,
      e.particle.ttl
    ), this.jsServiceHost.removeParticleScopeHandlers(r), e.onStageChange({ stage: "expired" });
  }
  decodeAvmData(e) {
    return new TextDecoder().decode(e.buffer);
  }
  async _execSingleCallRequest(e) {
    const r = e.particleContext.particleId;
    if (log_particle.trace("id %s. executing call service handler %j", r, e), this.marineHost && await this.marineHost.hasService(e.serviceId)) {
      const i = await this.marineHost.callService(e.serviceId, e.fnName, e.args, defaultCallParameters);
      return {
        retCode: ResultCodes.success,
        result: i
      };
    }
    let n = await this.jsServiceHost.callService(e);
    return n === null && (n = {
      retCode: ResultCodes.error,
      result: `No service found for service call: serviceId='${e.serviceId}', fnName='${e.fnName}' args='${jsonify(e.args)}'`
    }), log_particle.trace("id %s. executed call service handler, req: %j, res: %j ", r, e, n), n;
  }
  _stopParticleProcessing() {
    this._timeouts.forEach((e) => {
      clearTimeout(e);
    });
  }
}
function filterExpiredParticles(t) {
  return cjs.pipe(
    cjs.tap((e) => {
      hasExpired(e.particle) && t(e);
    }),
    cjs.filter((e) => !hasExpired(e.particle))
  );
}
class JsServiceHost {
  constructor() {
    $(this, "particleScopeHandlers", /* @__PURE__ */ new Map());
    $(this, "commonHandlers", /* @__PURE__ */ new Map());
  }
  /**
   * Returns true if any handler for the specified serviceId is registered
   */
  hasService(e) {
    return this.commonHandlers.has(e) || this.particleScopeHandlers.has(e);
  }
  /**
   * Removes all handlers associated with the specified particle scope
   * @param particleId Particle ID to remove handlers for
   */
  removeParticleScopeHandlers(e) {
    this.particleScopeHandlers.delete(e);
  }
  /**
   * Find call service handler for specified particle
   * @param serviceId Service ID as specified in `call` air instruction
   * @param fnName Function name as specified in `call` air instruction
   * @param particleId Particle ID
   */
  getHandler(e, r, n) {
    const i = serviceFnKey(e, r), o = this.particleScopeHandlers.get(n);
    let a;
    return o !== void 0 && (a = o.get(i)), a === void 0 && (a = this.commonHandlers.get(i)), a || null;
  }
  /**
   * Execute service call for specified call service data. Return null if no handler was found
   */
  async callService(e) {
    const r = this.getHandler(e.serviceId, e.fnName, e.particleContext.particleId);
    if (r === null)
      return null;
    const n = await r(e);
    return n.result === void 0 && (n.result = null), n;
  }
  /**
   * Register handler for all particles
   */
  registerGlobalHandler(e, r, n) {
    this.commonHandlers.set(serviceFnKey(e, r), n);
  }
  /**
   * Register handler which will be called only for particle with the specific id
   */
  registerParticleScopeHandler(e, r, n, i) {
    let o = this.particleScopeHandlers.get(e);
    o === void 0 && (o = /* @__PURE__ */ new Map(), this.particleScopeHandlers.set(e, o)), o.set(serviceFnKey(r, n), i);
  }
}
function serviceFnKey(t, e) {
  return `${t}/${e}`;
}
const log$1 = logger("client"), DEFAULT_TTL_MS = 7e3, MAX_OUTBOUND_STREAMS = 1024, MAX_INBOUND_STREAMS = 1024, makeClientPeerConfig = async (t, e) => {
  var o, a, c, l;
  const r = (e == null ? void 0 : e.keyPair) || { type: "Ed25519", source: "random" }, n = await fromOpts(r), i = relayOptionToMultiaddr(t);
  return {
    peerConfig: {
      debug: {
        printParticleId: ((o = e == null ? void 0 : e.debug) == null ? void 0 : o.printParticleId) || !1
      },
      defaultTtlMs: (e == null ? void 0 : e.defaultTtlMs) || DEFAULT_TTL_MS
    },
    relayConfig: {
      peerId: n.getLibp2pPeerId(),
      relayAddress: i,
      dialTimeoutMs: (a = e == null ? void 0 : e.connectionOptions) == null ? void 0 : a.dialTimeoutMs,
      maxInboundStreams: ((c = e == null ? void 0 : e.connectionOptions) == null ? void 0 : c.maxInboundStreams) || MAX_OUTBOUND_STREAMS,
      maxOutboundStreams: ((l = e == null ? void 0 : e.connectionOptions) == null ? void 0 : l.maxOutboundStreams) || MAX_INBOUND_STREAMS
    },
    keyPair: n
  };
};
class ClientPeer extends FluencePeer {
  constructor(r, n, i, o) {
    super(r, i, o, new JsServiceHost(), new RelayConnection(n));
    $(this, "connectionState", "disconnected");
    $(this, "connectionStateChangeHandler", () => {
    });
  }
  getPeerId() {
    return this.keyPair.getPeerId();
  }
  getPeerSecretKey() {
    return this.keyPair.toEd25519PrivateKey();
  }
  getRelayPeerId() {
    return this.internals.getRelayPeerId();
  }
  onConnectionStateChange(r) {
    return this.connectionStateChangeHandler = r, this.connectionState;
  }
  changeConnectionState(r) {
    this.connectionState = r, this.connectionStateChangeHandler(r);
  }
  /**
   * Connect to the Fluence network
   */
  async connect() {
    return this.start();
  }
  // /**
  //  * Disconnect from the Fluence network
  //  */
  async disconnect() {
    return this.stop();
  }
  async start() {
    log$1.trace("connecting to Fluence network"), this.changeConnectionState("connecting"), await super.start(), this.changeConnectionState("connected"), log$1.trace("connected");
  }
  async stop() {
    log$1.trace("disconnecting from Fluence network"), this.changeConnectionState("disconnecting"), await super.stop(), this.changeConnectionState("disconnected"), log$1.trace("disconnected");
  }
}
const getArgumentTypes = (t) => {
  if (t.arrow.domain.tag !== "labeledProduct")
    throw new Error("Should be impossible");
  return t.arrow.domain.fields;
}, isReturnTypeVoid = (t) => t.arrow.codomain.tag === "nil" ? !0 : t.arrow.codomain.items.length == 0, log = logger("aqua"), callAquaFunction = ({ def: t, script: e, config: r, peer: n, args: i }) => {
  log.trace("calling aqua function %j", { def: t, script: e, config: r, args: i });
  const o = getArgumentTypes(t);
  return new Promise((c, l) => {
    const u = n.internals.createNewParticle(e, r == null ? void 0 : r.ttl);
    if (u instanceof Error)
      return l(u.message);
    for (let [f, d] of Object.entries(i)) {
      const p = o[f];
      let g;
      p.tag === "arrow" ? g = userHandlerService(t.names.callbackSrv, [f, p], d) : g = injectValueService(t.names.getDataSrv, f, p, d), registerParticleScopeService(n, u, g);
    }
    registerParticleScopeService(n, u, responseService(t, c)), registerParticleScopeService(n, u, injectRelayService(t, n)), registerParticleScopeService(n, u, errorHandlingService(t, l)), n.internals.initiateParticle(u, (f) => {
      isReturnTypeVoid(t) && (f.stage === "sent" || f.stage === "localWorkDone") && c(void 0), f.stage === "sendingError" && l(`Could not send particle for ${t.functionName}: not connected  (particle id: ${u.id})`), f.stage === "expired" && l(
        `Particle expired after ttl of ${u.ttl}ms for function ${t.functionName} (particle id: ${u.id})`
      ), f.stage === "interpreterError" && l(
        `Script interpretation failed for ${t.functionName}: ${f.errorMessage}  (particle id: ${u.id})`
      );
    });
  });
}, DefaultErrorSerializer = {
  deserialize(t) {
    return Object.assign(Error(t.message), {
      name: t.name,
      stack: t.stack
    });
  },
  serialize(t) {
    return {
      __error_marker: "$$error",
      message: t.message,
      name: t.name,
      stack: t.stack
    };
  }
}, isSerializedError = (t) => t && typeof t == "object" && "__error_marker" in t && t.__error_marker === "$$error", DefaultSerializer = {
  deserialize(t) {
    return isSerializedError(t) ? DefaultErrorSerializer.deserialize(t) : t;
  },
  serialize(t) {
    return t instanceof Error ? DefaultErrorSerializer.serialize(t) : t;
  }
};
let registeredSerializer = DefaultSerializer;
function deserialize(t) {
  return registeredSerializer.deserialize(t);
}
function serialize(t) {
  return registeredSerializer.serialize(t);
}
let bundleURL;
function getBundleURLCached() {
  return bundleURL || (bundleURL = getBundleURL()), bundleURL;
}
function getBundleURL() {
  try {
    throw new Error();
  } catch (t) {
    const e = ("" + t.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
    if (e)
      return getBaseURL(e[0]);
  }
  return "/";
}
function getBaseURL(t) {
  return ("" + t).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, "$1") + "/";
}
const defaultPoolSize$1 = typeof navigator < "u" && navigator.hardwareConcurrency ? navigator.hardwareConcurrency : 4, isAbsoluteURL = (t) => /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(t);
function createSourceBlobURL(t) {
  const e = new Blob([t], { type: "application/javascript" });
  return URL.createObjectURL(e);
}
function selectWorkerImplementation$1() {
  if (typeof Worker > "u")
    return class {
      constructor() {
        throw Error("No web worker implementation available. You might have tried to spawn a worker within a worker in a browser that doesn't support workers in workers.");
      }
    };
  class t extends Worker {
    constructor(n, i) {
      var o, a;
      typeof n == "string" && i && i._baseURL ? n = new URL(n, i._baseURL) : typeof n == "string" && !isAbsoluteURL(n) && getBundleURLCached().match(/^file:\/\//i) && (n = new URL(n, getBundleURLCached().replace(/\/[^\/]+$/, "/")), (!((o = i == null ? void 0 : i.CORSWorkaround) !== null && o !== void 0) || o) && (n = createSourceBlobURL(`importScripts(${JSON.stringify(n)});`))), typeof n == "string" && isAbsoluteURL(n) && (!((a = i == null ? void 0 : i.CORSWorkaround) !== null && a !== void 0) || a) && (n = createSourceBlobURL(`importScripts(${JSON.stringify(n)});`)), super(n, i);
    }
  }
  class e extends t {
    constructor(n, i) {
      const o = window.URL.createObjectURL(n);
      super(o, i);
    }
    static fromText(n, i) {
      const o = new window.Blob([n], { type: "text/javascript" });
      return new e(o, i);
    }
  }
  return {
    blob: e,
    default: t
  };
}
let implementation$2;
function getWorkerImplementation$2() {
  return implementation$2 || (implementation$2 = selectWorkerImplementation$1()), implementation$2;
}
function isWorkerRuntime$1() {
  const t = typeof self$1 < "u" && typeof Window < "u" && self$1 instanceof Window;
  return !!(typeof self$1 < "u" && self$1.postMessage && !t);
}
const BrowserImplementation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPoolSize: defaultPoolSize$1,
  getWorkerImplementation: getWorkerImplementation$2,
  isWorkerRuntime: isWorkerRuntime$1
}, Symbol.toStringTag, { value: "Module" }));
var callsitesExports = {}, callsites$1 = {
  get exports() {
    return callsitesExports;
  },
  set exports(t) {
    callsitesExports = t;
  }
};
const callsites = () => {
  const t = Error.prepareStackTrace;
  Error.prepareStackTrace = (r, n) => n;
  const e = new Error().stack.slice(1);
  return Error.prepareStackTrace = t, e;
};
callsites$1.exports = callsites;
callsitesExports.default = callsites;
let tsNodeAvailable;
const defaultPoolSize = cpus().length;
function detectTsNode() {
  if (typeof __non_webpack_require__ == "function")
    return !1;
  if (tsNodeAvailable)
    return tsNodeAvailable;
  try {
    eval("require").resolve("ts-node"), tsNodeAvailable = !0;
  } catch (t) {
    if (t && t.code === "MODULE_NOT_FOUND")
      tsNodeAvailable = !1;
    else
      throw t;
  }
  return tsNodeAvailable;
}
function createTsNodeModule(t) {
  return `
    require("ts-node/register/transpile-only");
    require(${JSON.stringify(t)});
  `;
}
function rebaseScriptPath(t, e) {
  const r = callsitesExports().find((a) => {
    const c = a.getFileName();
    return Boolean(c && !c.match(e) && !c.match(/[\/\\]master[\/\\]implementation/) && !c.match(/^internal\/process/));
  }), n = r ? r.getFileName() : null;
  let i = n || null;
  return i && i.startsWith("file:") && (i = fileURLToPath(i)), i ? path.join(path.dirname(i), t) : t;
}
function resolveScriptPath(scriptPath, baseURL) {
  const makeRelative = (filePath) => path.isAbsolute(filePath) ? filePath : path.join(baseURL || eval("__dirname"), filePath), workerFilePath = typeof __non_webpack_require__ == "function" ? __non_webpack_require__.resolve(makeRelative(scriptPath)) : eval("require").resolve(makeRelative(rebaseScriptPath(scriptPath, /[\/\\]worker_threads[\/\\]/)));
  return workerFilePath;
}
function initWorkerThreadsWorker() {
  const t = typeof __non_webpack_require__ == "function" ? __non_webpack_require__("worker_threads").Worker : WorkerScope.Worker;
  let e = [];
  class r extends t {
    constructor(a, c) {
      const l = c && c.fromSource ? null : resolveScriptPath(a, (c || {})._baseURL);
      if (l)
        l.match(/\.tsx?$/i) && detectTsNode() ? super(createTsNodeModule(l), Object.assign(Object.assign({}, c), { eval: !0 })) : l.match(/\.asar[\/\\]/) ? super(l.replace(/\.asar([\/\\])/, ".asar.unpacked$1"), c) : super(l, c);
      else {
        const u = a;
        super(u, Object.assign(Object.assign({}, c), { eval: !0 }));
      }
      this.mappedEventListeners = /* @__PURE__ */ new WeakMap(), e.push(this);
    }
    addEventListener(a, c) {
      const l = (u) => {
        c({ data: u });
      };
      this.mappedEventListeners.set(c, l), this.on(a, l);
    }
    removeEventListener(a, c) {
      const l = this.mappedEventListeners.get(c) || c;
      this.off(a, l);
    }
  }
  const n = () => {
    Promise.all(e.map((o) => o.terminate())).then(() => process.exit(0), () => process.exit(1)), e = [];
  };
  process.on("SIGINT", () => n()), process.on("SIGTERM", () => n());
  class i extends r {
    constructor(a, c) {
      super(Buffer.from(a).toString("utf-8"), Object.assign(Object.assign({}, c), { fromSource: !0 }));
    }
    static fromText(a, c) {
      return new r(a, Object.assign(Object.assign({}, c), { fromSource: !0 }));
    }
  }
  return {
    blob: i,
    default: r
  };
}
function initTinyWorker() {
  const t = require("tiny-worker");
  let e = [];
  class r extends t {
    constructor(a, c) {
      const l = c && c.fromSource ? null : process.platform === "win32" ? `file:///${resolveScriptPath(a).replace(/\\/g, "/")}` : resolveScriptPath(a);
      if (l)
        l.match(/\.tsx?$/i) && detectTsNode() ? super(new Function(createTsNodeModule(resolveScriptPath(a))), [], { esm: !0 }) : l.match(/\.asar[\/\\]/) ? super(l.replace(/\.asar([\/\\])/, ".asar.unpacked$1"), [], { esm: !0 }) : super(l, [], { esm: !0 });
      else {
        const u = a;
        super(new Function(u), [], { esm: !0 });
      }
      e.push(this), this.emitter = new EventEmitter$4(), this.onerror = (u) => this.emitter.emit("error", u), this.onmessage = (u) => this.emitter.emit("message", u);
    }
    addEventListener(a, c) {
      this.emitter.addListener(a, c);
    }
    removeEventListener(a, c) {
      this.emitter.removeListener(a, c);
    }
    terminate() {
      return e = e.filter((a) => a !== this), super.terminate();
    }
  }
  const n = () => {
    Promise.all(e.map((o) => o.terminate())).then(() => process.exit(0), () => process.exit(1)), e = [];
  };
  process.on("SIGINT", () => n()), process.on("SIGTERM", () => n());
  class i extends r {
    constructor(a, c) {
      super(Buffer.from(a).toString("utf-8"), Object.assign(Object.assign({}, c), { fromSource: !0 }));
    }
    static fromText(a, c) {
      return new r(a, Object.assign(Object.assign({}, c), { fromSource: !0 }));
    }
  }
  return {
    blob: i,
    default: r
  };
}
let implementation$1, isTinyWorker;
function selectWorkerImplementation() {
  try {
    return isTinyWorker = !1, initWorkerThreadsWorker();
  } catch {
    return console.debug("Node worker_threads not available. Trying to fall back to tiny-worker polyfill..."), isTinyWorker = !0, initTinyWorker();
  }
}
function getWorkerImplementation$1() {
  return implementation$1 || (implementation$1 = selectWorkerImplementation()), implementation$1;
}
function isWorkerRuntime() {
  return isTinyWorker ? !!(typeof self$1 < "u" && self$1.postMessage) : !(typeof __non_webpack_require__ == "function" ? __non_webpack_require__("worker_threads").isMainThread : WorkerScope.isMainThread);
}
const NodeImplementation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPoolSize,
  getWorkerImplementation: getWorkerImplementation$1,
  isWorkerRuntime
}, Symbol.toStringTag, { value: "Module" })), runningInNode = typeof process < "u" && process.arch !== "browser" && "pid" in process, implementation = runningInNode ? NodeImplementation : BrowserImplementation, getWorkerImplementation = implementation.getWorkerImplementation, hasSymbols = () => typeof Symbol == "function", hasSymbol = (t) => hasSymbols() && Boolean(Symbol[t]), getSymbol = (t) => hasSymbol(t) ? Symbol[t] : "@@" + t;
hasSymbol("asyncIterator") || (Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator"));
const SymbolIterator = getSymbol("iterator"), SymbolObservable = getSymbol("observable"), SymbolSpecies = getSymbol("species");
function getMethod(t, e) {
  const r = t[e];
  if (r != null) {
    if (typeof r != "function")
      throw new TypeError(r + " is not a function");
    return r;
  }
}
function getSpecies(t) {
  let e = t.constructor;
  return e !== void 0 && (e = e[SymbolSpecies], e === null && (e = void 0)), e !== void 0 ? e : Observable;
}
function isObservable(t) {
  return t instanceof Observable;
}
function hostReportError(t) {
  hostReportError.log ? hostReportError.log(t) : setTimeout(() => {
    throw t;
  }, 0);
}
function enqueue(t) {
  Promise.resolve().then(() => {
    try {
      t();
    } catch (e) {
      hostReportError(e);
    }
  });
}
function cleanupSubscription(t) {
  const e = t._cleanup;
  if (e !== void 0 && (t._cleanup = void 0, !!e))
    try {
      if (typeof e == "function")
        e();
      else {
        const r = getMethod(e, "unsubscribe");
        r && r.call(e);
      }
    } catch (r) {
      hostReportError(r);
    }
}
function closeSubscription(t) {
  t._observer = void 0, t._queue = void 0, t._state = "closed";
}
function flushSubscription(t) {
  const e = t._queue;
  if (e) {
    t._queue = void 0, t._state = "ready";
    for (const r of e)
      if (notifySubscription(t, r.type, r.value), t._state === "closed")
        break;
  }
}
function notifySubscription(t, e, r) {
  t._state = "running";
  const n = t._observer;
  try {
    const i = n ? getMethod(n, e) : void 0;
    switch (e) {
      case "next":
        i && i.call(n, r);
        break;
      case "error":
        if (closeSubscription(t), i)
          i.call(n, r);
        else
          throw r;
        break;
      case "complete":
        closeSubscription(t), i && i.call(n);
        break;
    }
  } catch (i) {
    hostReportError(i);
  }
  t._state === "closed" ? cleanupSubscription(t) : t._state === "running" && (t._state = "ready");
}
function onNotify(t, e, r) {
  if (t._state !== "closed") {
    if (t._state === "buffering") {
      t._queue = t._queue || [], t._queue.push({ type: e, value: r });
      return;
    }
    if (t._state !== "ready") {
      t._state = "buffering", t._queue = [{ type: e, value: r }], enqueue(() => flushSubscription(t));
      return;
    }
    notifySubscription(t, e, r);
  }
}
class Subscription {
  constructor(e, r) {
    this._cleanup = void 0, this._observer = e, this._queue = void 0, this._state = "initializing";
    const n = new SubscriptionObserver(this);
    try {
      this._cleanup = r.call(void 0, n);
    } catch (i) {
      n.error(i);
    }
    this._state === "initializing" && (this._state = "ready");
  }
  get closed() {
    return this._state === "closed";
  }
  unsubscribe() {
    this._state !== "closed" && (closeSubscription(this), cleanupSubscription(this));
  }
}
class SubscriptionObserver {
  constructor(e) {
    this._subscription = e;
  }
  get closed() {
    return this._subscription._state === "closed";
  }
  next(e) {
    onNotify(this._subscription, "next", e);
  }
  error(e) {
    onNotify(this._subscription, "error", e);
  }
  complete() {
    onNotify(this._subscription, "complete");
  }
}
class Observable {
  constructor(e) {
    if (!(this instanceof Observable))
      throw new TypeError("Observable cannot be called as a function");
    if (typeof e != "function")
      throw new TypeError("Observable initializer must be a function");
    this._subscriber = e;
  }
  subscribe(e, r, n) {
    return (typeof e != "object" || e === null) && (e = {
      next: e,
      error: r,
      complete: n
    }), new Subscription(e, this._subscriber);
  }
  pipe(e, ...r) {
    let n = this;
    for (const i of [e, ...r])
      n = i(n);
    return n;
  }
  tap(e, r, n) {
    const i = typeof e != "object" || e === null ? {
      next: e,
      error: r,
      complete: n
    } : e;
    return new Observable((o) => this.subscribe({
      next(a) {
        i.next && i.next(a), o.next(a);
      },
      error(a) {
        i.error && i.error(a), o.error(a);
      },
      complete() {
        i.complete && i.complete(), o.complete();
      },
      start(a) {
        i.start && i.start(a);
      }
    }));
  }
  forEach(e) {
    return new Promise((r, n) => {
      if (typeof e != "function") {
        n(new TypeError(e + " is not a function"));
        return;
      }
      function i() {
        o.unsubscribe(), r(void 0);
      }
      const o = this.subscribe({
        next(a) {
          try {
            e(a, i);
          } catch (c) {
            n(c), o.unsubscribe();
          }
        },
        error(a) {
          n(a);
        },
        complete() {
          r(void 0);
        }
      });
    });
  }
  map(e) {
    if (typeof e != "function")
      throw new TypeError(e + " is not a function");
    const r = getSpecies(this);
    return new r((n) => this.subscribe({
      next(i) {
        let o = i;
        try {
          o = e(i);
        } catch (a) {
          return n.error(a);
        }
        n.next(o);
      },
      error(i) {
        n.error(i);
      },
      complete() {
        n.complete();
      }
    }));
  }
  filter(e) {
    if (typeof e != "function")
      throw new TypeError(e + " is not a function");
    const r = getSpecies(this);
    return new r((n) => this.subscribe({
      next(i) {
        try {
          if (!e(i))
            return;
        } catch (o) {
          return n.error(o);
        }
        n.next(i);
      },
      error(i) {
        n.error(i);
      },
      complete() {
        n.complete();
      }
    }));
  }
  reduce(e, r) {
    if (typeof e != "function")
      throw new TypeError(e + " is not a function");
    const n = getSpecies(this), i = arguments.length > 1;
    let o = !1, a = r;
    return new n((c) => this.subscribe({
      next(l) {
        const u = !o;
        if (o = !0, !u || i)
          try {
            a = e(a, l);
          } catch (f) {
            return c.error(f);
          }
        else
          a = l;
      },
      error(l) {
        c.error(l);
      },
      complete() {
        if (!o && !i)
          return c.error(new TypeError("Cannot reduce an empty sequence"));
        c.next(a), c.complete();
      }
    }));
  }
  concat(...e) {
    const r = getSpecies(this);
    return new r((n) => {
      let i, o = 0;
      function a(c) {
        i = c.subscribe({
          next(l) {
            n.next(l);
          },
          error(l) {
            n.error(l);
          },
          complete() {
            o === e.length ? (i = void 0, n.complete()) : a(r.from(e[o++]));
          }
        });
      }
      return a(this), () => {
        i && (i.unsubscribe(), i = void 0);
      };
    });
  }
  flatMap(e) {
    if (typeof e != "function")
      throw new TypeError(e + " is not a function");
    const r = getSpecies(this);
    return new r((n) => {
      const i = [], o = this.subscribe({
        next(c) {
          let l;
          if (e)
            try {
              l = e(c);
            } catch (f) {
              return n.error(f);
            }
          else
            l = c;
          const u = r.from(l).subscribe({
            next(f) {
              n.next(f);
            },
            error(f) {
              n.error(f);
            },
            complete() {
              const f = i.indexOf(u);
              f >= 0 && i.splice(f, 1), a();
            }
          });
          i.push(u);
        },
        error(c) {
          n.error(c);
        },
        complete() {
          a();
        }
      });
      function a() {
        o.closed && i.length === 0 && n.complete();
      }
      return () => {
        i.forEach((c) => c.unsubscribe()), o.unsubscribe();
      };
    });
  }
  [SymbolObservable]() {
    return this;
  }
  static from(e) {
    const r = typeof this == "function" ? this : Observable;
    if (e == null)
      throw new TypeError(e + " is not an object");
    const n = getMethod(e, SymbolObservable);
    if (n) {
      const i = n.call(e);
      if (Object(i) !== i)
        throw new TypeError(i + " is not an object");
      return isObservable(i) && i.constructor === r ? i : new r((o) => i.subscribe(o));
    }
    if (hasSymbol("iterator")) {
      const i = getMethod(e, SymbolIterator);
      if (i)
        return new r((o) => {
          enqueue(() => {
            if (!o.closed) {
              for (const a of i.call(e))
                if (o.next(a), o.closed)
                  return;
              o.complete();
            }
          });
        });
    }
    if (Array.isArray(e))
      return new r((i) => {
        enqueue(() => {
          if (!i.closed) {
            for (const o of e)
              if (i.next(o), i.closed)
                return;
            i.complete();
          }
        });
      });
    throw new TypeError(e + " is not observable");
  }
  static of(...e) {
    const r = typeof this == "function" ? this : Observable;
    return new r((n) => {
      enqueue(() => {
        if (!n.closed) {
          for (const i of e)
            if (n.next(i), n.closed)
              return;
          n.complete();
        }
      });
    });
  }
  static get [SymbolSpecies]() {
    return this;
  }
}
hasSymbols() && Object.defineProperty(Observable, Symbol("extensions"), {
  value: {
    symbol: SymbolObservable,
    hostReportError
  },
  configurable: !0
});
const Observable$1 = Observable;
function unsubscribe(t) {
  typeof t == "function" ? t() : t && typeof t.unsubscribe == "function" && t.unsubscribe();
}
class MulticastSubject extends Observable$1 {
  constructor() {
    super((e) => (this._observers.add(e), () => this._observers.delete(e))), this._observers = /* @__PURE__ */ new Set();
  }
  next(e) {
    for (const r of this._observers)
      r.next(e);
  }
  error(e) {
    for (const r of this._observers)
      r.error(e);
  }
  complete() {
    for (const e of this._observers)
      e.complete();
  }
}
const Subject = MulticastSubject;
function multicast(t) {
  const e = new Subject();
  let r, n = 0;
  return new Observable$1((i) => {
    r || (r = t.subscribe(e));
    const o = e.subscribe(i);
    return n++, () => {
      n--, o.unsubscribe(), n === 0 && (unsubscribe(r), r = void 0);
    };
  });
}
const $errors = Symbol("thread.errors"), $events = Symbol("thread.events"), $terminate = Symbol("thread.terminate"), $transferable = Symbol("thread.transferable"), $worker = Symbol("thread.worker");
function fail$1(t) {
  throw Error(t);
}
const Thread = {
  /** Return an observable that can be used to subscribe to all errors happening in the thread. */
  errors(t) {
    return t[$errors] || fail$1("Error observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
  },
  /** Return an observable that can be used to subscribe to internal events happening in the thread. Useful for debugging. */
  events(t) {
    return t[$events] || fail$1("Events observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
  },
  /** Terminate a thread. Remember to terminate every thread when you are done using it. */
  terminate(t) {
    return t[$terminate]();
  }
}, doNothing$1 = () => {
};
function createPromiseWithResolver() {
  let t = !1, e, r = doNothing$1;
  return [new Promise((o) => {
    t ? o(e) : r = o;
  }), (o) => {
    t = !0, e = o, r(e);
  }];
}
var WorkerEventType;
(function(t) {
  t.internalError = "internalError", t.message = "message", t.termination = "termination";
})(WorkerEventType || (WorkerEventType = {}));
const doNothing = () => {
}, returnInput = (t) => t, runDeferred = (t) => Promise.resolve().then(t);
function fail(t) {
  throw t;
}
function isThenable(t) {
  return t && typeof t.then == "function";
}
class ObservablePromise extends Observable$1 {
  constructor(e) {
    super((r) => {
      const n = this, i = Object.assign(Object.assign({}, r), {
        complete() {
          r.complete(), n.onCompletion();
        },
        error(o) {
          r.error(o), n.onError(o);
        },
        next(o) {
          r.next(o), n.onNext(o);
        }
      });
      try {
        return this.initHasRun = !0, e(i);
      } catch (o) {
        i.error(o);
      }
    }), this.initHasRun = !1, this.fulfillmentCallbacks = [], this.rejectionCallbacks = [], this.firstValueSet = !1, this.state = "pending";
  }
  onNext(e) {
    this.firstValueSet || (this.firstValue = e, this.firstValueSet = !0);
  }
  onError(e) {
    this.state = "rejected", this.rejection = e;
    for (const r of this.rejectionCallbacks)
      runDeferred(() => r(e));
  }
  onCompletion() {
    this.state = "fulfilled";
    for (const e of this.fulfillmentCallbacks)
      runDeferred(() => e(this.firstValue));
  }
  then(e, r) {
    const n = e || returnInput, i = r || fail;
    let o = !1;
    return new Promise((a, c) => {
      const l = (f) => {
        if (!o) {
          o = !0;
          try {
            a(i(f));
          } catch (d) {
            c(d);
          }
        }
      }, u = (f) => {
        try {
          a(n(f));
        } catch (d) {
          l(d);
        }
      };
      if (this.initHasRun || this.subscribe({ error: l }), this.state === "fulfilled")
        return a(n(this.firstValue));
      if (this.state === "rejected")
        return o = !0, a(i(this.rejection));
      this.fulfillmentCallbacks.push(u), this.rejectionCallbacks.push(l);
    });
  }
  catch(e) {
    return this.then(void 0, e);
  }
  finally(e) {
    const r = e || doNothing;
    return this.then((n) => (r(), n), () => r());
  }
  static from(e) {
    return isThenable(e) ? new ObservablePromise((r) => {
      const n = (o) => {
        r.next(o), r.complete();
      }, i = (o) => {
        r.error(o);
      };
      e.then(n, i);
    }) : super.from(e);
  }
}
function isTransferDescriptor(t) {
  return t && typeof t == "object" && t[$transferable];
}
var MasterMessageType;
(function(t) {
  t.cancel = "cancel", t.run = "run";
})(MasterMessageType || (MasterMessageType = {}));
var WorkerMessageType;
(function(t) {
  t.error = "error", t.init = "init", t.result = "result", t.running = "running", t.uncaughtError = "uncaughtError";
})(WorkerMessageType || (WorkerMessageType = {}));
const debugMessages$1 = DebugLogger("threads:master:messages");
let nextJobUID = 1;
const dedupe = (t) => Array.from(new Set(t)), isJobErrorMessage = (t) => t && t.type === WorkerMessageType.error, isJobResultMessage = (t) => t && t.type === WorkerMessageType.result, isJobStartMessage = (t) => t && t.type === WorkerMessageType.running;
function createObservableForJob(t, e) {
  return new Observable$1((r) => {
    let n;
    const i = (o) => {
      if (debugMessages$1("Message from worker:", o.data), !(!o.data || o.data.uid !== e)) {
        if (isJobStartMessage(o.data))
          n = o.data.resultType;
        else if (isJobResultMessage(o.data))
          n === "promise" ? (typeof o.data.payload < "u" && r.next(deserialize(o.data.payload)), r.complete(), t.removeEventListener("message", i)) : (o.data.payload && r.next(deserialize(o.data.payload)), o.data.complete && (r.complete(), t.removeEventListener("message", i)));
        else if (isJobErrorMessage(o.data)) {
          const a = deserialize(o.data.error);
          r.error(a), t.removeEventListener("message", i);
        }
      }
    };
    return t.addEventListener("message", i), () => {
      if (n === "observable" || !n) {
        const o = {
          type: MasterMessageType.cancel,
          uid: e
        };
        t.postMessage(o);
      }
      t.removeEventListener("message", i);
    };
  });
}
function prepareArguments(t) {
  if (t.length === 0)
    return {
      args: [],
      transferables: []
    };
  const e = [], r = [];
  for (const n of t)
    isTransferDescriptor(n) ? (e.push(serialize(n.send)), r.push(...n.transferables)) : e.push(serialize(n));
  return {
    args: e,
    transferables: r.length === 0 ? r : dedupe(r)
  };
}
function createProxyFunction(t, e) {
  return (...r) => {
    const n = nextJobUID++, { args: i, transferables: o } = prepareArguments(r), a = {
      type: MasterMessageType.run,
      uid: n,
      method: e,
      args: i
    };
    debugMessages$1("Sending command to run function to worker:", a);
    try {
      t.postMessage(a, o);
    } catch (c) {
      return ObservablePromise.from(Promise.reject(c));
    }
    return ObservablePromise.from(multicast(createObservableForJob(t, n)));
  };
}
function createProxyModule(t, e) {
  const r = {};
  for (const n of e)
    r[n] = createProxyFunction(t, n);
  return r;
}
var __awaiter = globalThis && globalThis.__awaiter || function(t, e, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(a) {
      a(o);
    });
  }
  return new (r || (r = Promise))(function(o, a) {
    function c(f) {
      try {
        u(n.next(f));
      } catch (d) {
        a(d);
      }
    }
    function l(f) {
      try {
        u(n.throw(f));
      } catch (d) {
        a(d);
      }
    }
    function u(f) {
      f.done ? o(f.value) : i(f.value).then(c, l);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const debugMessages = DebugLogger("threads:master:messages"), debugSpawn = DebugLogger("threads:master:spawn"), debugThreadUtils = DebugLogger("threads:master:thread-utils"), isInitMessage = (t) => t && t.type === "init", isUncaughtErrorMessage = (t) => t && t.type === "uncaughtError", initMessageTimeout = typeof process < "u" && process.env.THREADS_WORKER_INIT_TIMEOUT ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10) : 1e4;
function withTimeout(t, e, r) {
  return __awaiter(this, void 0, void 0, function* () {
    let n;
    const i = new Promise((a, c) => {
      n = setTimeout(() => c(Error(r)), e);
    }), o = yield Promise.race([
      t,
      i
    ]);
    return clearTimeout(n), o;
  });
}
function receiveInitMessage(t) {
  return new Promise((e, r) => {
    const n = (i) => {
      debugMessages("Message from worker before finishing initialization:", i.data), isInitMessage(i.data) ? (t.removeEventListener("message", n), e(i.data)) : isUncaughtErrorMessage(i.data) && (t.removeEventListener("message", n), r(deserialize(i.data.error)));
    };
    t.addEventListener("message", n);
  });
}
function createEventObservable(t, e) {
  return new Observable$1((r) => {
    const n = (o) => {
      const a = {
        type: WorkerEventType.message,
        data: o.data
      };
      r.next(a);
    }, i = (o) => {
      debugThreadUtils("Unhandled promise rejection event in thread:", o);
      const a = {
        type: WorkerEventType.internalError,
        error: Error(o.reason)
      };
      r.next(a);
    };
    t.addEventListener("message", n), t.addEventListener("unhandledrejection", i), e.then(() => {
      const o = {
        type: WorkerEventType.termination
      };
      t.removeEventListener("message", n), t.removeEventListener("unhandledrejection", i), r.next(o), r.complete();
    });
  });
}
function createTerminator(t) {
  const [e, r] = createPromiseWithResolver();
  return { terminate: () => __awaiter(this, void 0, void 0, function* () {
    debugThreadUtils("Terminating worker"), yield t.terminate(), r();
  }), termination: e };
}
function setPrivateThreadProps(t, e, r, n) {
  const i = r.filter((o) => o.type === WorkerEventType.internalError).map((o) => o.error);
  return Object.assign(t, {
    [$errors]: i,
    [$events]: r,
    [$terminate]: n,
    [$worker]: e
  });
}
function spawn(t, e) {
  return __awaiter(this, void 0, void 0, function* () {
    debugSpawn("Initializing new thread");
    const r = e && e.timeout ? e.timeout : initMessageTimeout, i = (yield withTimeout(receiveInitMessage(t), r, `Timeout: Did not receive an init message from worker after ${r}ms. Make sure the worker calls expose().`)).exposed, { termination: o, terminate: a } = createTerminator(t), c = createEventObservable(t, o);
    if (i.type === "function") {
      const l = createProxyFunction(t);
      return setPrivateThreadProps(l, t, c, a);
    } else if (i.type === "module") {
      const l = createProxyModule(t, i.methods);
      return setPrivateThreadProps(l, t, c, a);
    } else {
      const l = i.type;
      throw Error(`Worker init message states unexpected type of expose(): ${l}`);
    }
  });
}
const BlobWorker = getWorkerImplementation().blob;
getWorkerImplementation().default;
class MarineBackgroundRunner {
  constructor(e, r, n) {
    $(this, "workerThread");
    $(this, "loggers", /* @__PURE__ */ new Map());
    this.workerLoader = e, this.controlModuleLoader = r, this.avmWasmLoader = n;
  }
  async hasService(e) {
    if (!this.workerThread)
      throw new Error("Worker is not initialized");
    return this.workerThread.hasService(e);
  }
  async removeService(e) {
    if (!this.workerThread)
      throw new Error("Worker is not initialized");
    await this.workerThread.removeService(e);
  }
  async start() {
    if (this.workerThread)
      throw new Error("Worker thread already initialized");
    await this.controlModuleLoader.start();
    const e = this.controlModuleLoader.getValue();
    await this.avmWasmLoader.start(), await this.workerLoader.start();
    const r = this.workerLoader.getValue(), n = await spawn(r), i = (o) => {
      const a = this.loggers.get(o.service);
      a && a[o.level](o.message);
    };
    n.onLogMessage().subscribe(i), await n.init(e), this.workerThread = n, await this.createService(this.avmWasmLoader.getValue(), "avm");
  }
  async createService(e, r) {
    if (!this.workerThread)
      throw new Error("Worker is not initialized");
    const n = logLevelToEnv("info");
    this.loggers.set(r, marineLogger(r)), await this.workerThread.createService(e, r, n);
  }
  async callService(e, r, n, i) {
    if (!this.workerThread)
      throw "Worker is not initialized";
    return this.workerThread.callService(e, r, n, i);
  }
  async stop() {
    this.workerThread && (await this.workerThread.terminate(), await Thread.terminate(this.workerThread));
  }
}
function registerNodeUtils(t, e, r) {
  registerService({
    peer: t,
    service: r,
    serviceId: e,
    def: {
      defaultServiceId: "node_utils",
      functions: {
        tag: "labeledProduct",
        fields: {
          read_file: {
            tag: "arrow",
            domain: {
              tag: "labeledProduct",
              fields: {
                path: {
                  tag: "scalar",
                  name: "string"
                }
              }
            },
            codomain: {
              tag: "unlabeledProduct",
              items: [
                {
                  tag: "struct",
                  name: "ReadFileResult",
                  fields: {
                    content: {
                      tag: "option",
                      type: {
                        tag: "scalar",
                        name: "string"
                      }
                    },
                    error: {
                      tag: "option",
                      type: {
                        tag: "scalar",
                        name: "string"
                      }
                    },
                    success: {
                      tag: "scalar",
                      name: "bool"
                    }
                  }
                }
              ]
            }
          }
        }
      }
    }
  });
}
class NodeUtils {
  constructor(e) {
    $(this, "securityGuard_readFile");
    this.peer = e, this.securityGuard_readFile = defaultGuard(this.peer);
  }
  async read_file(e, r) {
    if (!this.securityGuard_readFile(r))
      return {
        success: !1,
        error: "Security guard validation failed",
        content: null
      };
    try {
      return {
        success: !0,
        content: await new Promise((i, o) => {
          fs.readFile(e, (a, c) => {
            if (a) {
              o(a);
              return;
            }
            i(c);
          });
        }),
        error: null
      };
    } catch (n) {
      return {
        success: !1,
        error: n.message,
        content: null
      };
    }
  }
}
const doRegisterNodeUtils = (t) => {
  registerNodeUtils(t, "node_utils", new NodeUtils(t));
};
async function fetchResource$2(t, e) {
  return fetch(new globalThis.URL(`@fluencelabs/js-client@${e}/dist` + t, "https://unpkg.com/"));
}
async function fetchResource$1(t, e) {
  const r = await new Promise((n, i) => {
    const o = path__default.dirname(require$$7.fileURLToPath(import.meta.url)), a = path__default.join(o, "..", t);
    fs__default.readFile(a, (c, l) => {
      if (c) {
        i(c);
        return;
      }
      n(l);
    });
  });
  return new Response(r, {
    headers: {
      "Content-type": t.endsWith(".wasm") ? "application/wasm" : t.endsWith(".js") ? "application/javascript" : "application/text"
    }
  });
}
var it, ot;
const isNode$1 = typeof process$2 < "u" && ((ot = (it = process$2) == null ? void 0 : it.release) == null ? void 0 : ot.name) === "node";
async function fetchResource(t, e) {
  switch (!0) {
    case isNode$1:
      return fetchResource$1(t);
    default:
      return fetchResource$2(t, e);
  }
}
const avmWasmUrl = "/assets/2b9358811f6fdb2e.wasm", marineJsWasmUrl = "/assets/f8e44487e3436273.wasm", workerCodeUrl = "/assets/638dec84890fd2df.cjs", isFluencePeer = (t) => t instanceof FluencePeer, v5_callFunction = async (t, e, r) => {
  const { args: n, client: i, config: o } = await extractFunctionArgs(t, e);
  return callAquaFunction({
    args: n,
    def: e,
    script: r,
    config: o || {},
    peer: i
  });
}, v5_registerService = async (t, e) => {
  const { peer: r, service: n, serviceId: i } = await extractServiceArgs(t, e.defaultServiceId);
  return registerService({
    def: e,
    service: n,
    serviceId: i,
    peer: r
  });
}, extractFunctionArgs = async (t, e) => {
  const r = getArgumentTypes(e), n = Object.keys(r), i = n.length;
  let o, a, c;
  if (isFluencePeer(t[0]))
    o = t[0], a = t.slice(1, i + 1), c = t[i + 1];
  else {
    if (!Fluence.defaultClient)
      throw new Error(
        "Could not register Aqua service because the client is not initialized. Did you forget to call Fluence.connect()?"
      );
    o = Fluence.defaultClient, a = t.slice(0, i), c = t[i];
  }
  if (a.length !== i)
    throw new Error(`Incorrect number of arguments. Expecting ${i}`);
  const l = n.reduce((u, f, d) => ({ ...u, [f]: a[d] }), {});
  return {
    client: o,
    config: c,
    args: l
  };
}, extractServiceArgs = async (t, e) => {
  let r, n, i;
  if (isFluencePeer(t[0]))
    r = t[0];
  else {
    if (!Fluence.defaultClient)
      throw new Error(
        "Could not register Aqua service because the client is not initialized. Did you forget to call Fluence.connect()?"
      );
    r = Fluence.defaultClient;
  }
  return typeof t[0] == "string" ? n = t[0] : typeof t[1] == "string" ? n = t[1] : n = e, !isFluencePeer(t[0]) && typeof t[0] == "object" ? i = t[0] : typeof t[1] == "object" ? i = t[1] : i = t[2], {
    peer: r,
    serviceId: n,
    service: i
  };
}, getFluenceInterfaceFromGlobalThis = () => globalThis.fluence, REJECT_MESSAGE = `Could not load Fluence JS Client library.
If you are using Node.js that probably means that you forgot in install or import the @fluencelabs/js-client.node package.
If you are using a browser, then you probably forgot to add the <script> tag to your HTML.
Please refer to the documentation page for more details: https://fluence.dev/docs/build/js-client/installation
`, POLL_PEER_TIMEOUT = 5e3, POLL_PEER_INTERVAL = 100, getFluenceInterface = () => {
  const t = getFluenceInterfaceFromGlobalThis();
  return t ? Promise.resolve(t) : new Promise((e, r) => {
    let n, i = POLL_PEER_TIMEOUT / POLL_PEER_INTERVAL;
    n = setInterval(() => {
      i === 0 && (clearInterval(n), r(REJECT_MESSAGE));
      let o = getFluenceInterfaceFromGlobalThis();
      o && (clearInterval(n), e(o)), i--;
    }, POLL_PEER_INTERVAL);
  });
}, JS_CLIENT_VERSION = "0.1.7";
var st, at;
const isNode = typeof process$2 < "u" && ((at = (st = process$2) == null ? void 0 : st.release) == null ? void 0 : at.name) === "node", fetchWorkerCode = () => fetchResource(workerCodeUrl, JS_CLIENT_VERSION).then((t) => t.text()), fetchMarineJsWasm = () => fetchResource(marineJsWasmUrl, JS_CLIENT_VERSION).then((t) => t.arrayBuffer()), fetchAvmWasm = () => fetchResource(avmWasmUrl, JS_CLIENT_VERSION).then((t) => t.arrayBuffer()), createClient = async (t, e) => {
  const r = await fetchWorkerCode(), n = await fetchMarineJsWasm(), i = await fetchAvmWasm(), o = new MarineBackgroundRunner({
    getValue() {
      return BlobWorker.fromText(r);
    },
    start() {
      return Promise.resolve(void 0);
    },
    stop() {
      return Promise.resolve(void 0);
    }
  }, {
    getValue() {
      return n;
    },
    start() {
      return Promise.resolve(void 0);
    },
    stop() {
      return Promise.resolve(void 0);
    }
  }, {
    getValue() {
      return i;
    },
    start() {
      return Promise.resolve(void 0);
    },
    stop() {
      return Promise.resolve(void 0);
    }
  }), { keyPair: a, peerConfig: c, relayConfig: l } = await makeClientPeerConfig(t, e), u = new ClientPeer(c, l, a, o);
  return isNode && doRegisterNodeUtils(u), await u.connect(), u;
}, Fluence = {
  defaultClient: void 0,
  /**
   * Connect to the Fluence network
   * @param relay - relay node to connect to
   * @param config - client configuration
   */
  connect: async function(t, e) {
    const r = await createClient(t, e);
    this.defaultClient = r;
  },
  /**
   * Disconnect from the Fluence network
   */
  disconnect: async function() {
    var t;
    await ((t = this.defaultClient) == null ? void 0 : t.disconnect()), this.defaultClient = void 0;
  },
  /**
   * Handle connection state changes. Immediately returns the current connection state
   */
  onConnectionStateChange(t) {
    var e;
    return ((e = this.defaultClient) == null ? void 0 : e.onConnectionStateChange(t)) || "disconnected";
  },
  /**
   * Low level API. Get the underlying client instance which holds the connection to the network
   * @returns IFluenceClient instance
   */
  getClient: async function() {
    if (!this.defaultClient)
      throw new Error("Fluence client is not initialized. Call Fluence.connect() first");
    return this.defaultClient;
  }
};
globalThis.new_fluence = Fluence;
globalThis.fluence = {
  clientFactory: createClient,
  callAquaFunction,
  registerService
};
export {
  Fluence,
  callAquaFunction,
  createClient,
  getFluenceInterface,
  getFluenceInterfaceFromGlobalThis,
  registerService,
  v5_callFunction,
  v5_registerService
};
